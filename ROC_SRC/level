affect.c:		SET_BIT( ch->affected_by, paf->bitvector );
affect.c:      REMOVE_BIT( ch->affected_by, paf->bitvector );
affect.c:					paf->location, ch->name );
affect.c:			ch->mod_str += mod;				
affect.c:			ch->mod_dex += mod;				
affect.c:			ch->mod_int += mod;				
affect.c:			ch->mod_wis += mod;				
affect.c:			ch->mod_con += mod;			    
affect.c:			ch->sex			+= mod; 
affect.c:			int  nNewRace    = ch->race + mod;
affect.c:			bOrgFlyStat = IS_SET(race_table[ ch->race ].race_abilities, RACE_FLY);
affect.c:				ch->dodge += nRaceSklv * 2 + (nRaceSklv * nRaceSklv) / 2;
affect.c:				ch->dodge -= race_table[ch->race].size * 5;
affect.c:				ch->dodge -= nRaceSklv * 2 + (nRaceSklv * nRaceSklv) / 2;
affect.c:				ch->dodge += race_table[nNewRace].size * 5;
affect.c:			ch->race	= nNewRace;
affect.c:			ch->carry_weight += mod;
affect.c:			ch->max_mana		+= mod; 
affect.c:			ch->max_hit		+= mod; 
affect.c:			ch->max_move		+= mod; 
affect.c:			ch->armor += mod; 
affect.c:			ch->hitroll	+= mod; 
affect.c:			ch->damroll	+= mod; 
affect.c:			ch->saving_throw[0]	+= mod; 
affect.c:			ch->saving_throw[MAGIC_BREATH] += mod; 
affect.c:			ch->saving_throw[0]	+= mod; 
affect.c:			ch->saving_throw[MAGIC_EARTH] += mod; 
affect.c:			ch->saving_throw[MAGIC_EARTH] += mod; 
affect.c:			ch->saving_throw[MAGIC_SAINT] += mod; 
affect.c:			ch->saving_throw[MAGIC_DARK]  += mod; 
affect.c:			ch->saving_throw[MAGIC_LIGHTNING] += mod; 
affect.c:			ch->saving_throw[MAGIC_WIND] += mod; 
affect.c:			ch->saving_throw[MAGIC_POISON] += mod;
affect.c:			ch->saving_throw[0] += mod;
affect.c:			ch->saving_throw[MAGIC_FIRE]		+= mod; 
affect.c:			ch->saving_throw[MAGIC_WIND]		+= mod; 
affect.c:			ch->saving_throw[MAGIC_COLD]		+= mod; 
affect.c:			ch->saving_throw[MAGIC_EARTH]		+= mod; 
affect.c:			ch->saving_throw[MAGIC_LIGHTNING]	+= mod;
affect.c:			ch->saving_throw[MAGIC_BREATH] += mod; 
affect.c:			ch->saving_throw[MAGIC_FIRE] += mod; 
affect.c:			ch->saving_throw[MAGIC_COLD] += mod; 
affect.c:			ch->pdr += mod; 
affect.c:			ch->mdr += mod; 
affect.c:			ch->apdr += mod; 
affect.c:			ch->amdr += mod; 
affect.c:			if( IS_NPC(ch) ) ch->pad += mod; 
affect.c:			if( IS_NPC(ch) ) ch->mad += mod; 
affect.c:			ch->pp += mod; 
affect.c:			ch->dodge += mod; 
affect.c:	ch->hit  = UMIN( ch->hit, ch->max_hit );
affect.c:	ch->mana = UMIN( ch->mana, ch->max_mana );
affect.c:	ch->move = UMIN( ch->move, ch->max_move );
affect.c:    paf_new->next	= ch->affected;
affect.c:    ch->affected	= paf_new;
affect.c:    if ( !ch->affected )
affect.c:	ch->position = POS_STANDING;
affect.c:        && ( ch->in_room                                            )
affect.c:        if ( ch->in_room->area != pRoomIndex->area )
affect.c:	for ( paf = ch->affected; paf; paf = paf->next ){
affect.c:	for ( paf = ch->affected; paf; paf = paf->next ){
affect.c:    for ( paf = ch->affected; paf; paf = paf->next )
affect.c:	for ( paf_old = ch->affected; paf_old; paf_old = paf_old->next ){
clan.c:  to = ch->in_room->people;
clan.c:      if( !vch->in_room )//amenda 6/2/01 for debug purpose
clan.c:          bug( vch->name, 0 );
clan.c:      to = vch->in_room->people;
clan.c:       // if( (to && ( to->clan != ch->clan && to->clan_channel != ch->clan->whoname 
clan.c:       if( to->clan != ch->clan && !to->clan_channel ) continue;
clan.c:           if( to->clan_channel != ch->clan->whoname 
clan.c:               && to->clan != ch->clan )
clan.c:       sprintf(buf, "%s【%s】", HIY, ch->clan->whoname);
clan.c:    if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_NO_EMOTE ) )
clan.c:    switch ( ch->position )
clan.c:      original = ch->in_room;
clan.c:    free_string( ch->pcdata->clantitle );
clan.c:    ch->pcdata->clantitle = str_dup( buf );
clan.c:    if ( IS_NPC( ch ) || ( ch->desc && ch->desc->original ) )
clan.c:    if ( !ch->in_room || ch->in_room->vnum != 11000)
clan.c:      if ( !str_cmp( cn->founder, ch->name) )
clan.c:      if ( ch->bank < 8000000 )
clan.c:      if ( ch->pcdata->respect < 2 || ch->level < 38 )
clan.c:    if ( ch->clan )
clan.c:      ch->bank -= 8000000;
clan.c:      ch->pcdata->respect += 5;
clan.c:      ch->pcdata->clanlevel = 5;
clan.c:    strcpy( buf, ch->name );
clan.c:    sprintf(buf, "%s%s.clan", CLAN_DIR, ch->name);
clan.c:    ch->clan = cn;
clan.c:        cn->name, ch->name );
clan.c:  if( IS_NPC(ch) || !ch->clan ) {return;}
clan.c:  //strcpy(clan_name, ch->clan->name);
clan.c:  || victim->clan != ch->clan ){
clan.c:  if ( ch->pcdata->clanlevel < 5 )
clan.c:  free_string(ch->clan->leader);
clan.c:  ch->clan->leader = str_dup( victim->name );
clan.c:  ch->clan->score -= ch->clan->cclass * 5000;
clan.c:  ch->pcdata->clanlevel = 4;
clan.c:  ch->pcdata->respect -= 2;
clan.c:    ch->cname,
clan.c:    ch->name,
clan.c:    ch->clan->name,
clan.c:    if ( ch->clan )
clan.c:      if ( !ch->clan_join )
clan.c:      sprintf( buf, "你打消加入%s的念頭！\n\r", ch->clan_join );
clan.c:          ch->clan_join,
clan.c:          ch->short_descr,
clan.c:            if( victim->clan->whoname != ch->clan_join && !victim->clan_channel ) continue;
clan.c:              if ( victim->clan_channel != ch->clan_join )
clan.c:      ch->clan_join = NULL;
clan.c:        ch->clan_join = cn->whoname;
clan.c:        sprintf( buf, "你希望加入的幫派是：%s！\n\r", ch->clan_join );
clan.c:          ch->clan_join,
clan.c:          ch->short_descr,
clan.c:            if( victim->clan->whoname != ch->clan_join && !victim->clan_channel ) continue;
clan.c:              if ( victim->clan_channel != ch->clan_join )
clan.c:    if( !ch->clan_join )
clan.c:  if( !ch->clan ) return;
clan.c:  if( ch->pcdata->clanlevel < 3 ) {
clan.c:  if( !IS_PPLBUILDER(ch, pRoom->area)|| !IS_PPLBUILDER(ch, ch->in_room->area)){
clan.c:  if( !( ch->clan ) ) return;
clan.c:  //strcpy(clan_name, ch->clan->name);
clan.c:    ch->clan->whoname,
clan.c:    ch->short_descr,
clan.c:    //ch->name,
clan.c:      if( victim->clan != ch->clan && !victim->clan_channel ) continue;
clan.c:      if ( victim->clan_channel != ch->clan->whoname 
clan.c:           && victim->clan != ch->clan )
clan.c:  if( !( ch->clan ) ) return;
clan.c:  if( !ch->clan ) return;
clan.c:    if ( ch->clan->whoname != victim->clan_join )
clan.c:    if ( IS_NPC( victim ) || ch->pcdata->clanlevel < 3 )
clan.c:    if ( ch->clan->bank < 100000 )
clan.c:    ch->clan->bank -= 100000;
clan.c:                    ch->clan->score += victim->level * 10;
clan.c:                    ch->clan->score += UMIN( victim->level * (victim->level + victim->level / 3), 1000);
clan.c:    ch->clan->member[0] +=1;
clan.c:        ch->clan->name );
clan.c:    victim->clan = ch->clan;
clan.c:      victim->cname,victim->name, ch->cname, ch->clan->name, ch->clan->name );
clan.c:  if( !ch->clan ) return;
clan.c:    if ( ch->pcdata->clanlevel < 3 )
clan.c:    if( ch->pcdata->clanlevel <= victim->pcdata->clanlevel )
clan.c:    if( ch->clan != victim->clan ) {
clan.c:      if ( ch->clan->bank < 200000 )
clan.c:      ch->clan->bank -= 200000;
clan.c:      ch->clan->score -= 1000;
clan.c:    ch->clan->member[0] -= 1;
clan.c:      ch->cname, victim->cname, ch->clan->name );
clan.c:  if( !ch->clan ) return;
clan.c:    if ( ch->pcdata->clanlevel > 4 )
clan.c:    if( ch->pcdata->clanlevel > 2 ) {
clan.c:      if ( ch->gold < 100000 )
clan.c:      if ( !ch->clan )
clan.c:      ch->gold -= 100000;
clan.c:    ch->pcdata->respect -= 2;
clan.c:        ch->clan->name );
clan.c:      ch->cname,ch->name, ch->clan->name );
clan.c:    ch->clan->score -= 1000;
clan.c:    ch->clan->member [0]-=1;
clan.c:    ch->clan = NULL;
clan.c:      if ( !ch->clan )
clan.c:        //strcpy(clan_name, ch->clan->name);
clan.c:        vclan = ch->clan;
clan.c:        //vclan = ch->clan;
clan.c:    if( ch->pcdata->clanlevel > 0 && ch->clan == vclan ) {
clan.c:          if( (ch->pcdata->clanlevel > 3 && ch->clan == vclan) || IS_IMMORTAL(ch))
clan.c:    if ( !ch->clan )
clan.c:    if ( ch->pcdata->clanlevel < 3 )
clan.c:    for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
clan.c:      if ( IS_SET( vch->act, ACT_BANKER ) )
clan.c:      if ( num < ch->clan->bank )
clan.c:        ch->gold += num;
clan.c:        ch->clan->bank -= ( num );
clan.c:        ch->pcdata->clanstatistics -= num;
clan.c:    if ( !ch->clan )
clan.c:    for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
clan.c:      if ( IS_SET( vch->act, ACT_BANKER ) )
clan.c:      if ( num < ch->gold )
clan.c:        ch->gold -= num;
clan.c:        ch->clan->bank += num;
clan.c:        ch->pcdata->clanstatistics += num;
clan.c:  if( !ch->clan ) return;
clan.c:    if ( ch->pcdata->clanlevel < 4 )
clan.c:    if ( victim->clan != ch->clan || IS_NPC( victim ) )
clan.c:                if( ch->pcdata->clanlevel <= victim->pcdata->clanlevel 
clan.c:                ||  ch->pcdata->clanlevel <= level ) {
clan.c:    if ( ch->clan->bank < level * level * 10000 )
clan.c:    ch->clan->member[victim->pcdata->clanlevel] -=1;
clan.c:    ch->clan->member[level] +=1;
clan.c:    ch->clan->bank -= level * level * 10000;
clan.c:  if( !ch->clan ) return;
clan.c:    if ( ch->pcdata->clanlevel == 0 )
clan.c:    if ( !ch->clan || !victim->clan )
clan.c:    if ( victim != ch && victim->pcdata->clanlevel >= ch->pcdata->clanlevel )
clan.c:    if ( ch->clan != victim->clan )
clan.c:        || ( ch->clan == cn && ch->pcdata->clanlevel > 3 ))
clan.c:    if ( !ch->clan || ch->pcdata->clanlevel < 4 )
clan.c:    if ( ch->clan->desc )
clan.c:      strcpy( buf, ch->clan->desc );
clan.c:    if(ch->clan->desc)
clan.c:        free_string( ch->clan->desc );
clan.c:    ch->clan->desc = str_dup( buf );
clan.c:    if ( !ch->clan || ch->pcdata->clanlevel < 4 )
clan.c:    if( ch->clan->desc )
clan.c:        free_string( ch->clan->desc );
clan.c:    ch->clan->desc = NULL;
clan.c:      if ( !ch->clan || ch->pcdata->clanlevel < 4 )
clan.c:      if ( ch->clan->bank < 1000000 )
clan.c:        if ( ch->clan->score < cc[i].exp )
clan.c:      if ( ch->clan->cclass < i )
clan.c:        ch->clan->cclass++;
clan.c:        ch->clan->bank -= 1000000;
clan.c:        ch->clan->name );
clan.c:      sprintf( buf, "%s"HIY"現在已是一個"NOR" %s "HIY"的組織！"NOR"\n\r", ch->clan->name, cc[ch->clan->cclass].name );
clan.c:        sprintf( buf, "你的組織還需要 %d 點發展點數才能升級。\n\r", cc[i].exp - ch->clan->score );
clan.c:    if ( !ch->clan || ch->pcdata->clanlevel < 3 || mch->clan != ch->clan
clan.c:      || lch->clan != ch->clan || !IS_NPC( mch ) )
clan.c:    if ( mch->level > lch->level + 5 )
clan.c:    mch->master = lch;
clan.c:      if ( ch->pcdata->clanlevel < 3 )
clan.c:      if ( ch->clan == clan_war->clan_a || ch->clan == clan_war->clan_b )
clan.c:      if ( !IS_SET( ch->act, PLR_REGISTER ) )
clan.c:      if ( ch->clan->bank < 500000 )
clan.c:      ch->clan->bank -= 500000;
clan.c:        clan_war->clan_a = ch->clan;
clan.c:        for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
clan.c:          if ( !IS_NPC( vch ) && vch->desc && IS_SET( vch->act, PLR_REGISTER )
clan.c:            && vch->clan == ch->clan )
clan.c:            vch->pcdata->clanpk = 1;
clan.c:        clan_war->clan_b = ch->clan;
clan.c:        for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
clan.c:          if ( !IS_NPC( vch ) && vch->desc && IS_SET( vch->act, PLR_REGISTER )
clan.c:            && vch->clan == ch->clan )
clan.c:            vch->pcdata->clanpk = 1;
clan.c:      if ( ch->pcdata->clanlevel < 3 )
clan.c:      if ( ch->clan == clan_war->clan_a )
clan.c:            cn = ch->clan;
clan.c:            if ( IS_IMMORTAL( ch ) || ( ch->pcdata->clanlevel > 2 && ch->clan == cn ) )
clan.c:  if( !ch->clan ) return;
clan.c:    ch->clan->name,
clan.c:    ch->cname,
clan.c:    ch->name,
clan.c:      if( victim && victim->clan == ch->clan ){
clan.c:    if( !ch->in_room || !ch->clan) return;
clan.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
clan.c:    place = ch->clan->crecall;
clan.c:    if( !(ch->in_room->area->recall == location->area->recall ))
clan.c:    if ( ch->in_room == location )
clan.c:    if ( ( victim = ch->fighting ) )
clan.c:      lose = ( ch->desc ) ? 12 : 25;
clan.c:  lose = ( ch->desc ) ? 25 : 50;
clan.c:    ch->move /= 2;
clan.c:    if ( ch->in_room->roomprogs && ( ch->in_room->progtypes & ROOM_LEAVE )
clan.c:  && !IS_SET( ch->act, PLR_WIZINVIS ) )
clan.c:  rprog_leave_trigger( ch->in_room, ch, 6 );
clan.c:  if ( IS_SET( ch->act, PLR_HORSE ) && ch->desc )
clan.c:    horse = ch->pcdata->horse;
clan.c:  if ( ch->pcdata && ch->pcdata->horse && ch->pcdata->horse )
clan.c:    if ( ch->in_room != ( horse = ch->pcdata->horse )->in_room )
comm.c:    CHAR_DATA *phorse = ch->pcdata->horse;
comm.c:    phorse = ch->pcdata->horse;
comm.c:    if ( ch->position == POS_FIGHTING )
comm.c:    if ( ch->in_room->roomprogs && ( ch->in_room->roomprogs->type & ROOM_LEAVE )
comm.c:  && !IS_SET( ch->act, PLR_WIZINVIS ) )
comm.c:    rprog_leave_trigger( ch->in_room, ch, 7 );
comm.c:    sprintf( log_buf, "%s close socket force quit.", ch->name );
comm.c:    for ( obj = ch->carrying; obj; obj = obj_next_content )
comm.c:      || ( ch->level < ( obj->level - 5 ) && ch->class < 5 ) )
comm.c:        obj_to_room( obj, ch->in_room );
comm.c:  sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c:	if( ch->neweqbank )
comm.c:		sprintf( tmp, "%s%s/%s", EQBANK_DIR, initial ( ch->neweqbank->name), capitalize (ch->neweqbank->name) );
comm.c:		ch->neweqbank->opened = FALSE;
comm.c:			free_neweqbank (ch->neweqbank);
comm.c:			ch->neweqbank = NULL;
comm.c:      if( ch->desc && ch->desc->original && ch->desc->original->pcdata 
comm.c:        && ch->desc->original->pcdata->switched )
comm.c:        CHAR_DATA * och = ch->desc->original;
comm.c:      if( IS_SET( ch->act, PLR_HORSE ) )
comm.c:      ch->desc = NULL;
comm.c:  sprintf( log_buf, "%s Reconnected.", ch->name );
comm.c:      if( ch->desc && ch->desc->original && ch->desc->original->pcdata 
comm.c:        && ch->desc->original->pcdata->switched )
comm.c:    if( IS_SET(ch->act, PLR_HORSE ))
comm.c:        CHAR_DATA * och = ch->desc->original;
comm.c:    ch->desc->character = ch->desc->original;
comm.c:    ch->desc->original = NULL;
comm.c:    ch->desc->character->pcdata->switched = FALSE;
comm.c:    ch->desc->character->desc = ch->desc;
comm.c:      ch->desc = NULL;
comm.c:      if ( IS_SET( ch->act, PLR_BLANK ) )
comm.c:      if ( IS_SET( ch->act, PLR_PROMPT  ) )
comm.c:      //if ( IS_SET( ch->act, PLR_TELNET_GA ) )
comm.c:   if( !ch->pcdata->prompt || ch->pcdata->prompt[0] == '\0' )
comm.c:   str = ch->pcdata->prompt;
comm.c:      if ( ch->hit > ch->max_hit * 3 / 4 )
comm.c:    else if ( ch->hit > ch->max_hit / 2 )
comm.c:    else if ( ch->hit > ch->max_hit / 4 )
comm.c:      sprintf( buf3, "%d[m", ch->hit );
comm.c:      sprintf( buf2, "%d", ch->max_hit             );
comm.c:      sprintf( buf2, "%d", ch->mana            );
comm.c:      sprintf( buf2, "%d", ch->max_mana            );
comm.c:      sprintf( buf2, "%d", ch->move            ); 
comm.c:      sprintf( buf2, "%d", ch->max_move            );
comm.c:      sprintf( buf2, "%d", ch->exp             );
comm.c:      sprintf( buf2, "%d", ch->level );
comm.c:      sprintf( buf2, "%d",  EXP_PER_LEVEL( ch->level ,ch->class) * (ch->level + 1 ) - ch->exp );
comm.c:      sprintf( buf2, "%d", ch->gold            );
comm.c:      sprintf( buf2, "%d", ch->wait            );
comm.c:      if( ch->level > 10 )
comm.c:         sprintf( buf2, "%d", ch->alignment          );
comm.c:      if( ch->in_room )
comm.c:         sprintf( buf2, "%s", ch->in_room->name          );
comm.c:      if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:         sprintf( buf2, "%d", ch->in_room->vnum          );
comm.c:      if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:         sprintf( buf2, "%s", ch->in_room->area->name        );
comm.c:         sprintf( buf2, "(wizinv: %s)", IS_SET( ch->act, PLR_WIZINVIS ) ?
comm.c:   if( !ch->pcdata || !ch->pcdata->prompt || ch->pcdata->prompt[0] == '\0' )
comm.c:   str = ch->pcdata->prompt;
comm.c:      sprintf( buf2, "%d", ch->hit             );
comm.c:      sprintf( buf2, "%d", ch->max_hit             );
comm.c:      sprintf( buf2, "%d", ch->mana            );
comm.c:      sprintf( buf2, "%d", ch->max_mana            );
comm.c:      sprintf( buf2, "%d", ch->move            ); 
comm.c:      sprintf( buf2, "%d", ch->max_move            );
comm.c:      sprintf( buf2, "%d", ch->exp             );
comm.c:      sprintf( buf2, "%d", ch->level );
comm.c:      sprintf( buf2, "%d",  EXP_PER_LEVEL( ch->level,ch->class ) * (ch->level + 1 ) - ch->exp );
comm.c:      sprintf( buf2, "%d", ch->gold            );
comm.c:      sprintf( buf2, "%d", ch->wait            );
comm.c:      if( ch->level > 10 )
comm.c:         sprintf( buf2, "%d", ch->alignment          );
comm.c:      if( ch->in_room )
comm.c:         sprintf( buf2, "%s", ch->in_room->name          );
comm.c:      if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:         sprintf( buf2, "%d", ch->in_room->vnum          );
comm.c:      if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:         sprintf( buf2, "%s", ch->in_room->area->name        );
comm.c:         sprintf( buf2, "(wizinv: %s)", IS_SET( ch->act, PLR_WIZINVIS ) ?
comm.c:      if ( IS_SET( ch->act, PLR_DENY ) )
comm.c:        if( IS_NPC(ch) || time(NULL) <= ch->pcdata->denied ){
comm.c:        else REMOVE_BIT(ch->act, PLR_DENY);
comm.c:            &&  !IS_SET( ch->act, PLR_WIZBIT ) 
comm.c:        if ( ch->level <= numlock
comm.c:            && !IS_SET( ch->act, PLR_WIZBIT )
comm.c:          if ( ch->level == 0 )
comm.c:      if ( /*!IS_SET( ch->act, PLR_REPLACE ) &&*/ ch->level < L_APP )
comm.c:        if ( check_playing( d, ch->name ) )
comm.c:      if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:      if ( check_reconnect( d, ch->name, TRUE ) )
comm.c:      if ( check_playing( d, ch->name) )
comm.c:      sprintf( log_buf, "%s, $U@$H has connected.", ch->name );
comm.c:      lines = ch->pcdata->pagelen;
comm.c:      ch->pcdata->pagelen = 40;
comm.c:      ch->pcdata->pagelen = lines;
comm.c:      //  ch->next  = char_list;
comm.c:          set_cname( ch, ch->name );
comm.c:              ch->name, echo_off_str );
comm.c:      pwdnew = crypt( argument, ch->name );
comm.c:      free_string( ch->pcdata->pwd );
comm.c:      ch->pcdata->pwd        = str_dup( pwdnew );
comm.c:      if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:          ch->race = race_lookup( race_table[iRace].name );
comm.c:      do_help( ch, race_table[ch->race].name );
comm.c:        case 'm': case 'M': ch->sex = SEX_MALE;    break;
comm.c:        case 'f': case 'F': ch->sex = SEX_FEMALE;  break;
comm.c:        case 'n': case 'N': ch->sex = SEX_NEUTRAL; break;
comm.c:          ch->class = iClass;
comm.c:      switch ( ch->class )
comm.c:        bug( "Nanny CON_GET_NEW_CLASS:  ch->class (%d) not valid",
comm.c:            ch->class );
comm.c:      sprintf( log_buf, "%s, $U@$H new player.", ch->name );
comm.c:      ch->pcdata->pagelen = 20;
comm.c:      //  ch->dodge += race_table[ ch->race ].nature_dodge;
comm.c:      //  ch->armor += race_table[ ch->race ].nature_ac;
comm.c:      ch->next  = char_list;
comm.c:      if ( ch->level == 0 )
comm.c:        switch ( class_table[ch->class].attr_prime )
comm.c:          case APPLY_STR: ch->perm_str = 16; break;
comm.c:          case APPLY_INT: ch->perm_int = 16; break;
comm.c:          case APPLY_WIS: ch->perm_wis = 16; break;
comm.c:          case APPLY_DEX: ch->perm_dex = 16; break;
comm.c:          case APPLY_CON: ch->perm_con = 16; break;
comm.c:        switch ( ch->class )
comm.c:          case MAGE :   ch->pcdata->prime_attr = APPLY_INT;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:          case CLERIC :   ch->pcdata->prime_attr = APPLY_WIS;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:          case THIEF :  ch->pcdata->prime_attr = APPLY_DEX;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:          case WARRIOR :  ch->pcdata->prime_attr = APPLY_STR;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:          case BARBARIAN :ch->pcdata->prime_attr = APPLY_CON;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:        ch->level      = 1;
comm.c:        ch->exp    = 1000;
comm.c:        ch->gold  = 10000 + number_fuzzy( 3 )
comm.c:        ch->hit    = ch->max_hit;
comm.c:        ch->mana      = ch->max_mana;
comm.c:        ch->move      = ch->max_move;
comm.c:            c_title_table [ch->class] [ch->level]
comm.c:            [ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c:        free_string( ch->pcdata->prompt );
comm.c:        ch->pcdata->prompt = str_dup( "[m<生命[1;32m%h[m魔法[1;34m%m[m移動[1;35m%v[m> " );
comm.c:        if ( !IS_SET( race_table[ ch->race ].race_abilities, RACE_BEHOLDER ) )
comm.c:              get_obj_index( class_table[ch->class].weapon ),
comm.c:      else if ( ch->in_room )
comm.c:        char_to_room( ch, ch->in_room );
comm.c:        if ( IS_SET( ch->pcdata->ride, 1 ) )
comm.c:        sprintf( log_buf, "Load %s's horse.", ch->name );
comm.c:        horse = load_horse_obj( d, ch->name );
comm.c:        ch->pcdata->ride = 0;
comm.c:        ch->pcdata->horse = NULL;
comm.c:        char_to_room( horse, ch->in_room );
comm.c:        ch->pcdata->horse = horse;
comm.c:         if ( ch->gold + ch->bank > 10000000 )
comm.c:         bug( ch->name, 0 );
comm.c:         bug( "gold + bank = %d", ch->gold + ch->bank );
comm.c:         ch->gold = 1000000;
comm.c:         ch->bank = 0;  
comm.c:      if ( !IS_SET( ch->act, PLR_WIZINVIS )
comm.c:        if ( is_note_to( ch, pnote ) && str_cmp( ch->name, pnote->sender )
comm.c:            && pnote->date_stamp > ch->last_note )
comm.c:  if( !ch->desc)
comm.c:  ch_d = ch->desc;
comm.c:    if( !str_cmp( ch->name , to->name )) 
comm.c:      strcat(buf, ch->name);
comm.c:    for ( ch = char_list; ch; ch = ch->next )
comm.c:  if ( ch->deleted || IS_NPC( ch ) || IS_SET(ch->act, PLR_HORSE))
comm.c:  if ( ( !fConn || !ch->desc /*|| IS_SET( ch->act, PLR_REPLACE)*/ )
comm.c:      && !str_cmp( d->character->name, ch->name))
comm.c:    d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:    ch->desc->original->pcdata->switched  = FALSE;
comm.c:    ch->desc->character = horse;
comm.c:    ch->desc->original = NULL;
comm.c:    horse->desc = ch->desc;
comm.c:    ch->desc = NULL;
comm.c:    ch->leader = horse;
comm.c:    if( IS_SET(ch->act, PLR_HORSE ) && ch->desc)
comm.c:    else if( ch->pcdata->switched ) {
comm.c:        if( !ch->desc ) {
comm.c:/*  有兩種取代，一是斷線取代(ch->desc == NULL)，二是沒斷線硬取代(ch->desc != NULL)
comm.c:  如果是硬取代，沒有下馬，但我們可以 check ch->pcdata->ride == 2 得知正在騎馬。
comm.c:    if ( IS_SET( ch->pcdata->ride, 2 ) )
comm.c:      do_ride( ch->pcdata->horse, "" );//強迫下馬，讓事情單純化。
comm.c:    if ( ch->pcdata->switched )//現在有硬取代，必須 check imm switch 的情況
comm.c:      for( och = char_list; och; och = och->next )
comm.c:        if ( och->desc && och->desc->original == ch )
comm.c:    if ( ch->desc )
comm.c:      close_socket2( ch->desc );
comm.c:    ch->desc     = d;
comm.c:    ch->timer    = 0;
comm.c:    sprintf( log_buf, "%s, $U@$H reconnected.", ch->name );
comm.c:  || !ch->desc
comm.c:  ||  ch->desc->connected != CON_PLAYING
comm.c:  || !ch->was_in_room
comm.c:  ||  ch->in_room != get_room_index( ROOM_VNUM_LIMBO ) )
comm.c:    ch->timer = 0;
comm.c:    char_to_room( ch, ch->was_in_room );
comm.c:    ch->was_in_room    = NULL;
comm.c:    if ( !txt || !ch ||!ch->desc )
comm.c:    if ( ch->desc->showstr_point )
comm.c:        int diff = (int)( ch->desc->showstr_point - ch->desc->showstr_head);
comm.c:        strcpy( buf, ch->desc->showstr_head );
comm.c:        free_string( ch->desc->showstr_head );
comm.c:        ch->desc->showstr_head = str_dup( buf );
comm.c:        ch->desc->showstr_point = ch->desc->showstr_head + diff;
comm.c:        write_to_buffer( ch->desc, txt, strlen( txt ) );
comm.c:        free_string( ch->desc->showstr_head );
comm.c:        ch->desc->showstr_head  = str_dup( txt );
comm.c:        ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:        show_string( ch->desc, "" );
comm.c:    if( ch->deleted ) {
comm.c:    if( ! ch->in_room ) {
comm.c:  bug(" Act: no ch->in_room !",0);
comm.c:    to = ch->in_room->people;
comm.c:  if ( !vch->in_room )//amenda 6/2/01 for debug purpose
comm.c:    bug( vch->name, 0 );
comm.c:  to = vch->in_room->people;
comm.c:    if( ch->deleted ) {
comm.c:    if( ! ch->in_room ) {
comm.c:  bug(" Combat_info: no ch->in_room !",0);
comm.c:    to = ch->in_room->people;
comm.c:  if ( !vch->in_room )//amenda 6/2/01 for debug purpose
comm.c:    bug( vch->name, 0 );
comm.c:  to = vch->in_room->people;
comm.c:    if( ch->deleted ) 
comm.c:	if( ch->position == POS_MORTAL )
db.c:        for ( pch = char_list; pch; pch = pch->next )
db.c:          && pch->in_room
db.c:          && pch->in_room->area == pArea )
db.c:        for ( pch = char_list; pch; pch = pch->next )
db.c:          && pch->in_room
db.c:          && pch->in_room->area == pArea )
db.c:      for( lch = char_list; lch; lch = lch->next )
db.c:      if ( lch->pIndexData == pMobIndex )
db.c:      for( vch = char_list; vch; vch = vch->next )
db.c:      if ( vch->pIndexData == pMobIndex )
db.c:      if ( vch->master )
db.c:            if( !lch->group ) {
db.c:      //vch->leader = lch;
db.c:        /*vch->protecting = lch;
db.c:    vch->next_in_protect = lch->protector;
db.c:        lch->protector = vch;*/
db.c:    for ( ch = pRoomIndex->people; ch; ch = ch->next_in_room )
db.c:        if ( IS_NPC( ch ) && ch->pIndexData == pMobIndex )
db.c:      for( lch = char_list; lch; lch = lch->next )
db.c:      if ( lch->pIndexData == pMobIndex )
db.c:      for( vch = char_list; vch; vch = vch->next )
db.c:      if ( vch->pIndexData == pMobIndex )
db.c:      if ( vch->master )
db.c:      vch->leader = lch;
db.c:      ch->pcdata  = alloc_mem( sizeof( *ch->pcdata ) );
db.c:      ch->pcdata  = pcdata_free;
db.c:  *ch->pcdata = pcdata_zero;
db.c:  ch->saving_throw[i] = 0;
db.c:    ch->deleted = FALSE;
db.c:    ch->mdr = 0;
db.c:    ch->dodge = 0;
db.c:    ch->pdr = 0;
db.c:    ch->pp = 0;
db.c:    ch->protector = NULL;
db.c:    ch->protecting = NULL;
db.c:    ch->next_in_protect = NULL;
db.c:    ch->tracking = NULL;
db.c:    ch->tracked = NULL;
db.c:    ch->next_in_track = NULL;
db.c:    ch->hunting = NULL;
db.c:    ch->hunted = NULL;
db.c:    ch->next_in_hunt = NULL;
db.c:    ch->rembch = NULL;
db.c:    ch->rembed = NULL;
db.c:    ch->rrembed = NULL;
db.c:    ch->next_in_rember = NULL;
db.c:    ch->assassinating = NULL;
db.c:    ch->assassinated = NULL;
db.c:    ch->next_in_ass = NULL;
db.c:    ch->perm_str = 0;
db.c:    ch->perm_dex = 0;
db.c:    ch->perm_int = 0;
db.c:    ch->perm_wis = 0;
db.c:    ch->perm_con = 0;
db.c:    ch->pad = 0;
db.c:    ch->mad = 0;
db.c:    ch->amdr = 0;
db.c:    ch->apdr = 0;
db.c:    ch->mod_str = 0;
db.c:    ch->mod_dex = 0;
db.c:    ch->mod_int = 0;
db.c:    ch->mod_wis = 0;
db.c:    ch->clan = NULL;
db.c:    ch->mod_con = 0;
db.c:    ch->group = NULL;
db.c:    ch->name      = &str_empty[0];
db.c:/*    ch->cname     = &str_empty[0];*/
db.c:    ch->short_descr   = &str_empty[0];
db.c:    ch->long_descr    = &str_empty[0];
db.c:    ch->description   = &str_empty[0];
db.c:    ch->last_note   = 0;
db.c:    ch->logon     = current_time;
db.c:    ch->armor     = 100;
db.c:    ch->position    = POS_STANDING;
db.c:    ch->level     = 0;
db.c:    ch->race      = 0;
db.c:    ch->practice    = 21;
db.c:    ch->hit     = 20;
db.c:    ch->max_hit     = 20;
db.c:    ch->mana      = 100;
db.c:    ch->max_mana    = 100;
db.c:    ch->move      = 100;
db.c:    ch->max_move    = 100;
db.c:    ch->leader      = NULL;
db.c:    ch->master      = NULL;
db.c:    ch->deleted     = FALSE;
db.c:    ch->protecting = NULL;
db.c:    ch->protector = NULL;
db.c:    ch->next_in_protect = NULL;
db.c:    ch->hunting = NULL;
db.c:    ch->hunted = NULL;
db.c:    ch->next_in_hunt = NULL;
db.c:    ch->tracking = NULL;
db.c:    ch->tracked = NULL;
db.c:    ch->next_in_track = NULL;
db.c:    ch->assassinating = NULL;
db.c:    ch->assassinated = NULL;
db.c:    ch->next_in_ass = NULL;
db.c:    ch->rembch = NULL;
db.c:    ch->rembed = NULL;
db.c:    ch->rrembed = NULL;
db.c:    ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
db.c:    for ( obj = ch->carrying; obj; obj = obj_next )
db.c:    for ( paf = ch->affected; paf; paf = paf->next )
db.c:    if ( ( qmark = ch->qmark ) )
db.c:    free_string( ch->name   );
db.c:    free_string( ch->short_descr  );
db.c:    free_string( ch->cname    );
db.c:    free_string( ch->long_descr   );
db.c:    free_string( ch->description  );
db.c:    if ( ch->pcdata )
db.c:  free_string( ch->pcdata->pwd    );
db.c:  free_string( ch->pcdata->bamfin   );
db.c:  free_string( ch->pcdata->bamfout  );
db.c:  free_string( ch->pcdata->immskll  );
db.c:  free_string( ch->pcdata->title    );
db.c:  free_string( ch->pcdata->prompt   );
db.c:  free_string( ch->pcdata->clantitle  );
db.c:  ch->pcdata->ride = 0;
db.c:  ch->pcdata->horse = NULL;
db.c:    if ( ch->pcdata->ba )
db.c:      free_string( ch->pcdata->ba->ba11 );
db.c:      free_string( ch->pcdata->ba->ba12 );
db.c:      free_string( ch->pcdata->ba->ba13 );
db.c:      free_string( ch->pcdata->ba->ba21 );
db.c:      free_string( ch->pcdata->ba->ba22 );
db.c:      free_string( ch->pcdata->ba->ba23 );
db.c:      free_string( ch->pcdata->ba->ba31 );
db.c:      free_string( ch->pcdata->ba->ba32 );
db.c:      free_string( ch->pcdata->ba->ba33 );
db.c:      ch->pcdata->ba->next = ba_free;
db.c:      ba_free = ch->pcdata->ba;
db.c:      ch->pcdata->ba = NULL;      
db.c:  ch->pcdata->next = pcdata_free;
db.c:  pcdata_free  = ch->pcdata;
db.c:    if ( ( mob_action = ch->mob_action ) )
db.c:    ch->next       = char_free;
db.c:    { bug( ch->name, 0 );
db.c:    ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c:    if( ch->clan ) return FALSE;
fight.c://*  PURPOSE     :         修改 violence_update(),在 ch->wait 為 0*
fight.c:  for ( ch = char_list; ch; ch = ch->next )
fight.c:    if ( !ch->in_room || ch->deleted )
fight.c:      if( ch->fighting && ch->position == POS_RESTING ){
fight.c:        ch->position = POS_FIGHTING;
fight.c:        ch->wait += 9;
fight.c:      if( ch->wait ){
fight.c:        ch->wait = UMAX( 0, ch->wait - 9 );
fight.c:    if ( !ch->desc  ) {
fight.c:      if( ch->wait ){
fight.c:        ch->wait = UMAX( 0, ch->wait - 6 );
fight.c:      if( ch->fighting && ch->position == POS_RESTING ){
fight.c:        ch->position = POS_FIGHTING;
fight.c:        ch->wait += 6;
fight.c:    if ( ( victim = ch->fighting ) )
fight.c:      if ( victim->deleted || ch->in_room != victim->in_room )
fight.c:      if( IS_SET(ch->in_room->room_flags, ROOM_SAFE ) ) {
fight.c:      if( ch->master == victim ) {
fight.c:      if ( IS_SET( race_table[ ch->race ].race_abilities, RACE_VAMPIRE )
fight.c:          ch->hit += ch->level / 4 + nRaceSklv + nRaceSklv * nRaceSklv / 2;
fight.c:          ch->hit += ch->level + nRaceSklv * 5 + nRaceSklv * nRaceSklv * 2;
fight.c:        ch->hit = UMIN( ch->hit, ch->max_hit);
fight.c:        //      ch->hit = ( ch->hit > ch->max_hit ) ? ch->max_hit : ch->hit;
fight.c:        ch->hit = UMIN( ch->max_hit, ch->hit + ch->level );
fight.c:      if( ( (is_affected( ch, gsn_invoke ) && get_skill_level(ch, gsn_invoke)>5)|| !IS_AFFECTED(ch, AFF_POISON) )&& ( IS_SET( race_table[ ch->race ].race_abilities, RACE_REGENERACY )
fight.c:            || ( IS_NPC( ch ) && IS_SET( ch->act, ACT_REGENERACY ) ) ||
fight.c:            ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_regeneracy] > 0 ) ) && ch != victim )
fight.c:          ch->hit += ch->level * 10;
fight.c:          if ( ch->hit > ch->max_hit )
fight.c:            ch->hit = ch->max_hit;
fight.c:        else if ( ch != ch->fighting )
fight.c:          int difflv = victim->level - ( ch->level > 36 ? 36 : ch->level );
fight.c:          if( IS_SET( race_table[ ch->race ].race_abilities, RACE_REGENERACY ))
fight.c:          /*if ( ch->level <= victim->level )
fight.c:            ch->move += get_curr_con( ch ) * (sklv);
fight.c:            if( ch->move > ch->max_move )
fight.c:              ch->move = ch->max_move;
fight.c:          if( ch->hit < ch->max_hit )
fight.c:              ch->hit += (( UMAX( 0, ( get_curr_con( ch ) - 10 ) ) * base * factor )/ 100 / 
fight.c:                  ( ( victim->level - ch->level > 5 ) ? 4 : 7))/8 ;
fight.c:              ch->hit += ( UMAX( 0, ( get_curr_con( ch ) - 10 ) ) * base * factor )/ 100 / 
fight.c:                ( ( victim->level - ch->level > 5 ) ? 4 : 7) ;
fight.c:            if ( ch->hit > ch->max_hit )
fight.c:              ch->hit = ch->max_hit;
fight.c:      if( ch->wait == 0 )
fight.c:      if( !ch->fighting || victim->deleted || ch->in_room != victim->in_room
fight.c:          || IS_SET( ch->in_room->room_flags, ROOM_SAFE ) ) 
fight.c:      if ( IS_AWAKE( ch ) && (victim = ch->fighting) && !victim->deleted )
fight.c:        if( !IS_NPC(ch) && ch->position == POS_RESTING ) continue;
fight.c:        if( !ch->fighting || ch->fighting->deleted ) continue;
fight.c:    || ( IS_NPC( ch ) && ch->pIndexData->pShop ) )
fight.c:  for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
fight.c:        || rch->deleted
fight.c:        || !( rch->fighting ) )
fight.c:      if ( IS_NPC( ch ) && !IS_AFFECTED( ch, AFF_CHARM ) && !IS_AFFECTED( ch, AFF_SUMMONED ) && !ch->clan
fight.c:        && IS_NPC( rch ) && !IS_AFFECTED( rch, AFF_CHARM ) && !IS_AFFECTED ( rch, AFF_SUMMONED ) && !rch->clan)
fight.c:  if ( !rch || !(rch->fighting))
fight.c:  victim = rch->fighting;
fight.c:      for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
fight.c:      if ( ( rch->pIndexData != ch->pIndexData && number_bits( 3 ) != 0 )
fight.c:        || abs( victim->level - ch->level ) > 5 )
fight.c:        || IS_SET(ch->act, PLR_ASSIST) )
fight.c:    for( ch = char_list; ch; ch = ch->next )
fight.c:      if(ch && !IS_NPC(ch) && ch->fighting)
fight.c:            show_vs_graphy(ch, ch->fighting);
fight.c:  if( ch->fighting )
fight.c:           ch->short_descr, ch->name, victim->short_descr, victim->name,
fight.c:  ch->fighting = victim;
fight.c:  if( !IS_NPC(ch) && ch->position == POS_RESTING ) return;
fight.c:  if( !ch->fighting || ch->fighting->deleted ) return;
fight.c:  ch->position = POS_FIGHTING;
fight.c:  REMOVE_BIT(ch->affected_by, AFF_CAST_ACC);
fight.c:  for ( fch = char_list; fch; fch = fch->next )
fight.c:      fch->fighting = NULL;
fight.c:      fch->position = POS_STANDING;
fight.c:    else if ( fBoth && fch->fighting == ch && !fch->deleted )
fight.c:      for( vch = fch->in_room->people; vch; vch = vch->next_in_room )
fight.c:        if ( vch->fighting == fch && !vch->deleted )
fight.c:          fch->fighting = vch;
fight.c:      fch->fighting = NULL;
fight.c:      fch->position = POS_STANDING;
fight.c:	REMOVE_BIT ( ch->affected_by, AFF_CAST_ACC );
fight.c:	for ( fch = char_list; fch; fch = fch->next )
fight.c:		else if ( fBoth && fch->fighting == ch && !fch->deleted )
fight.c:			for( vch = fch->in_room->people; vch; vch = vch->next_in_room )
fight.c:				if ( vch->fighting == fch && !vch->deleted && vch != ch ) {
fight.c:					fch->fighting = vch;
fight.c:					fch->attacked = NULL;                       //Added by Razgriz 20060822
fight.c:					fch->fighting = NULL;
fight.c:					fch->position = POS_STANDING;
fight.c:					fch->attacked = NULL;                       //Added by Razgriz 20060822
fight.c:						fch->wait = 0;//trade-off
fight.c:		tch->fighting = NULL;
fight.c:		tch->position = POS_STANDING;
fight.c:		tch->attacked = NULL;                                   //Added by Razgriz 20060822
fight.c:			tch->wait = 0;//trade-off
fight.c:  if ( ( killer == ch ) && ( ch->attacked ) )
fight.c:    killer = ch->attacked;
fight.c:    name      = ch->name;
fight.c:        sprintf( buf, "%s ", ch->name );
fight.c:        sprintf( buf, "%s ", ch->name );
fight.c:        sprintf( buf, "%s ", ch->name );
fight.c:    name        = ch->name;
fight.c:  if ( ch->gold > 0 )
fight.c:    int gold = ch->gold;    
fight.c:      int difflv = killer->level - ch->level;
fight.c:    ch->gold = 0;
fight.c:    sprintf( buf, corpse->short_descr, ch->short_descr );
fight.c:  sprintf( buf, corpse->description, ch->short_descr, killer->short_descr );
fight.c:  corpse->level = ch->level;
fight.c:  for ( obj = ch->carrying; obj; obj = obj_next )
fight.c:        ( IS_NPC( ch ) && ch->pIndexData->pShop ) )
fight.c:        char_to_room( horse, ch->in_room);
fight.c:  obj_to_room( corpse, ch->in_room );
fight.c:    name    = ch->name;
fight.c:    cname   = ch->short_descr;
fight.c:    obj_to_room( obj, ch->in_room );
fight.c:  was_in_room = ch->in_room;
fight.c:      ch->in_room = pexit->to_room;
fight.c:  ch->in_room = was_in_room;
fight.c:	ch->armor = 100;
fight.c:  ch->dodge = 0;
fight.c:  if( ch->class > BARBARIAN ){
fight.c:    ch->armor  += race_table[ch->race]. nature_ac;
fight.c:    ch->dodge  += race_table[ch->race]. nature_dodge;
fight.c:  ch->position   = POS_RESTING;
fight.c:  if ( IS_SET( race_table[ ch->race ].race_abilities, RACE_VAMPIRE 
fight.c:        || ch->class < WIZARD 
fight.c:        || ch->level < 31 ) ){
fight.c:    ch->hit  = ((ch->max_hit*10)/ 100);
fight.c:    ch->hit    = UMAX( 1, ch->hit  );
fight.c:  ch->mana     = UMAX( 1, ch->mana );
fight.c:  ch->move     = UMAX( 1, ch->move );
fight.c:  ch->hitroll  = 0;
fight.c:  ch->damroll  = 0;
fight.c:  if(IS_SET(race_table[ ch->race ].race_abilities, RACE_FLY)){
fight.c:    ch->dodge -= nRaceSklv * 2 + (nRaceSklv * nRaceSklv) / 2;
fight.c:		ch->dodge += race_table[ ch->race ].size * 5;
fight.c:  switch(ch->level) {
fight.c:      ch->pp = 0;
fight.c:      ch->pdr = 0;
fight.c:      ch->mdr = 0;
fight.c:      ch->pp = 3;
fight.c:      ch->pdr = 4;
fight.c:      ch->mdr = 4;
fight.c:      ch->pp = 7;
fight.c:      ch->pdr = 12;
fight.c:      ch->mdr = 12;
fight.c:      ch->pp = 13;
fight.c:      ch->pdr = 25;
fight.c:      ch->mdr = 25;
fight.c:  ch->apdr = 0;
fight.c:  ch->amdr = 0;
fight.c:  ch->pad = 0;
fight.c:  ch->mad = 0;
fight.c:  ch->pcdata->autocombat = AUTOC_NORMAL;
fight.c:    ch->saving_throw[i] = 0;
fight.c:	ch->mod_str = 0;
fight.c:  ch->mod_int = 0;
fight.c:  ch->mod_wis = 0;
fight.c:  ch->mod_dex = 0;
fight.c:  ch->mod_con = 0;
fight.c:    ch->pcdata->pkwin += 1;
fight.c:  logf_envy("%s is killed by %s.", victim->name, ch->name);
fight.c:    if ( ch->class == WARLORD && (victim->level >= ch->level || victim->level > 36 )
fight.c:      if( ch->hitroll > 20 - sklv*3 ) {
fight.c:        if( ch->level > victim->level )
fight.c:        if( ch->level > victim->level )
fight.c:    cn  = ch->clan;
fight.c:    if ( cn && victim->level > ch->level && victim->pIndexData->killed < 4 
fight.c:  if( !ch->in_room )
fight.c:  for( gch = ch->in_room->people; gch; gch = gch->next_in_room )
fight.c:  lch = ( ch->group && ch->group->leader ) ? ch->group->leader : ch;
fight.c:  for( gch = ch->in_room->people; gch; gch = gch->next_in_room )
fight.c:        ( gch != ch->master ||( !IS_AFFECTED( ch, AFF_CHARM ) && !IS_AFFECTED( ch, AFF_SUMMONED ) ) ) )
fight.c:    if( IS_NPC( ch ) && ch->master != gch && (  ch->level - gch->level > 5 || ch->level - gch->level < -5 ) )
fight.c:    if( gch->level - lch->level >= 6 )
fight.c:    if( gch->level - lch->level <= -6 )
fight.c:    if( !IS_NPC( gch ) && gch->class <= BARBARIAN && !IS_SET( gch->act, PLR_HORSE ) )
fight.c:    if( !str_infix( race_table[lch->race].name,race_table[gch->race].hate) && members > 1 )
fight.c:    if( gch && found && gch->class > BARBARIAN && gch == lch )
fight.c:    if( IS_SET( gch->act, PLR_HORSE ) )
fight.c:    if( ch->level > 35 && gch->level < 36 )
fight.c:        xp /= UMAX( 1,( ch->level - gch->level - members + 3 ));
fight.c:    if( ch->level < 37 )
fight.c:    for( obj = gch->carrying; obj; obj = obj_next )
fight.c:               obj_to_room( obj, gch->in_room );
fight.c:         if( obj->pIndexData->max_level > 0 && gch->level > obj->pIndexData->max_level )
fight.c:  level = gch->level - victim->level;
fight.c:  align = gch->alignment - victim->alignment;
fight.c:      gch->alignment += (((( 0 - victim->alignment ) / 200) + ( (align > 0 ) ? (1) : (-1)))) / 2 ;
fight.c:      gch->alignment -= ( (((victim->alignment - GOOD_BASE) * (victim->alignment - GOOD_BASE) / 45000 ) + 3 ) / 5 );
fight.c:      gch->alignment += ( (((EVIL_BASE - victim->alignment ) * (EVIL_BASE - victim->alignment ) / 45000 ) + 3 ) / 5 );
fight.c:      gch->alignment += (((( align) / 300) + ( (align > 0 ) ? (1) : (-1))) / 5 );
fight.c:    if ( IS_SET( race_table[ gch->race ].race_abilities, RACE_VAMPIRE ) )
fight.c:      gch->alignment = UMIN( 0, gch->alignment );
fight.c:    gch->alignment = URANGE( -1000, gch->alignment, 1000);
fight.c:        race_table[gch->race].hate ) )
fight.c:  if ( victim->race == gch->race )
fight.c:      if ( gch->class == CLERIC || gch->class == SAVANT )
fight.c:      if ( gch->class > BARBARIAN && !IS_SET(victim->special, EXPERT) && gch->level > 29 )
fight.c:      else if ( gch->class > BARBARIAN )
fight.c:      if ( !strcmp( race_table[ gch->race ].name, "Gnome" ) )
fight.c:  if ( (race_table[ch->race].size - race_table[victim->race].size ) < -2 )
fight.c:  if ( IS_NPC( victim ) && ( ( IS_SET( ch->act, ACT_HARD_DIS ) && number_bits( 3 ) != 1 ) || IS_SET( victim->special, NO_DISARM ) ) )
fight.c:        > (number_percent( ) * mod / 100) + ((IS_SET(race_table[ch->race].race_abilities, RACE_LIZARDMAN)) ? 20 : 0))
fight.c:      || ( IS_NPC(victim) && IS_SET(victim->special, EXPERT) && number_percent()  > ch->level - 20))
fight.c:    //if( !IS_NPC( ch ) &&!IS_SET( ch->act, PLR_CHINESE ) )
fight.c:  if ( ch->position == POS_FIGHTING )
fight.c:      victim->in_room == ch->in_room )//victim may flee!
fight.c:  if( !IS_SET( ch->act, PLR_REGISTER ) && (ch->in_room && !IS_SET(ch->in_room->room_flags, ROOM_PK))) {
fight.c:  if ( ch->position == POS_FIGHTING )
fight.c:  if( ch->deleted ) return;
fight.c:  if( !( victim = ch->fighting ) )
fight.c:  if( !ch->in_room || victim->deleted ) return;
fight.c:  if( IS_SET( ch->in_room->room_flags, ROOM_NO_FLEE ) )
fight.c:  if( ch->move < 20 )
fight.c:      switch( ch->pcdata->prime_attr ) 
fight.c:      switch( ch->pcdata->snd_attr ) 
fight.c:      if( ch->class == ASSASSIN ) 
fight.c:      else if( ch->class == NINJA ) 
fight.c:      else if( ch->class < WIZARD ) 
fight.c:  was_in = ch->in_room;
fight.c:                    && !IS_SET( race_table[ ch->race ].race_abilities, RACE_PASSDOOR ) 
fight.c:                         || ( IS_SET( ch->act, ACT_STAY_AREA )
fight.c:                              && pexit->to_room->area != ch->in_room->area ) ) ) )
fight.c:                       if( ch->pcdata->learned[gsn_escape] )
fight.c:                               ch->exp = ch->exp - 20;
fight.c:                           ch->exp = ch->exp-15;
fight.c:           if( ( now_in = ch->in_room ) == was_in )
fight.c:               if( ch->fighting ) stop_fighting(ch, FALSE);
fight.c:           ch->in_room = was_in;
fight.c:           act( "$n 逃走了！", IS_SET( ch->act, PLR_HORSE ) && ch->desc ? ch->pcdata->horse : ch,
fight.c:           ch->in_room = now_in;
fight.c:               if( ch->pcdata->learned[gsn_escape])
fight.c:                       ch->exp = ch->exp - 25;
fight.c:                   ch->exp = ch->exp - 20;
fight.c:		   ch->attacked = NULL;
fight.c:           if( victim->level > ch->level/2 )
fight.c:          if( ch->pcdata->learned[gsn_escape])
fight.c:                  ch->exp = ch->exp -20;
fight.c:              ch->exp = ch->exp -15;
fight.c:                 && !IS_SET( race_table[ ch->race ].race_abilities, RACE_PASSDOOR ) 
fight.c:                      || ( IS_SET( ch->act, ACT_STAY_AREA )
fight.c:                           && pexit->to_room->area != ch->in_room->area ) ) ) )
fight.c:                  if( ch->pcdata->learned[gsn_escape])
fight.c:                        ch->exp -= 20; 
fight.c:                      ch->exp -= 15;
fight.c:    if( ( now_in = ch->in_room ) == was_in )
fight.c:        if( ch->fighting ) stop_fighting(ch, FALSE);
fight.c:    ch->in_room = was_in;
fight.c:    act( "$n 逃走了！", IS_SET( ch->act, PLR_HORSE ) && ch->desc ? ch->pcdata->horse : ch,
fight.c:    ch->in_room = now_in;
fight.c:        if( ch->pcdata->learned[gsn_escape])
fight.c:              ch->exp=ch->exp-25;
fight.c:	ch->attacked = NULL;
fight.c:    if( victim->level > ch->level/2)
fight.c:  for( fch = room->people ; fch ; fch = fch->next_in_room ) {
fight.c:    if( fch->fighting == ch && fch != victim ) return fch;
fight.c:  if(!ch || !victim || !victim->in_room || !ch->in_room || !was_in) return;
fight.c:    vch_next_in_room = vch->next_in_room;
fight.c:    if ( vch != victim || vch->deleted || !can_see( vch, ch ) )
fight.c:    if ( IS_NPC( vch ) && IS_SET( vch->act, ACT_HUNT ) )
fight.c:      if ( ( hch = vch->hunting ) )
fight.c:        if ( hch->hunted == vch )
fight.c:          hch->hunted = vch->next_in_hunt;
fight.c:          for( rch = hch->hunted; rch; rch = rch->next_in_hunt )
fight.c:            if ( rch->next_in_hunt == vch )
fight.c:              rch->next_in_hunt = vch->next_in_hunt;
fight.c:        vch->hunting = ch;
fight.c:        vch->next_in_hunt = ch->hunted;
fight.c:        ch->hunted = vch;
fight.c:        vch->hunting = ch;
fight.c:        vch->next_in_hunt = ch->hunted;
fight.c:        ch->hunted = vch;
fight.c:    if ( ( IS_NPC( vch ) && !IS_SET( vch->act, ACT_TRACK ) ) 
fight.c:        ||  ( !IS_NPC( vch ) && ( vch->tracking != ch ||
fight.c:    if ( IS_NPC( vch ) && IS_SET( vch->act, ACT_TRACK ) )
fight.c:      if ( vch->track_times >= 6 )
fight.c:        ch->tracked = vch->next_in_track;
fight.c:        vch->tracking = NULL;
fight.c:        vch->next_in_track = NULL;
fight.c:        vch->track_times = 0;
fight.c:        vch->track_times += 1;
fight.c:    if( was_in == vch->in_room ) return;
fight.c:    if ( ch->in_room == vch->in_room )//ROOM_ENTRY_TRIGGER may mptransfer vch!
fight.c:      if ( ch->position != POS_FIGHTING )
fight.c:    //track_hunt( vch, vch->fighting, was_in, door );
fight.c:    vch_next_in_room = was_in->people;//vch->next_in_room may tracking and leave
fight.c:  if ( !IS_NPC( victim ) && victim->level >= ch->level )
fight.c:  if ( arg[0] == '\0' && !ch->fighting  )
fight.c:  if( arg[0] == '\0' && ch->fighting && ch->fighting->in_room &&
fight.c:      ch->fighting->in_room != ch->in_room )
fight.c:  if ( !( victim = ch->fighting ) )
fight.c:  if ( !IS_SET( race_table[ ch->race ].race_abilities, RACE_VAMPIRE ) )
fight.c:    if ( !ch->fighting )
fight.c:  if(ch->move < 10 + nSklv * 5){
fight.c:	ch->move -= 10 + nSklv * 5;
fight.c:  if ( !ch->fighting ){
fight.c:    if ( number_percent() >   (ch->hitroll + nSklv * 2 + nSklv * nSklv / 2 + GET_DODGE(victim) / 30) 
fight.c:        nHitRate = ch->hitroll * 1000 / (1000 - GET_DODGE(victim));
fight.c:        nHitRate = ch->hitroll * (1000 + GET_DODGE(victim)) / 1000;
fight.c:  dam  =  (ch->damroll + ch->damroll * abs(ch->damroll) / 100) / 2;
fight.c:	dam +=  ch->apdr * (12 + nSklv * 3) / 10;
fight.c:  if ( victim->in_room == ch->in_room && 15 + nSklv + nSklv * nSklv / 4 > number_percent( ) ){
fight.c:      && number_percent( ) < ( 25 - victim->level + ch->level + nSklv * 2 + nSklv * nSklv / 2) )
fight.c:    if (   ch->pcdata->condition[COND_FULL  ] > 40
fight.c:        && ch->pcdata->condition[COND_THIRST] > 40
fight.c:        && ( ch->hit * 100 / ch->max_hit > 75 ) )
fight.c:        ch->hit = UMIN( ch->max_hit, ch->hit + dam / 4);
fight.c:        ch->hit = UMIN( ch->max_hit, ch->hit + dam / 12);
fight.c:  for ( obj = ch->carrying; obj; obj = obj->next_content )
fight.c:  chance = ( IS_NPC( ch ) ? ch->level : ch->pcdata->learned[gsn_stake] );
fight.c:  chance = chance - victim->level + ch->level;
fight.c:    do_feed( victim, ch->name );
fight.c:  for ( obj = ch->carrying; obj; obj = obj->next_content )
fight.c:  if ( ch->fighting && ch->fighting == ch ) return;
fight.c:    if ( ( IS_SET( obj->pIndexData->hp_use_class, ALLOW_BIT ) && !IS_SET( obj->pIndexData->hp_use_class, NUM_BIT( ch->class ) ) )
fight.c:        || ( IS_SET( obj->pIndexData->hp_use_class, DENY_BIT ) && IS_SET( obj->pIndexData->hp_use_class, NUM_BIT( ch->class ) ) ) )
fight.c:    if ( ( IS_SET( obj->pIndexData->hp_use_race, ALLOW_BIT ) && !IS_SET( obj->pIndexData->hp_use_race, NUM_BIT( ch->race ) ) )
fight.c:        || ( IS_SET( obj->pIndexData->hp_use_race, DENY_BIT ) && IS_SET( obj->pIndexData->hp_use_race, NUM_BIT( ch->race ) ) ) )
fight.c:    if ( ( IS_SET( obj->pIndexData->hp_use_sex, ALLOW_BIT ) && !IS_SET( obj->pIndexData->hp_use_sex, NUM_BIT( ch->sex ) ) )
fight.c:        || ( IS_SET( obj->pIndexData->hp_use_sex, DENY_BIT ) && IS_SET( obj->pIndexData->hp_use_sex, NUM_BIT( ch->sex ) ) ) )
fight.c:  	if(!IS_SET(ch->act, PLR_STATUS))       return;
fight.c:	if(!ch || !ch->in_room || ch->deleted ) return;
fight.c:  	for(vch = ch->in_room->people; vch; vch = vch->next_in_room)
fight.c:    	if( vch && vch->fighting == ch)
fight.c:    if ( ch->sex == SEX_FEMALE )
fight.c:                ch->short_descr, victim->name, ch->in_room->name ); break;
fight.c:                victim->name, ch->short_descr ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, ch->in_room->name, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:    if ( vch->hunted == victim )
fight.c:      vch->hunted = victim->next_in_hunt;
fight.c:      for( rch = vch->hunted; rch; rch = rch->next_in_hunt )
fight.c:        if ( rch->next_in_hunt == victim )
fight.c:          rch->next_in_hunt = victim->next_in_hunt;
fight.c:      rch = vch->next_in_hunt;
fight.c:      vch->hunting = NULL;
fight.c:      vch->next_in_hunt = NULL;
fight.c:    if ( vch->assassinated == victim )
fight.c:      vch->assassinated = victim->next_in_ass;
fight.c:      for( rch = vch->assassinated; rch; rch = rch->next_in_ass )
fight.c:        if ( rch->next_in_ass == victim )
fight.c:          rch->next_in_ass = victim->next_in_ass;
fight.c:      rch = vch->next_in_ass;
fight.c:      vch->assassinating = NULL;
fight.c:      vch->next_in_ass = NULL;
fight.c:    if ( vch->tracked == victim )
fight.c:      vch->tracked = victim->next_in_track;
fight.c:      for( rch = vch->tracked; rch; rch = rch->next_in_track ){
fight.c:        if ( rch->next_in_track == victim )
fight.c:          rch->next_in_track = victim->next_in_track;
fight.c:      rch = vch->next_in_track;
fight.c:      vch->tracking = NULL;
fight.c:      vch->next_in_track = NULL;
fight.c:  //if( ( vch = ch->rembed ))
fight.c:  //  vch->rembch = NULL;
fight_check.c:			if ( ch->pcdata->prime_attr == APPLY_STR 
fight_check.c:					|| ch->pcdata->snd_attr == APPLY_STR )
fight_check.c:			if ( ch->pcdata->prime_attr == APPLY_DEX 
fight_check.c:					|| ch->pcdata->snd_attr == APPLY_DEX )
fight_check.c:        if( ch->move < 16 ) return FALSE;
fight_check.c:    ch->move -= 15;
fight_check.c:            if ( ch->pcdata->prime_attr == APPLY_STR || ch->pcdata->snd_attr == APPLY_STR )
fight_check.c:            if ( ch->pcdata->prime_attr == APPLY_DEX || ch->pcdata->snd_attr == APPLY_DEX )
fight_check.c:        //if( !IS_NPC(ch) && ch->class == NINJA && fReposte && victim->class != NINJA) 
fight_check.c:                if( ch->class != NINJA && (victim->class == NINJA && !IS_NPC(victim)) && number_percent() < (get_curr_dex(victim)+get_skill_level(victim, gsn_reposte)+get_skill_percent(victim, gsn_reposte)/6)){
fight_check.c:            if( ch->class != NINJA && victim->class == NINJA && !IS_NPC(victim) && number_percent() < (get_curr_dex(victim)+get_skill_level(victim, gsn_reposte) + get_skill_percent(victim, gsn_reposte))/6)
fight_check.c:        ( ch->pcdata->prime_attr == APPLY_STR || ch->pcdata->snd_attr == APPLY_STR ) ? 1 :
fight_check.c:        ( ch->pcdata->prime_attr == APPLY_DEX || ch->pcdata->snd_attr == APPLY_DEX ) ? 2 : 0;
fight_check.c:    break_shield = ( IS_NPC( ch ) ) ? IS_SET( ch->class, 8 ) ? ch->level + 30 : 0
fight_check.c:	    // if( !IS_NPC( ch ) &&!IS_SET( ch->act, PLR_CHINESE ) )
fight_check.c:	    // if( !IS_NPC( ch ) &&!IS_SET( ch->act, PLR_CHINESE ) )
fight_check.c:    else if ( !IS_SET( ch->act, ACT_TACTICS ) )
fight_check.c:    	chance = UMIN( 30, ch->level / 2 );
fight_check.c:    if ( IS_NPC( ch ) && ( IS_AFFECTED( ch, AFF_CHARM ) || IS_AFFECTED( ch, AFF_SUMMONED) || ch->clan )
fight_check.c:		&& ch->master && !IS_NPC( ch->master ) )
fight_check.c:	ch = ch->master;
fight_check.c:    if( ch->in_room != victim->in_room )
fight_check.c:	|| ( IS_SET( ch->act, PLR_KILLER ) && ch->fighting ) )
fight_check.c:	    && ch->level - victim->level < 6 )
fight_check.c:    if ( ( ch->level - victim->level > 5 && victim->fighting != ch )
fight_check.c:	sprintf( buf, "救命啊！  %s 正在攻擊我！", ch->name );
fight_check.c:	SET_BIT( ch->act, PLR_KILLER );
fight_check.c:	for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
fight_check.c:			SET_BIT( ch->act, PLR_KILLER );
fight_check.c:	for ( obj = ch->carrying; obj; obj = obj_next )
fight_check.c:    if( !IS_NPC(ch) && IS_AFFECTED(ch,AFF_CHARM) && ch->group && ch->group->leader == victim ) {
fight_check.c:	    if ( ch->qmark && !str_cmp( ch->qmark->mark_name, "gated_mob" ) && ch->protecting && 
fight_check.c:		!IS_NPC( ch->protecting ) && !IS_SET( ch->protecting->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "對方沒參加 PK ！", ch->protecting );
fight_check.c:		if ( IS_AFFECTED( ch, AFF_SUMMONED ) && ch->rembch && 
fight_check.c:		!IS_SET( ch->rembch->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "對方沒參加 PK ！", ch->protecting );
fight_check.c:	    if ( ch->qmark && !str_cmp( ch->qmark->mark_name, "gated_mob" ) && ch->protecting && 
fight_check.c:		!IS_NPC( ch->protecting ) && !IS_SET( ch->protecting->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "它的主人沒參加 PK ！", ch->protecting );
fight_check.c:		if ( IS_AFFECTED( ch, AFF_SUMMONED ) && ch->rembch && 
fight_check.c:		!IS_SET( ch->rembch->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "它的主人沒參加 PK ！", ch->protecting );
fight_check.c:		!IS_SET( victim->rembch->act, PLR_REGISTER ) )
fight_check.c:		!IS_SET( victim->rembch->act, PLR_REGISTER ) )
fight_check.c:    if ( ch->level < 16 && !ch->fighting )
fight_check.c:    if( !IS_SET(ch->act, PLR_REGISTER)) {
fight_check.c:    if ( ch->level >= L_APP )
fight_check.c:    sprintf(buf_q, "corpse_count_%d", ch->pIndexData->vnum);
fight_check.c:            if (ch->clan)
fight_check.c:            ch->clan->score -=  500*ch->level ;
fight_check.c:            ch->clan->bank -= UMAX( 0, 500*ch->level * 2 );
fight_check.c:            ch->pcdata->clanexp -= 500*ch->level;
fight_check.c:    if( !IS_NPC(ch) ) return ch->fighting;
fight_check.c:    if( IS_SET(ch->special, MOBAI_LV3)){
fight_check.c:	SET_BIT(ch->act, ACT_MOB_AI);
fight_check.c:    else if (IS_SET(ch->special, MOBAI_LV2)){
fight_check.c:	SET_BIT(ch->act, ACT_MOB_AI);
fight_check.c:    CHAR_DATA *victim = ch->fighting, *rch;
fight_check.c:    if ( victim->level > 35 && ch->level > 45 &&
fight_check.c:	    ( number_percent( ) < IS_SET( ch->act, ACT_MOB_AI ) ? 
fight_check.c:	      ch->level : ch->level - 45  ) )
fight_check.c:	for( rch = ch->in_room->people; rch; rch = rch->next_in_room ){
fight_check.c:	    if ( rch->fighting == ch && !rch->deleted )
fight_check.c:		if ( ch->hitroll < - GET_DODGE( rch ) / 8 )
fight_check.c:		if ( rch->class == MONK || rch->class == WARLORD 
fight_check.c:		   || rch->class == ALCHEMIST ||rch->class == MARTIALMAN )
fight_check.c:		if ( rch->class == SAVANT || rch->class == BISHOP )
fight_check.c:		if ( rch->class != SHAMAN && number_bits(3) == 1 )
fight_check.c:    CHAR_DATA *victim = ch->fighting, *rch;
fight_check.c:    if( ch && ch->class && (IS_SET(ch->class, 16) || IS_SET(ch->class, 2)))
fight_check.c:	    min = ch->fighting->hit * 5 - GET_AC(ch->fighting) * 3;
fight_check.c:	    if ( victim->level > 35 && ch->level > 45 &&
fight_check.c:		    ( number_percent( ) < IS_SET( ch->act, ACT_MOB_AI ) ? 
fight_check.c:		      ch->level : ch->level - 45 ))
fight_check.c:		for( rch = ch->in_room->people; rch; rch = rch->next_in_room ){
fight_check.c:		    if ( rch->fighting == ch && !rch->deleted )
fight_check.c:			if ( ch->hitroll < - GET_DODGE( rch ) / 8 )
fight_check.c:			if( rch->hit * 5 - GET_AC(rch) * 3 < min ){
fight_check.c:			    min = rch->hit*5- GET_AC(rch) * 3 ;
fight_check.c:	    if ( victim->level > 35 && ch->level > 45 &&
f