affect.c://*---------------------------------------------------------------*
affect.c://*---------------------------------------------------------------*
affect.c://*---------------------------------------------------------------*
affect.c://*---------------------------------------------------------------*
affect.c:	if( !ch || paf->deleted ) return;
affect.c:	mod = paf->modifier;
affect.c:		SET_BIT( ch->affected_by, paf->bitvector );
affect.c:      REMOVE_BIT( ch->affected_by, paf->bitvector );
affect.c:      mod = 0 - mod;
affect.c:	switch ( paf->location )
affect.c:					paf->location, ch->name );
affect.c:			ch->mod_str += mod;				
affect.c:			ch->mod_dex += mod;				
affect.c:			ch->mod_int += mod;				
affect.c:			ch->mod_wis += mod;				
affect.c:			ch->mod_con += mod;			    
affect.c:			ch->sex			+= mod; 
affect.c:			//	Check for natural_fly and inborn ability skill -- added by keelar
affect.c:			int  nNewRace    = ch->race + mod;
affect.c:				nNewRace -= MAX_RACE;
affect.c:			bOrgFlyStat = IS_SET(race_table[ ch->race ].race_abilities, RACE_FLY);
affect.c:				ch->dodge += nRaceSklv * 2 + (nRaceSklv * nRaceSklv) / 2;
affect.c:				ch->dodge -= race_table[ch->race].size * 5;
affect.c:				ch->dodge -= nRaceSklv * 2 + (nRaceSklv * nRaceSklv) / 2;
affect.c:				ch->dodge += race_table[nNewRace].size * 5;
affect.c:			ch->race	= nNewRace;
affect.c:			ch->carry_weight += mod;
affect.c:			ch->max_mana		+= mod; 
affect.c:			ch->max_hit		+= mod; 
affect.c:			ch->max_move		+= mod; 
affect.c:			ch->armor += mod; 
affect.c:			ch->hitroll	+= mod; 
affect.c:			ch->damroll	+= mod; 
affect.c:			ch->saving_throw[0]	+= mod; 
affect.c:			ch->saving_throw[MAGIC_BREATH] += mod; 
affect.c:			ch->saving_throw[0]	+= mod; 
affect.c:			ch->saving_throw[MAGIC_EARTH] += mod; 
affect.c:			ch->saving_throw[MAGIC_EARTH] += mod; 
affect.c:			ch->saving_throw[MAGIC_SAINT] += mod; 
affect.c:			ch->saving_throw[MAGIC_DARK]  += mod; 
affect.c:			ch->saving_throw[MAGIC_LIGHTNING] += mod; 
affect.c:			ch->saving_throw[MAGIC_WIND] += mod; 
affect.c:			ch->saving_throw[MAGIC_POISON] += mod;
affect.c:			ch->saving_throw[MAGIC_FIRE]		+= mod; 
affect.c:			ch->saving_throw[MAGIC_WIND]		+= mod; 
affect.c:			ch->saving_throw[MAGIC_COLD]		+= mod; 
affect.c:			ch->saving_throw[MAGIC_EARTH]		+= mod; 
affect.c:			ch->saving_throw[MAGIC_LIGHTNING]	+= mod;
affect.c:			ch->saving_throw[MAGIC_BREATH] += mod; 
affect.c:			ch->saving_throw[MAGIC_FIRE] += mod; 
affect.c:			ch->saving_throw[MAGIC_COLD] += mod; 
affect.c:			ch->pdr += mod; 
affect.c:			ch->mdr += mod; 
affect.c:			ch->apdr += mod; 
affect.c:			ch->amdr += mod; 
affect.c:			if( IS_NPC(ch) ) ch->pad += mod; 
affect.c:			if( IS_NPC(ch) ) ch->mad += mod; 
affect.c:			ch->pp += mod; 
affect.c:			ch->dodge += mod; 
affect.c:	ch->hit  = UMIN( ch->hit, ch->max_hit );
affect.c:	ch->mana = UMIN( ch->mana, ch->max_mana );
affect.c:	ch->move = UMIN( ch->move, ch->max_move );
affect.c:    paf_new->deleted	= FALSE;
affect.c:    paf_new->next	= ch->affected;
affect.c:    ch->affected	= paf_new;
affect.c:    if ( !ch->affected )
affect.c:    if (paf->type == gsn_sleep)
affect.c:        ch->position = POS_STANDING;
affect.c:    paf->deleted = TRUE;
affect.c:        && ( ch->in_room                                            )
affect.c:        && ( paf->type == gsn_charm_person                          )
affect.c:        && ( ( pRoomIndex = get_room_index ( qmark->v0 )  ) != NULL )    )
affect.c:        if ( ch->in_room->area != pRoomIndex->area )
affect.c:/*    if (paf->type == gsn_adore && paf->next )
affect.c:    	vpaf = paf->next;
affect.c:    	if (vpaf->type == gsn_adore )
affect.c:		vpaf->deleted = TRUE;
affect.c:	for ( paf = ch->affected; paf; paf = paf->next ){
affect.c:		if ( paf->deleted ) 
affect.c:		if ( paf->type == sn )
affect.c:	for ( paf = ch->affected; paf; paf = paf->next ){
affect.c:		if ( paf->deleted ) 
affect.c:		if ( paf->type == sn )
affect.c:    for ( paf = ch->affected; paf; paf = paf->next )
affect.c:        if ( paf->deleted )
affect.c:        if ( paf->type == sn && paf->location == apply_type)
affect.c:            return paf->modifier;
affect.c:	int nOrgDuration = -1;
affect.c:	for ( paf_old = ch->affected; paf_old; paf_old = paf_old->next ){
affect.c:		if ( paf_old->deleted ) continue;
affect.c:		if ( paf_old->type == paf->type && paf_old->location == paf->location ){
affect.c:			if ( IS_NPC( ch ) && paf->location < 6 && paf_old->modifier < 0 
affect.c:				&& number_percent() < ( - paf_old->modifier * 8 ) )
affect.c:			nOrgDuration   = paf_old->duration;
affect.c:			paf->duration += paf_old->duration;
affect.c:			paf->modifier += paf_old->modifier;
affect.c:	if(nOrgDuration < 0 || paf->duration >= 0)
bit.c: *  and has been used here for OLC - OLC would not be what it is without   *
bit.c: implementing a system like below with such functions. -Jason Dinkel
bit.c: Purpose:	Returns the value of the flags entered.	 Multi-flags accepted.
bit.c:    {	"bashed",   99,-1},
bit.c:    { "private",	99,		-1},
bit.c:    { "solitary",	99,		-1},
bit.c:    { "pet_shop",	99,		-1},
bit.c:    { "no_recall",	99,		-1},
bit.c:    { "cone_of_silence",99,-1},
bit.c:    { "summon_bit",	99,		-1},
bit.c:    { "horse_shop", 99 , -1},
bit.c:    { "noswim",	    99,	-1},
bit.c:    { "underwater", 99,	-1},
bit.c:    { "air",	    99,	-1},
bit.c:    {	"drink-container",	ITEM_DRINK_CON,		TRUE	},
bit.c:    { "scroll",	    99, 	-1},
bit.c:    { "wand",	    99, 	-1},
bit.c:    { "staff",	    99,	-1},
bit.c:    { "treasure",   99, 	-1},
bit.c:    { "armor",	    8, 		-1},
bit.c:    { "potion",   	99, 	-1},
bit.c:    { "container",  12,		-1},
bit.c:    { "drink-container", 14,-1},
bit.c:    { "money",		99, 	-1},
bit.c:    { "npc corpse", 99, 	-1},
bit.c:    { "pc corpse", 	99, 	-1},
bit.c:    { "pill", 		99,		-1},
bit.c:    { "arrow", 		99,		-1},
bit.c:    {	"anti-good",		ITEM_ANTI_GOOD,		TRUE	},
bit.c:    {	"anti-evil",		ITEM_ANTI_EVIL,		TRUE	},
bit.c:    {	"anti-neutral",		ITEM_ANTI_NEUTRAL,	TRUE	},
bit.c:    {	"vampire-bane",		ITEM_VAMPIRE_BANE,	TRUE	},
bit.c:    { "magic",		99,-1},
bit.c:    { "anti-good", 	99,-1},
bit.c:    { "anti-evil", 	99,-1},
bit.c:    { "anti-neutral",99,-1},
bit.c:    { "noremove", 	99,-1},
bit.c:    { "inventory", 	99,-1},
bit.c:    { "vampire-bane",99,-1},
bit.c:    { "holy", 		99,-1},
bit.c:    { "remove_nodrop",99,-1},
bit.c:    { "donation_pit",99,-1},
bit.c:    { "unique",		99,-1},
bit.c:    { "clan", 		99,-1},
bit.c:    { "personal", 	99,-1},
bit.c:    { "nosave",	99,-1},
bit.c:    {	"nomale",	99,		-1},
bit.c:    {	"nosac",	99,		-1},
bit.c:    {	"nofemale",	99,		-1},
bit.c:    {	"noneutral",	99,		-1},
bit.c:    {	"detect-evil",		AFF_DETECT_EVIL,	TRUE	},
bit.c:    {	"detect-invis",		AFF_DETECT_INVIS,	TRUE	},
bit.c:    {	"detect-magic",		AFF_DETECT_MAGIC,	TRUE	},
bit.c:    {	"detect-hidden",	AFF_DETECT_HIDDEN,	TRUE	},
bit.c:    {	"faerie-fire",		AFF_FAERIE_FIRE,	TRUE	},
bit.c:    {	"change-sex",		AFF_CHANGE_SEX,		TRUE	},
bit.c:    {	"pass-door",		AFF_PASS_DOOR,		TRUE	},
bit.c:    {	"vamp-bite",		AFF_VAMP_BITE,		TRUE	},
bit.c:    {	"saving-para",		APPLY_SAVING_PARA,	TRUE	},
bit.c:    {	"saving-life",		APPLY_SAVING_LIFE,	TRUE	},
bit.c:    {	"saving-petri",		APPLY_SAVING_PETRI,	TRUE	},
bit.c:    {	"saving-breath",	APPLY_SAVING_BREATH,	TRUE	},
bit.c:    {	"saving-spell",		APPLY_SAVING_SPELL,	TRUE	},
bit.c:    {	"saving-element",		APPLY_SAVING_ELEMENT,	TRUE	},
bit.c:    {	"dark-ale",		4,	TRUE	},
bit.c:    {	"local-specialty",	8,	TRUE	},
bit.c:    {	"slime-mold-juice",	9,	TRUE	},
bit.c:    {	"salt-water",		14,	TRUE	},
bit.c: * Race types for medit - Envy 2.x version
bit.c:    { "spec_cast_psionicist",	99,		-1		},
bit.c:    { "spec_mayor",		99,		-1		},
bit.c:    { "spec_repairman",		99,		-1		},
clan.c://*---------------------------------------------------------------*
clan.c://*---------------------------------------------------------------*
clan.c:    free_string( pClan->name );
clan.c:    free_string( pClan->whoname );
clan.c:    free_string( pClan->filename );
clan.c:    free_string( pClan->leader );
clan.c:    free_string( pClan->founder );
clan.c:    free_string( pClan->desc );
clan.c:    free_string( pClan->feud );
clan.c:    free_string( pClan->ally );
clan.c:    pClan->next = clan_free;
clan.c:   * Discard null and zero-length messages.
clan.c:  to = ch->in_room->people;
clan.c:      if( !vch->in_room )//amenda 6/2/01 for debug purpose
clan.c:          bug( vch->name, 0 );
clan.c:      to = vch->in_room->people;
clan.c:  for( d = descriptor_list; d; d = d->next ) 
clan.c:       to = (d->original) ? d->original : d->character;
clan.c:       // if( (to && ( to->clan != ch->clan && to->clan_channel != ch->clan->whoname 
clan.c:       //  && !str_cmp( to->clan_channel, "all" ) ) ) ) continue;
clan.c:       if( to->clan != ch->clan && !to->clan_channel ) continue;
clan.c:       if( to->clan_channel )
clan.c:           if( to->clan_channel != ch->clan->whoname 
clan.c:               && to->clan != ch->clan )
clan.c:               if( str_cmp( to->clan_channel, "all" ) ) continue;
clan.c:       sprintf(buf, "%s¡i%s¡j", HIY, ch->clan->whoname);
clan.c:                 case 'e': i = he_she  [URANGE( 0, ch  ->sex, 2 )];    break;
clan.c:                 case 'E': i = he_she  [URANGE( 0, vch ->sex, 2 )];    break;
clan.c:                 case 'm': i = him_her [URANGE( 0, ch  ->sex, 2 )];    break;
clan.c:                 case 'M': i = him_her [URANGE( 0, vch ->sex, 2 )];    break;
clan.c:                 case 's': i = his_her [URANGE( 0, ch  ->sex, 2 )];    break;
clan.c:                 case 'S': i = his_her [URANGE( 0, vch ->sex, 2 )];    break;
clan.c:                       ? ( strcpy(name_buf, obj1->short_descr) )
clan.c:                       ? ( strcpy(name_buf, obj2->short_descr) )
clan.c:       if( to->desc )
clan.c:           write_to_buffer( to->desc, buf, point - buf );
clan.c:    if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_NO_EMOTE ) )
clan.c:    switch ( ch->position )
clan.c:   * But two players asked for it already!  -- Furey
clan.c:      original = ch->in_room;
clan.c:      char_to_room( ch, victim->in_room );
clan.c:    for( i = 0; i < CLAN_LEVEL-1; ++i ) m+=pClan->member[i];
clan.c:  clan_free = pClan->next;
clan.c:    pClan->dirty = 0;
clan.c:    pClan->filename = NULL;
clan.c:    for ( cn = clan_list; cn; cn = cn->next )
clan.c:  //sprintf(buf, "%s%s", CLAN_DIR, cn->filename );
clan.c:  if ( !( fp = fopen ( cn->filename, "w" ) ) )
clan.c:  fprintf( fp, "Nm  %s~\n", cn->name );
clan.c:  fprintf( fp, "Wnm %s~\n", cn->whoname );
clan.c:  fprintf( fp, "Fndr  %s~\n", cn->founder);
clan.c:  fprintf( fp, "Ldr %s~\n", cn->leader );
clan.c:  fprintf( fp, "Desc  %s~\n", cn->desc ? cn->desc : "");
clan.c:  fprintf( fp, "Bank  %lld\n", cn->bank );
clan.c:  fprintf( fp, "Mmbr      %d", cn->member[0] );
clan.c:  for( i = 1; i < CLAN_LEVEL -1 ; ++i ) fprintf(fp, " %d", cn->member[i]);
clan.c:  fprintf( fp, "CRecl %d\n", cn->crecall);
clan.c:  fprintf( fp, "Ally  %s~\n", cn->ally);
clan.c:  fprintf( fp, "Feud   %s~\n", cn->feud);
clan.c:  fprintf( fp, "War   %d %d\n", cn->warwin, cn->warlose);
clan.c:  fprintf( fp, "CScore  %d\n", cn->score);
clan.c:  fprintf( fp, "CClass  %d\n", cn->cclass);
clan.c:  fprintf( fp, "HIRE  %d\n", cn->hire);
clan.c:  fprintf( fp, "Construct %d\n", cn->construct);
clan.c:  fprintf( fp, "CObj  %d", cn->cobj[0]);
clan.c:  for( i = 1; i < CLAN_LEVEL ; ++i ) fprintf(fp, " %d", cn->cobj[i]);
clan.c:  fprintf( fp, "Killed  %d", cn->kill[0]);
clan.c:  for( i = 1; i < CLAN_KILL ; ++i ) fprintf(fp, " %d", cn->kill[i]);
clan.c:    for ( cn = clan_list; cn; cn = cn->next ){
clan.c:  fprintf(fp, "%s\n", cn->filename);
clan.c:        if( pClan->ally ) free_string( pClan->ally );
clan.c:        pClan->ally = fread_string(fp, &stat);
clan.c:        pClan->bank = fread_number(fp, &stat);
clan.c:        pClan->crecall = fread_number(fp, &stat);
clan.c:        pClan->score = fread_number(fp, &stat);
clan.c:        pClan->cclass = fread_number(fp, &stat);
clan.c:      pClan->cobj[i] = fread_number(fp, &stat);
clan.c:        pClan->construct = fread_number(fp, &stat);
clan.c:        if( pClan->desc ) free_string( pClan->desc );
clan.c:        pClan->desc = fread_string(fp, &stat);
clan.c:        if( pClan->feud ) free_string( pClan->feud);
clan.c:        pClan->feud = fread_string( fp, &stat);
clan.c:        if( pClan->founder ) free_string( pClan->founder );
clan.c:        pClan->founder = fread_string( fp, &stat);
clan.c:        pClan->hire = fread_number(fp, &stat);
clan.c:      pClan->kill[i] = fread_number(fp, &stat);
clan.c:        if( pClan->leader ) free_string(pClan->leader);
clan.c:        pClan->leader = fread_string(fp, &stat);
clan.c:        for( i = 0; i < CLAN_LEVEL-1; ++i){
clan.c:      pClan->member[i] = fread_number(fp, &stat);
clan.c:        if( pClan->name ) free_string(pClan->name);
clan.c:        pClan->name = fread_string(fp, &stat);
clan.c://bug( pClan->name, 0 );
clan.c:        pClan->warwin = fread_number(fp, &stat);
clan.c:        pClan->warlose = fread_number(fp, &stat);
clan.c:        if( pClan->whoname ) free_string(pClan->whoname);
clan.c:        pClan->whoname = fread_string(fp, &stat);
clan.c:      clan_free = clan_free->next;
clan.c:  cn->name   = fread_string( fp, &stat );
clan.c:  cn->founder= fread_string( fp, &stat );
clan.c:  cn->leader = fread_string( fp, &stat );
clan.c:  cn->desc   = fread_string( fp, &stat );
clan.c:  cn->bank   = fread_number( fp, &stat );
clan.c:  cn->member[0] = fread_number( fp, &stat );
clan.c:  cn->next   = clan_list;
clan.c:    pClan->filename = str_dup(clanfile);
clan.c:      pClan->next = clan_list;
clan.c:    free_string( ch->pcdata->clantitle );
clan.c:    ch->pcdata->clantitle = str_dup( buf );
clan.c:    if ( IS_NPC( ch ) || ( ch->desc && ch->desc->original ) )
clan.c:    if ( !ch->in_room || ch->in_room->vnum != 11000)
clan.c:  for( cn = clan_list; cn; cn = cn->next )
clan.c:      if ( !str_cmp( cn->founder, ch->name) )
clan.c:      if ( ch->bank < 8000000 )
clan.c:      if ( ch->pcdata->respect < 2 || ch->level < 38 )
clan.c:    if ( ch->clan )
clan.c:    for( cn = clan_list; cn; cn = cn->next )
clan.c:      if ( !str_cmp( cn->name, arg2 ) || !str_cmp(cn->whoname, arg3) )
clan.c:      ch->bank -= 8000000;
clan.c:      ch->pcdata->respect += 5;
clan.c:      ch->pcdata->clanlevel = 5;
clan.c:        clan_free = clan_free->next;
clan.c:    cn->name = str_dup( buf );
clan.c:    cn->whoname = str_dup(buf);
clan.c:    strcpy( buf, ch->name );
clan.c:    cn->leader = str_dup( buf );
clan.c:    cn->founder = str_dup( buf );
clan.c:    sprintf(buf, "%s%s.clan", CLAN_DIR, ch->name);
clan.c:    cn->filename = str_dup(buf);
clan.c:    cn->bank = 1000000;
clan.c:    cn->member[0] = 0;
clan.c:    cn->member[1] = 0;
clan.c:    cn->member[2] = 0;
clan.c:    cn->member[3] = 0;
clan.c:    cn->member[4] = 1;
clan.c:    cn->next = clan_list;
clan.c:    ch->clan = cn;
clan.c:        cn->name, ch->name );
clan.c:  if( IS_NPC(ch) || !ch->clan ) {return;}
clan.c:  //strcpy(clan_name, ch->clan->name);
clan.c:  if( !victim->clan 
clan.c:  || victim->clan != ch->clan ){
clan.c:  if( victim->level < 38 ) {
clan.c:  if ( ch->pcdata->clanlevel < 5 )
clan.c:  free_string(ch->clan->leader);
clan.c:  ch->clan->leader = str_dup( victim->name );
clan.c:  ch->clan->score -= ch->clan->cclass * 5000;
clan.c:  ch->pcdata->clanlevel = 4;
clan.c:  victim->pcdata->clanlevel = 5;
clan.c:  ch->pcdata->respect -= 2;
clan.c:  victim->pcdata->respect += 2;
clan.c:    ch->cname,
clan.c:    ch->name,
clan.c:    ch->clan->name,
clan.c:    victim->name,
clan.c:    if ( ch->clan )
clan.c:      if ( !ch->clan_join )
clan.c:      sprintf( buf, "§A¥´®ø¥[¤J%sªº©ÀÀY¡I\n\r", ch->clan_join );
clan.c:          ch->clan_join,
clan.c:          ch->short_descr,
clan.c:          for ( d = descriptor_list; d; d = d->next )
clan.c:            if( d->connected != CON_PLAYING ) continue;
clan.c:            victim = (d->character) ? d->character : d->original;
clan.c:            if( victim->clan->whoname != ch->clan_join && !victim->clan_channel ) continue;
clan.c:            if( victim->clan_channel )
clan.c:              if ( victim->clan_channel != ch->clan_join )
clan.c:                if ( str_cmp( victim->clan_channel, "all" ) ) continue;
clan.c:      ch->clan_join = NULL;
clan.c:    for( cn = clan_list; cn; cn = cn->next ) {
clan.c:      if(!str_cmp(clan_name, cn->leader)) {
clan.c:        ch->clan_join = cn->whoname;
clan.c:        sprintf( buf, "§A§Æ±æ¥[¤JªºÀ°¬£¬O¡G%s¡I\n\r", ch->clan_join );
clan.c:          ch->clan_join,
clan.c:          ch->short_descr,
clan.c:          for ( d = descriptor_list; d; d = d->next )
clan.c:            if( d->connected != CON_PLAYING ) continue;
clan.c:            victim = (d->character) ? d->character : d->original;
clan.c:            if( victim->clan->whoname != ch->clan_join && !victim->clan_channel ) continue;
clan.c:            if( victim->clan_channel )
clan.c:              if ( victim->clan_channel != ch->clan_join )
clan.c:                if ( str_cmp( victim->clan_channel, "all" ) ) continue;
clan.c:    if( !ch->clan_join )
clan.c:  if( !ch->clan ) return;
clan.c:  if( ch->pcdata->clanlevel < 3 ) {
clan.c:  if( !IS_PPLBUILDER(ch, pRoom->area)|| !IS_PPLBUILDER(ch, ch->in_room->area)){
clan.c:  if( !( ch->clan ) ) return;
clan.c:  //strcpy(clan_name, ch->clan->name);
clan.c:    ch->clan->whoname,
clan.c:    ch->short_descr,
clan.c:    //ch->name,
clan.c:  for ( d = descriptor_list; d; d = d->next )
clan.c:      if( d->connected != CON_PLAYING ) continue;
clan.c://      victim = (d->original) ? d->original : d->character;
clan.c:      victim = (d->character) ? d->character : d->original;
clan.c:      if( !victim ) continue; //&& !( victim->clan && victim->clan_channel ) ) continue;
clan.c:      if( victim->clan != ch->clan && !victim->clan_channel ) continue;
clan.c:    if( victim->clan_channel )
clan.c:      if ( victim->clan_channel != ch->clan->whoname 
clan.c:           && victim->clan != ch->clan )
clan.c:        if ( str_cmp( victim->clan_channel, "all" ) ) continue;
clan.c:  if( !( ch->clan ) ) return;
clan.c:  if( !ch->clan ) return;
clan.c:    if ( victim->clan )
clan.c:    if ( !victim->clan_join )
clan.c:    if ( ch->clan->whoname != victim->clan_join )
clan.c:    if ( IS_NPC( victim ) || ch->pcdata->clanlevel < 3 )
clan.c:    if ( victim->level < 10 )
clan.c:    if ( victim->gold < 30000 )
clan.c:    if ( ch->clan->bank < 100000 )
clan.c:    victim->gold -= 30000;
clan.c:    ch->clan->bank -= 100000;
clan.c:                if( victim->level <= 20 )
clan.c:                    ch->clan->score += victim->level * 10;
clan.c:                    ch->clan->score += UMIN( victim->level * (victim->level + victim->level / 3), 1000);
clan.c:    ch->clan->member[0] +=1;
clan.c:    victim->pcdata->respect += 2;
clan.c:    victim->pcdata->clanstatistics = 0;
clan.c:    victim->pcdata->clanexp = 0;
clan.c:    victim->pcdata->clanlevel = 0;
clan.c:        ch->clan->name );
clan.c:    victim->clan = ch->clan;
clan.c:      victim->cname,victim->name, ch->cname, ch->clan->name, ch->clan->name );
clan.c:  if( !ch->clan ) return;
clan.c:    if ( ch->pcdata->clanlevel < 3 )
clan.c:    if( ch->pcdata->clanlevel <= victim->pcdata->clanlevel )
clan.c:    if( ch->clan != victim->clan ) {
clan.c:      if ( ch->clan->bank < 200000 )
clan.c:      if ( !victim->clan || IS_NPC( victim ) )
clan.c:      ch->clan->bank -= 200000;
clan.c:      ch->clan->score -= 1000;
clan.c:    victim->pcdata->respect -= 3;
clan.c:        victim->clan->name );
clan.c:    victim->clan = NULL;
clan.c:    ch->clan->member[0] -= 1;
clan.c:      ch->cname, victim->cname, ch->clan->name );
clan.c:  if( !ch->clan ) return;
clan.c:    if ( ch->pcdata->clanlevel > 4 )
clan.c:    if( ch->pcdata->clanlevel > 2 ) {
clan.c:      if ( ch->gold < 100000 )
clan.c:      if ( !ch->clan )
clan.c:      ch->gold -= 100000;
clan.c:    ch->pcdata->respect -= 2;
clan.c:        ch->clan->name );
clan.c:      ch->cname,ch->name, ch->clan->name );
clan.c:    ch->clan->score -= 1000;
clan.c:    ch->clan->member [0]-=1;
clan.c:    ch->clan = NULL;
clan.c:    for( clv = 5; clv >= 0; --clv) {
clan.c:                    for( lv = MAX_LEVEL; lv > 0; --lv ) {
clan.c:                        for ( d = descriptor_list; d; d = d->next )
clan.c:                            if( d->connected != CON_PLAYING ) continue;
clan.c:                            victim = (d->original) ? d->original : d->character;
clan.c:                            if( victim->level != lv ) continue;
clan.c:                            if( !victim->clan ) continue;
clan.c:                            if( victim->pcdata->clanlevel != clv ) continue;
clan.c:                            sprintf( buf , "¡i"HIW"%8s %1d %2d"NOR" ¡j "HIG"%s"NOR"  -  %s("HIY"%s"NOR") %s \n\r",
clan.c:                                    victim->clan->whoname,
clan.c:                                    victim->pcdata->clanlevel,
clan.c:                                    victim->level,
clan.c:                                    //    class_table[ victim->class ].cwho_name,
clan.c:                                    victim->pcdata->clantitle,
clan.c:                                    victim->cname,
clan.c:                                    victim->name,
clan.c:                                    victim->pcdata->title
clan.c:      if ( !ch->clan )
clan.c:        //strcpy(clan_name, ch->clan->name);
clan.c:        vclan = ch->clan;
clan.c:        //vclan = ch->clan;
clan.c:        for( cn = clan_list; cn; cn = cn->next ) {
clan.c:      if(!str_cmp(clan_name, cn->leader)) {
clan.c:    sprintf( buf , "[ "HIC"%sÀ°­û¦Cªí"NOR" ]",vclan->whoname);
clan.c:    if( ch->pcdata->clanlevel > 0 && ch->clan == vclan ) {
clan.c:          vclan->bank, vclan->cclass, vclan->warwin, vclan->warlose);
clan.c:    for ( d = descriptor_list; d; d = d->next )
clan.c:        if( d->connected != CON_PLAYING ) continue;
clan.c:        victim = (d->original) ? d->original : d->character;
clan.c:        if( victim->clan 
clan.c:        //&& !str_cmp( clan_name, victim->clan->name))
clan.c:        && victim->clan == vclan )
clan.c:      class[members] = class_table[ wch[members]->class ].cwho_name;
clan.c:    for( level = 5; level >=0; --level) {
clan.c:      if ( wch[i]->pcdata->clanlevel == level )
clan.c:          cn = wch[i]->clan;
clan.c:          if( (ch->pcdata->clanlevel > 3 && ch->clan == vclan) || IS_IMMORTAL(ch))
clan.c:        strip_ansi( wch[i]->name, no_ansi );  
clan.c:        sprintf( buf , "¡i"HIW"%1d %2d"NOR" "HIW"%6s"NOR" ¡j %s - %s("HIY"%s"NOR")  ("HIY"%d, %d"NOR")\n\r",
clan.c:          wch[i]->pcdata->clanlevel,
clan.c:          wch[i]->level,
clan.c:          wch[i]->pcdata->clantitle,
clan.c:          wch[i]->cname,
clan.c:          wch[i]->name,
clan.c:        //  wch[i]->pcdata->title,
clan.c:          wch[i]->pcdata->clanexp,
clan.c:          wch[i]->pcdata->clanstatistics);
clan.c:        strip_ansi( wch[i]->name, no_ansi );  
clan.c:        sprintf( buf , "¡i"HIW"%1d %2d"NOR" "HIW"%6s"NOR" ¡j %s - %s("HIY"%s"NOR") %s\n\r",
clan.c:          wch[i]->pcdata->clanlevel,
clan.c:          wch[i]->level,
clan.c:          wch[i]->pcdata->clantitle,
clan.c:          wch[i]->cname,
clan.c:          wch[i]->name,
clan.c:          wch[i]->pcdata->title);
clan.c:        //      cn->name, d->character->pcdata->clantitle, 
clan.c:        //      d->character->cname, d->character->pcdata->clanstatistics );
clan.c:    if ( !ch->clan )
clan.c:    if ( ch->pcdata->clanlevel < 3 )
clan.c:    for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
clan.c:      if ( IS_SET( vch->act, ACT_BANKER ) )
clan.c:      if ( num < ch->clan->bank )
clan.c:        ch->gold += num;
clan.c:        ch->clan->bank -= ( num );
clan.c:        ch->pcdata->clanstatistics -= num;
clan.c:    if ( !ch->clan )
clan.c:    for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
clan.c:      if ( IS_SET( vch->act, ACT_BANKER ) )
clan.c:      if ( num < ch->gold )
clan.c:        ch->gold -= num;
clan.c:        ch->clan->bank += num;
clan.c:        ch->pcdata->clanstatistics += num;
clan.c:  if( !ch->clan ) return;
clan.c:        send_to_char( "µ¥¯Å¥²¶·¬O 0-4 ªº¼Æ¦r¡C\n\r", ch );
clan.c:    if ( ch->pcdata->clanlevel < 4 )
clan.c:    if ( victim->clan != ch->clan || IS_NPC( victim ) )
clan.c:                if( ch->pcdata->clanlevel <= victim->pcdata->clanlevel 
clan.c:                ||  ch->pcdata->clanlevel <= level ) {
clan.c:    if ( ch->clan->bank < level * level * 10000 )
clan.c:    if ( level > victim->pcdata->clanlevel )
clan.c:    ch->clan->member[victim->pcdata->clanlevel] -=1;
clan.c:    ch->clan->member[level] +=1;
clan.c:    victim->pcdata->clanlevel = level;
clan.c:    ch->clan->bank -= level * level * 10000;
clan.c:  if( !ch->clan ) return;
clan.c:    if ( ch->pcdata->clanlevel == 0 )
clan.c:    if ( !ch->clan || !victim->clan )
clan.c:    if ( victim != ch && victim->pcdata->clanlevel >= ch->pcdata->clanlevel )
clan.c:    if ( ch->clan != victim->clan )
clan.c:      sprintf(buf, "chat ¥»¤H«Å¥¬¡G«Ê %s ¬° %s¡I", victim->short_descr, arg);
clan.c:      for( cn = clan_list; cn; cn = cn->next )
clan.c:        || ( ch->clan == cn && ch->pcdata->clanlevel > 3 ))
clan.c:          sprintf( buf, " %-20s %12s %12s  %4d%10s(%2d) %lld\n\r",
clan.c:            cn->name, cn->founder,cn->leader, clan_members(cn), cc[cn->cclass].name, cn->cclass, cn->bank );
clan.c:          sprintf( buf, " %-20s %12s %12s  %4d %10s  %s\n\r",
clan.c:            cn->name, cn->founder,cn->leader, clan_members(cn), cc[cn->cclass].name, bank_desc(cn->bank));
clan.c:    if ( clan_war->fighting == 2 )
clan.c:        clan_war->clan_a->name, clan_war->clan_b->name );
clan.c:        sprintf( buf, "%s ¤è­±¤´µM¦z¥ß¦b¾Ô³õªº¤H­û¦³¡G", clan_war->clan_a->name );
clan.c:        if ( clan_war->clan_a_member[i] )
clan.c:            sprintf( buf1, "%s, ", clan_war->clan_a_member[i]->name );
clan.c:        sprintf( buf, "%s ¤è­±¤´µM¦z¥ß¦b¾Ô³õªº¤H­û¦³¡G", clan_war->clan_b->name );
clan.c:          if ( clan_war->clan_b_member[i] )
clan.c:            sprintf( buf1, "%s, ", clan_war->clan_b_member[i]->name );
clan.c:    if ( !ch->clan || ch->pcdata->clanlevel < 4 )
clan.c:    if ( ch->clan->desc )
clan.c:      strcpy( buf, ch->clan->desc );
clan.c:    if ( strlen( buf ) + strlen( argument ) >= MAX_STRING_LENGTH - 200 )
clan.c:    if(ch->clan->desc)
clan.c:        free_string( ch->clan->desc );
clan.c:    ch->clan->desc = str_dup( buf );
clan.c:    if ( !ch->clan || ch->pcdata->clanlevel < 4 )
clan.c:    if( ch->clan->desc )
clan.c:        free_string( ch->clan->desc );
clan.c:    ch->clan->desc = NULL;
clan.c:      for( cn = clan_list; cn; cn = cn->next )
clan.c:        if ( !str_cmp( cn->leader, arg ) )
clan.c:      send_to_char( cn->desc, ch );
clan.c:      if ( !ch->clan || ch->pcdata->clanlevel < 4 )
clan.c:      if ( ch->clan->bank < 1000000 )
clan.c:        if ( ch->clan->score < cc[i].exp )
clan.c:      if ( ch->clan->cclass < i )
clan.c:        ch->clan->cclass++;
clan.c:        ch->clan->bank -= 1000000;
clan.c:        ch->clan->name );
clan.c:      sprintf( buf, "%s"HIY"²{¦b¤w¬O¤@­Ó"NOR" %s "HIY"ªº²ÕÂ´¡I"NOR"\n\r", ch->clan->name, cc[ch->clan->cclass].name );
clan.c:        sprintf( buf, "§Aªº²ÕÂ´ÁÙ»Ý­n %d ÂIµo®iÂI¼Æ¤~¯à¤É¯Å¡C\n\r", cc[i].exp - ch->clan->score );
clan.c:    if ( !ch->clan || ch->pcdata->clanlevel < 3 || mch->clan != ch->clan
clan.c:      || lch->clan != ch->clan || !IS_NPC( mch ) )
clan.c:    if ( mch->level > lch->level + 5 )
clan.c:    mch->master = lch;
clan.c:      if ( ch->pcdata->clanlevel < 3 )
clan.c:      if ( ch->clan == clan_war->clan_a || ch->clan == clan_war->clan_b )
clan.c:      if ( clan_war->fighting == 2 )
clan.c:        sprintf( "%s ©M %s ªº¾Ô§ÐÁÙ¦b¶i¦æ¤¤¡A½Ðµy­Ô¡C\n\r", clan_war->clan_a->name,
clan.c:          clan_war->clan_b->name );
clan.c:      if ( !IS_SET( ch->act, PLR_REGISTER ) )
clan.c:      if ( ch->clan->bank < 500000 )
clan.c:      ch->clan->bank -= 500000;
clan.c:      if ( clan_war->fighting == 0 )
clan.c:      clan_war->fighting = 1;
clan.c:        clan_war->clan_a = ch->clan;
clan.c:        for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
clan.c:          if ( !IS_NPC( vch ) && vch->desc && IS_SET( vch->act, PLR_REGISTER )
clan.c:            && vch->clan == ch->clan )
clan.c:            clan_war->clan_a_member[clan_war->clan_a_num] = vch;
clan.c:            vch->pcdata->clanpk = 1;
clan.c:            clan_war->clan_a_num ++;
clan.c:            if ( clan_war->clan_a_num == 10 ) break;
clan.c:      clan_war->fighting = 2;
clan.c:        clan_war->clan_b = ch->clan;
clan.c:        for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
clan.c:          if ( !IS_NPC( vch ) && vch->desc && IS_SET( vch->act, PLR_REGISTER )
clan.c:            && vch->clan == ch->clan )
clan.c:            clan_war->clan_b_member[clan_war->clan_b_num] = vch;
clan.c:            vch->pcdata->clanpk = 1;
clan.c:            clan_war->clan_b_num ++;
clan.c:            if ( clan_war->clan_b_num == 10 ) break;
clan.c:        sprintf( buf, ""HIY"²V¨P¤Û¥@¨â¤j±jÅv -- "NOR"%s "HIY"©M"NOR" %s "HIY"Ãzµo¿E¯P¾Ô°«¡I"NOR"\n\r",
clan.c:        clan_war->clan_a->name, clan_war->clan_b->name );
clan.c:        sprintf( buf, "%s ¤è­±¥D­n°Ñ¾Ô¤H­û¦³¡G", clan_war->clan_a->name );
clan.c:        if ( clan_war->clan_a_member[i] )
clan.c:            sprintf( buf1, "%s, ", clan_war->clan_a_member[i]->name );
clan.c:        sprintf( buf, "%s ¤è­±¥D­n°Ñ¾Ô¤H­û¦³¡G", clan_war->clan_b->name );
clan.c:          if ( clan_war->clan_b_member[i] )
clan.c:            sprintf( buf1, "%s, ", clan_war->clan_b_member[i]->name );
clan.c:    if ( clan_war->fighting < 2 )
clan.c:      if ( ch->pcdata->clanlevel < 3 )
clan.c:      if ( ch->clan == clan_war->clan_a )
clan.c:        clan_war->clan_a->name, clan_war->clan_b->name );
clan.c:      clan_war->clan_b->bank += 1000000;
clan.c:        if ( clan_war->clan_a_member[i] )
clan.c:          clan_war->clan_a_member[i]->pcdata->clanpk = 0;
clan.c:          clan_war->clan_a_member[i] = NULL;
clan.c:        if ( clan_war->clan_b_member[i] )
clan.c:          clan_war->clan_b_member[i]->pcdata->clanpk = 0;
clan.c:          clan_war->clan_b_member[i] = NULL;
clan.c:      clan_war->fighting = 0;
clan.c:      clan_war->clan_a = NULL;
clan.c:      clan_war->clan_b = NULL;
clan.c:      clan_war->clan_a_num = 0;
clan.c:      clan_war->clan_b_num = 0;
clan.c:        clan_war->clan_b->name, clan_war->clan_a->name );
clan.c:      clan_war->clan_a->bank += 1000000;
clan.c:        if ( clan_war->clan_a_member[i] )
clan.c:          clan_war->clan_a_member[i]->pcdata->clanpk = 0;
clan.c:          clan_war->clan_a_member[i] = NULL;
clan.c:        if ( clan_war->clan_b_member[i] )
clan.c:          clan_war->clan_b_member[i]->pcdata->clanpk = 0;
clan.c:          clan_war->clan_b_member[i] = NULL;
clan.c:      clan_war->fighting = 0;
clan.c:      clan_war->clan_a = NULL;
clan.c:      clan_war->clan_b = NULL;
clan.c:      clan_war->clan_a_num = 0;
clan.c:      clan_war->clan_b_num = 0;
clan.c:            cn = ch->clan;
clan.c:                for ( cn = clan_list; cn; cn = cn->next )
clan.c:                    if ( !str_cmp( arg, cn->leader ) )
clan.c:            if ( IS_IMMORTAL( ch ) || ( ch->pcdata->clanlevel > 2 && ch->clan == cn ) )
clan.c:                for ( pArea = area_first; pArea; pArea = pArea->next )
clan.c:                    if ( pArea->clan == cn )
clan.c:                        for( vnum = pArea->lvnum ; vnum <= pArea->uvnum; ++vnum )
clan.c:            sprintf( buf, "Á`¸g¶O¡G%lld\n\r", cn->bank );
clan.c:            sprintf( buf, "²ÕÂ´µ¥¯Å¡G%d, %s\n\r", cn->cclass, cc[cn->cclass].name );
clan.c:            sprintf( buf, "²Ö¿nµo®iÂI¼Æ/¤É¯Å©Ò»ÝÂI¼Æ¡G%d/%d\n\r", cn->score, cc[cn->cclass].exp - cn->score );
clan.c:            sprintf( buf, "¶±¥ÎÂI¼Æ¡G%d\n\r", cn->hire );
clan.c:            sprintf( buf, "»s³yÂI¼Æ¡G%d\n\r", cn->construct );
clan.c:            sprintf( buf, "¾Ô§Ð°O¿ý¡G%d ³Ó %d ±Ñ\n\r", cn->warwin, cn->warlose );
clan.c:  if( !ch->clan ) return;
clan.c:    ch->clan->name,
clan.c:    ch->cname,
clan.c:    ch->name,
clan.c:  for ( d = descriptor_list; d; d = d->next )
clan.c:      victim = (d->original) ? d->original : d->character;
clan.c:      if( victim && !victim->clan ) continue;
clan.c:      //if( !str_cmp( clan_name, victim->clan->name)){
clan.c:      if( victim && victim->clan == ch->clan ){
clan.c:    if( !ch->in_room || !ch->clan) return;
clan.c:  for( auction = auction_list ; auction; auction = auction->next ){
clan.c:      if( ch == auction->buyer || ch == auction->owner )
clan.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
clan.c:    place = ch->clan->crecall;
clan.c:    if( !(ch->in_room->area->recall == location->area->recall ))
clan.c:    if ( ch->in_room == location )
clan.c:    if ( ( victim = ch->fighting ) )
clan.c:      lose = ( ch->desc ) ? 12 : 25;
clan.c:      gain_exp( ch, 0 - lose );
clan.c:  lose = ( ch->desc ) ? 25 : 50;
clan.c:  gain_exp( ch, 0 - lose );
clan.c:    ch->move /= 2;
clan.c:    if ( ch->in_room->roomprogs && ( ch->in_room->progtypes & ROOM_LEAVE )
clan.c:  && !IS_SET( ch->act, PLR_WIZINVIS ) )
clan.c:  rprog_leave_trigger( ch->in_room, ch, 6 );
clan.c:  if ( IS_SET( ch->act, PLR_HORSE ) && ch->desc )
clan.c:    horse = ch->pcdata->horse;
clan.c:      if ( horse->in_room->roomprogs && ( horse->in_room->progtypes & ROOM_LEAVE )
clan.c:    && !IS_SET( horse->act, PLR_WIZINVIS ) )
clan.c:    rprog_leave_trigger( horse->in_room, horse, 6 );
clan.c:  if ( ch->pcdata && ch->pcdata->horse && ch->pcdata->horse )
clan.c:    if ( ch->in_room != ( horse = ch->pcdata->horse )->in_room )
commands.c://*---------------------------------------------------------------*
commands.c://*---------------------------------------------------------------*
commands.c://*---------------------------------------------------------------*
commands.c://*---------------------------------------------------------------*
commands.c://*---------------------------------------------------------------*
commands.c://*---------------------------------------------------------------*
commands.c://*---------------------------------------------------------------*
commands.c: * God Levels - Check them out in merc.h
commands.c: * Log-all switch.
commands.c:		/* Adopt mapping to these num-pad commands
comm.c: *  Thanks to abaddon for proof-reading our comm.c and pointing out bugs.  *
comm.c: * This file contains all of the OS-dependent stuff:
comm.c: *    Game_loop ---> Read_from_descriptor ---> Read
comm.c: *    Game_loop ---> Read_from_buffer
comm.c: *    Game_loop ---> Process_Output ---> Write_to_descriptor -> Write
comm.c: * The OS-dependent functions are Read_from_descriptor and Write_to_descriptor.
comm.c: * -- Furey  26 Jan 1993
comm.c://*---------------------------------------------------------------*
comm.c://*---------------------------------------------------------------*
comm.c://*---------------------------------------------------------------*
comm.c://*---------------------------------------------------------------*
comm.c://*---------------------------------------------------------------*
comm.c://*---------------------------------------------------------------*
comm.c://*---------------------------------------------------------------*
comm.c://*---------------------------------------------------------------*
comm.c://*---------------------------------------------------------------*
comm.c: * Also include these assigns in your user-startup (After the SC assigns)
comm.c: * 4-16-96
comm.c: * OS-dependent declarations.
comm.c: * OS-dependent local functions.
comm.c:#define RFC931_PORT 113   *//* Semi-well-known port *//*
comm.c: * Other local functions (OS-independent).
comm.c:      d_next    = d->next;
comm.c:      d->fcommand        = FALSE;
comm.c:      if ( d->character )
comm.c:    d->character->timer = 0;
comm.c:    if ( d->character )
comm.c:        save_char_obj( d->character );
comm.c:    d->outtop  = 0;
comm.c:      if ( d->character && d->character->wait > 0 )
comm.c:    --d->character->wait;
comm.c:      if ( d->incomm[0] != '\0' )
comm.c:    d->fcommand    = TRUE;
comm.c:    stop_idling( d->character );
comm.c:    if ( d->showstr_point )
comm.c:        show_string( d, d->incomm );
comm.c:    if ( d->pString )
comm.c:        string_add( d->character, d->incomm );
comm.c:        if ( d->connected == CON_PLAYING )
comm.c:/*          if ( d->showstr_point )
comm.c:      show_string( d, d->incomm );
comm.c:          interpret( d->character, d->incomm );
comm.c:      nanny( d, d->incomm );
comm.c:    d->incomm[0]      = '\0';
comm.c:      d_next = d->next;
comm.c:      if ( ( d->fcommand || d->outtop > 0 ) )
comm.c:              if ( d->character )
comm.c:                  save_char_obj( d->character );
comm.c:              d->outtop      = 0;
comm.c:    dcon.character->timer = 0;
comm.c:        save_char_obj( d->character );
comm.c:      delta = ( now_time.tv_sec  - last_time.tv_sec  ) * 1000 * 1000
comm.c:      + ( now_time.tv_usec - last_time.tv_usec );
comm.c:    for ( d = descriptor_list; d; d = d->next )
comm.c:      maxdesc = UMAX( (unsigned) maxdesc, d->descriptor );
comm.c:      FD_SET( d->descriptor, &in_set  );
comm.c:      FD_SET( d->descriptor, &out_set );
comm.c:      FD_SET( d->descriptor, &exc_set );
comm.c:      d_next = d->next; 
comm.c:      if ( FD_ISSET( d->descriptor, &exc_set ) )
comm.c:        FD_CLR( d->descriptor, &in_set  );
comm.c:        FD_CLR( d->descriptor, &out_set );
comm.c:        if ( d->character )
comm.c:          save_char_obj( d->character );
comm.c:        d->outtop  = 0;
comm.c:      d_next    = d->next;
comm.c:      d->fcommand        = FALSE;
comm.c:      if ( FD_ISSET( d->descriptor, &in_set ) )
comm.c:        if ( d->character )
comm.c:          d->character->timer = 0;
comm.c:          FD_CLR( d->descriptor, &out_set );
comm.c:          if ( d->character )
comm.c:            save_char_obj( d->character );
comm.c:          d->outtop      = 0;
comm.c:      if ( d->character && d->character->pcdata
comm.c:          && d->character->pcdata->horse 
comm.c:          && d->character->pcdata->horse->wait
comm.c:          && d->character->pcdata->horse->wait > 0)
comm.c:        --d->character->pcdata->horse->wait;
comm.c:      if ( d->character && d->character->wait > 0 )
comm.c:        --d->character->wait;
comm.c:      if ( d->incomm[0] != '\0' )
comm.c:        d->fcommand    = TRUE;
comm.c:        stop_idling( d->character );
comm.c:        if ( d->showstr_point )
comm.c:          show_string( d, d->incomm );
comm.c:          if ( d->pString )
comm.c:            string_add( d->character, d->incomm );
comm.c:            if ( d->connected == CON_PLAYING )
comm.c:              /*          if ( d->showstr_point )
comm.c:                      show_string( d, d->incomm );
comm.c:                interpret( d->character, d->incomm );
comm.c:              nanny( d, d->incomm );
comm.c:        d->incomm[0]      = '\0';
comm.c:      if ((n=read(fd1[0],read_pipe_ptr,MAX_STRING_LENGTH-(read_pipe_ptr-read_pipe_buf)-1))>0) {
comm.c:                if (resolving->character 
comm.c:                  && !str_cmp(buf1, resolving->character->name) 
comm.c:                  && str_cmp(buf2, resolving->host)) {
comm.c:                  free_string(resolving->host);
comm.c:                  resolving->host=str_dup(buf2);
comm.c:                  for ( pban = ban_list; pban; pban = pban->next )
comm.c:                    if ( !str_infix( pban->name, resolving->host ) )
comm.c:                      write_to_descriptor( resolving->descriptor,
comm.c:                if (resolving->character && !str_cmp(buf1, resolving->character->name) && str_cmp(buf2, resolving->remoteuser)) {
comm.c:                  free_string(resolving->remoteuser);
comm.c:                  resolving->remoteuser=str_dup(buf2);
comm.c:      d_next = d->next;
comm.c:      if ( ( d->fcommand || d->outtop > 0 )
comm.c:          && FD_ISSET( d->descriptor, &out_set ) )
comm.c:          if ( d->character )
comm.c:            save_char_obj( d->character );
comm.c:          d->outtop      = 0;
comm.c:     * Sleep( last_time + 1/PULSE_PER_SECOND - now ).
comm.c:        - ( (int)  now_time.tv_usec )
comm.c:        - ( (int)  now_time.tv_sec );
comm.c:        secDelta  -= 1;
comm.c:        usecDelta -= 1000000;
comm.c:                  (double) ( ( end_time.time - start_time.time ) +
comm.c:                         ( (double) ( end_time.millitm -
comm.c:          Sleep( (int) ( (double) ( 1000 / PULSE_PER_SECOND ) -
comm.c:  if ( fcntl( desc, F_SETFL, FNDELAY ) == -1 )
comm.c:    descriptor_free        = descriptor_free->next;
comm.c:  dnew->descriptor      = desc;
comm.c:  dnew->character = NULL;
comm.c:  dnew->connected    = CON_GET_NAME;
comm.c:  dnew->showstr_head  = str_dup( "" );
comm.c:  dnew->showstr_point = 0;
comm.c:  dnew->pEdit          = NULL;            /* OLC */
comm.c:  dnew->pString = NULL;     /* OLC */
comm.c:  dnew->editor  = 0;          /* OLC */
comm.c:  dnew->outsize  = 2000;
comm.c:  dnew->outbuf  = alloc_mem( dnew->outsize );
comm.c:  dnew->trytimes  = 1;
comm.c:  /*    dnew->remoteuser = str_dup( rfc931_name( (int)desc, (struct sockaddr_in*)&sock ) );*/
comm.c:  dnew->remoteuser=str_dup("UNKNOWN");
comm.c:  dnew->host=str_dup(buf);
comm.c:      dnew->host = str_dup( from ? from->h_name : buf );*/
comm.c:  for ( pban = ban_list; pban; pban = pban->next )
comm.c:    if ( !str_prefix( pban->name, dnew->host ) )
comm.c:      free_string( dnew->showstr_head );
comm.c:      free_string( dnew->remoteuser );
comm.c:      free_string( dnew->host );
comm.c:      free_mem( dnew->outbuf/*, dnew->outsize */);
comm.c:      dnew->next          = descriptor_free;
comm.c:  dnew->next            = descriptor_list;
comm.c:    for ( dcount = descriptor_list, i=0; dcount; dcount = dcount->next, i++ )
comm.c:    	if ( dcount->connected != CON_PLAYING ) continue;
comm.c:        for ( dcount2 = dcount->next; dcount2 ; dcount2 = dcount2->next )
comm.c:            if ( dcount2->connected != CON_PLAYING ) continue;
comm.c:            if ( !str_cmp ( dcount2->host, dcount->host ) )
comm.c:    random_greeting = number_range( 0, num_greeting - 1 );
comm.c:    CHAR_DATA *phorse = ch->pcdata->horse;
comm.c:    phorse = ch->pcdata->horse;
comm.c:      for( auction = auction_list ; auction; auction = auction->next ){
comm.c:    if( auction->owner == ch || auction->buyer == ch )
comm.c:    if ( ch->position == POS_FIGHTING )
comm.c:    if ( phorse && phorse->position == POS_FIGHTING )
comm.c:    if ( ch->in_room->roomprogs && ( ch->in_room->roomprogs->type & ROOM_LEAVE )
comm.c:  && !IS_SET( ch->act, PLR_WIZINVIS ) )
comm.c:    rprog_leave_trigger( ch->in_room, ch, 7 );
comm.c:    sprintf( log_buf, "%s close socket force quit.", ch->name );
comm.c:    for ( obj = ch->carrying; obj; obj = obj_next_content )
comm.c:    obj_next_content = obj->next_content;
comm.c:      if ( obj->deleted )
comm.c:    if ( IS_SET( obj->extra_flags, ITEM_NOSAVE )
comm.c:      || ( ch->level < ( obj->level - 5 ) && ch->class < 5 ) )
comm.c:        obj_to_room( obj, ch->in_room );
comm.c:    if ( dclose->outtop > 0 )
comm.c:    if ( dclose->snoop_by )
comm.c:  write_to_buffer( dclose->snoop_by,
comm.c:  for ( d = descriptor_list; d; d = d->next )
comm.c:      if ( d->snoop_by == dclose )
comm.c:    d->snoop_by = NULL;
comm.c:    if ( ( ch = dclose->character ) )
comm.c:  sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c:  if ( dclose->connected == CON_PLAYING )
comm.c:	if( ch->neweqbank )
comm.c:		sprintf( tmp, "%s%s/%s", EQBANK_DIR, initial ( ch->neweqbank->name), capitalize (ch->neweqbank->name) );
comm.c:		ch->neweqbank->opened = FALSE;
comm.c:			free_neweqbank (ch->neweqbank);
comm.c:			ch->neweqbank = NULL;
comm.c:      if( ch->desc && ch->desc->original && ch->desc->original->pcdata 
comm.c:        && ch->desc->original->pcdata->switched )
comm.c:        CHAR_DATA * och = ch->desc->original;
comm.c:      if( IS_SET( ch->act, PLR_HORSE ) )
comm.c:      ch->desc = NULL;
comm.c:      free_char( dclose->character );
comm.c:  d_next = d_next->next;   
comm.c:  descriptor_list = descriptor_list->next;
comm.c:  for ( d = descriptor_list; d && d->next != dclose; d = d->next )
comm.c:      d->next = dclose->next;
comm.c:    close( dclose->descriptor );
comm.c:    closesocket( dclose->descriptor );
comm.c:    free_string( dclose->showstr_head );
comm.c:    free_string( dclose->host );
comm.c:    free_string( dclose->remoteuser );
comm.c:    free_mem( dclose->outbuf/*, dclose->outsize */);
comm.c:    dclose->next  = descriptor_free;
comm.c:    if ( dclose->outtop > 0 )
comm.c:    if ( dclose->snoop_by )
comm.c:  write_to_buffer( dclose->snoop_by,
comm.c:  for ( d = descriptor_list; d; d = d->next )
comm.c:      if ( d->snoop_by == dclose )
comm.c:    d->snoop_by = NULL;
comm.c:    if ( ( ch = dclose->character ) )
comm.c:  sprintf( log_buf, "%s Reconnected.", ch->name );
comm.c:  if ( dclose->connected == CON_PLAYING )
comm.c:      if( ch->desc && ch->desc->original && ch->desc->original->pcdata 
comm.c:        && ch->desc->original->pcdata->switched )
comm.c:    if( IS_SET(ch->act, PLR_HORSE ))
comm.c:        CHAR_DATA * och = ch->desc->original;
comm.c:    ch->desc->character = ch->desc->original;
comm.c:    ch->desc->original = NULL;
comm.c:    ch->desc->character->pcdata->switched = FALSE;
comm.c:    ch->desc->character->desc = ch->desc;
comm.c:      ch->desc = NULL;
comm.c:      free_char( dclose->character );
comm.c:  d_next = d_next->next;   
comm.c:  descriptor_list = descriptor_list->next;
comm.c:  for ( d = descriptor_list; d && d->next != dclose; d = d->next )
comm.c:      d->next = dclose->next;
comm.c:    close( dclose->descriptor );
comm.c:    closesocket( dclose->descriptor );
comm.c:    free_string( dclose->showstr_head );
comm.c:    free_string( dclose->host );
comm.c:    free_string( dclose->remoteuser );
comm.c:    free_mem( dclose->outbuf/*, dclose->outsize */);
comm.c:    dclose->next  = descriptor_free;
comm.c:    if ( d->incomm[0] != '\0' )
comm.c:    iStart = strlen( d->inbuf );
comm.c:/*    while ( iStart>=3 && d->inbuf[iStart-1]=='\x01'
comm.c:    && d->inbuf[iStart-2]=='\xfd' && d->inbuf[iStart-3]=='\xff' )
comm.c:  iStart-=3; */
comm.c:    if ( iStart >= sizeof( d->inbuf ) - 10 )
comm.c:  write_to_descriptor( d->descriptor,
comm.c:  d->inbuf[iStart++] = c;
comm.c:  if ( iStart > sizeof( d->inbuf ) - 10 )
comm.c:  nRead = read( d->descriptor, d->inbuf + iStart,
comm.c:         sizeof( d->inbuf ) - 10 - iStart );
comm.c:  nRead = recv( d->descriptor, d->inbuf + iStart,
comm.c:         sizeof( d->inbuf ) - 10 - iStart, 0 );
comm.c:      if ( d->inbuf[iStart-1] == '\n' || d->inbuf[iStart-1] == '\r' )
comm.c:    d->inbuf[iStart] = '\0';
comm.c:    if ( d->incomm[0] != '\0' )
comm.c:    for ( i = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r'; i++ )
comm.c:  if ( d->inbuf[i] == '\0' )
comm.c:    for ( i = 0, k = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r'; i++ )
comm.c:  if ( k >= MAX_INPUT_LENGTH - 2 )
comm.c:      write_to_descriptor( d->descriptor, "Line too long.\n\r", 0 );
comm.c:      for ( ; d->inbuf[i] != '\0'; i++ )
comm.c:    if ( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
comm.c:      d->inbuf[i]   = '\n';
comm.c:      d->inbuf[i+1] = '\0';
comm.c:  if ( d->inbuf[i] == '\b' && k > 0 )
comm.c:      --k;
comm.c:  else if ( iscntrl( d->inbuf[i] ) ) {
comm.c:      if ( d->inbuf[i]=='\b' || d->inbuf[i]=='\n' || d->inbuf[i]=='\r' || d->inbuf[i]=='\t' || d->inbuf[i]=='\0' )
comm.c:    d->incomm[k++]=d->inbuf[i];
comm.c:      else if ( d->inbuf[i]=='\x1b' && d->inbuf[i+1]=='[') {
comm.c:    for (l=i+2;isdigit(d->inbuf[l]) || d->inbuf[l]==';';l++);
comm.c:    if ( d->inbuf[l]=='m' )
comm.c:        d->incomm[k++]=d->inbuf[i];
comm.c:  else /* if ( ( isascii( d->inbuf[i] ) && isprint( d->inbuf[i] ) )
comm.c:    || ( d->inbuf[i]>'\x80' && d->inbuf[i]<'\xff' )
comm.c:    || d->inbuf[i]=='\x1b' ) */
comm.c:      d->incomm[k++] = d->inbuf[i];
comm.c:  d->incomm[k++] = ' ';
comm.c:    d->incomm[k] = '\0';
comm.c:    if ( k > 1 || d->incomm[0] == '!' )
comm.c:      if ( d->incomm[0] != '!' && strcmp( d->incomm, d->inlast ) )
comm.c:      d->repeat = 0;
comm.c:      if ( ++d->repeat >= 20 )
comm.c:    write_to_descriptor( d->descriptor,
comm.c:    strcpy( d->incomm, "quit" );
comm.c:    if ( d->incomm[0] == '!' )
comm.c:  strcpy( d->incomm, d->inlast );
comm.c:  strcpy( d->inlast, d->incomm );
comm.c:    while ( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
comm.c:    for ( j = 0; ( d->inbuf[j] = d->inbuf[i+j] ) != '\0'; j++ )
comm.c:    if ( fPrompt && !merc_down && d->connected == CON_PLAYING )        /* OLC */
comm.c:      if ( d->showstr_point )
comm.c:      }else if ( d->pString ){
comm.c:          ch = d->original ? d->original : d->character;
comm.c:          if ( IS_SET( ch->act, PLR_BLANK ) )
comm.c:          if ( IS_SET( ch->act, PLR_PROMPT  ) )
comm.c:          //if ( IS_SET( ch->act, PLR_TELNET_GA ) )
comm.c:     * Short-circuit if nothing to write.
comm.c:    if ( d->outtop == 0 )
comm.c:     * Snoop-o-rama.
comm.c:    if ( d->snoop_by )
comm.c:        write_to_buffer( d->snoop_by, "% ", 2 );
comm.c:        write_to_buffer( d->snoop_by, d->outbuf, d->outtop );
comm.c:     * OS-dependent output.
comm.c:    if ( !write_to_descriptor( d->descriptor, d->outbuf, d->outtop ) )
comm.c:        d->outtop = 0;
comm.c:        write_to_descriptor( d->descriptor, d->outbuf, d->outtop );
comm.c:        d->outtop = 0;
comm.c:        d->outtop = 0;
comm.c:   ch = ( d->original ? d->original : d->character );
comm.c:   if( !ch->pcdata->prompt || ch->pcdata->prompt[0] == '\0' )
comm.c:   str = ch->pcdata->prompt;
comm.c:      if ( ch->hit > ch->max_hit * 3 / 4 )
comm.c:    else if ( ch->hit > ch->max_hit / 2 )
comm.c:    else if ( ch->hit > ch->max_hit / 4 )
comm.c:      sprintf( buf3, "%d[m", ch->hit );
comm.c:      sprintf( buf2, "%d", ch->max_hit             );
comm.c:      sprintf( buf2, "%d", ch->mana            );
comm.c:      sprintf( buf2, "%d", ch->max_mana            );
comm.c:      sprintf( buf2, "%d", ch->move            ); 
comm.c:      sprintf( buf2, "%d", ch->max_move            );
comm.c:      sprintf( buf2, "%d", ch->exp             );
comm.c:      sprintf( buf2, "%d", ch->level );
comm.c:      sprintf( buf2, "%d",  EXP_PER_LEVEL( ch->level ,ch->class) * (ch->level + 1 ) - ch->exp );
comm.c:      sprintf( buf2, "%d", ch->gold            );
comm.c:      sprintf( buf2, "%d", ch->wait            );
comm.c:      if( ch->level > 10 )
comm.c:         sprintf( buf2, "%d", ch->alignment          );
comm.c:      if( ch->in_room )
comm.c:         sprintf( buf2, "%s", ch->in_room->name          );
comm.c:      if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:         sprintf( buf2, "%d", ch->in_room->vnum          );
comm.c:      if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:         sprintf( buf2, "%s", ch->in_room->area->name        );
comm.c:         sprintf( buf2, "(wizinv: %s)", IS_SET( ch->act, PLR_WIZINVIS ) ?
comm.c:   write_to_buffer( d, buf, point - buf );
comm.c:  if ( d->original )
comm.c:    ch = d->character;
comm.c:   if( !ch->pcdata || !ch->pcdata->prompt || ch->pcdata->prompt[0] == '\0' )
comm.c:   str = ch->pcdata->prompt;
comm.c:      sprintf( buf2, "%d", ch->hit             );
comm.c:      sprintf( buf2, "%d", ch->max_hit             );
comm.c:      sprintf( buf2, "%d", ch->mana            );
comm.c:      sprintf( buf2, "%d", ch->max_mana            );
comm.c:      sprintf( buf2, "%d", ch->move            ); 
comm.c:      sprintf( buf2, "%d", ch->max_move            );
comm.c:      sprintf( buf2, "%d", ch->exp             );
comm.c:      sprintf( buf2, "%d", ch->level );
comm.c:      sprintf( buf2, "%d",  EXP_PER_LEVEL( ch->level,ch->class ) * (ch->level + 1 ) - ch->exp );
comm.c:      sprintf( buf2, "%d", ch->gold            );
comm.c:      sprintf( buf2, "%d", ch->wait            );
comm.c:      if( ch->level > 10 )
comm.c:         sprintf( buf2, "%d", ch->alignment          );
comm.c:      if( ch->in_room )
comm.c:         sprintf( buf2, "%s", ch->in_room->name          );
comm.c:      if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:         sprintf( buf2, "%d", ch->in_room->vnum          );
comm.c:      if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:         sprintf( buf2, "%s", ch->in_room->area->name        );
comm.c:         sprintf( buf2, "(wizinv: %s)", IS_SET( ch->act, PLR_WIZINVIS ) ?
comm.c:   write_to_buffer( d, buf, point - buf );  
comm.c:    if ( d->outtop == 0 && !d->fcommand )
comm.c:        d->outbuf[0]      = '\n';
comm.c:        d->outbuf[1]      = '\r';
comm.c:        d->outtop  = 2;
comm.c:    while ( d->outtop + length >= d->outsize )
comm.c:        if ( d->outsize >= 32000 )
comm.c:            d->outtop = 0;
comm.c:                ( d->character ? d->character->name : "???" ) );
comm.c://      write_to_descriptor( d->descriptor, "\n\r*** BUFFER OVERFLOW!!! ***\n\r", 0 );
comm.c:        outbuf      = alloc_mem( 2 * d->outsize );
comm.c:        strncpy( outbuf, d->outbuf, d->outtop );
comm.c:        free_mem( d->outbuf/*, d->outsize */);
comm.c:        d->outbuf   = outbuf;
comm.c:        d->outsize *= 2;
comm.c:    strncpy( d->outbuf + d->outtop, txt, length );
comm.c:    d->outtop += length;
comm.c:    if ( d->outtop == 0 && !d->fcommand )
comm.c:  d->outbuf[0]      = '\n';
comm.c:  d->outbuf[1]      = '\r';
comm.c:  d->outtop  = 2;
comm.c:    while ( d->outtop + length >= d->outsize )
comm.c:  outbuf      = alloc_mem( 2 * d->outsize );
comm.c:  strncpy( outbuf, d->outbuf, d->outtop );
comm.c:  free_mem( d->outbuf*, d->outsize* );
comm.c:  d->outbuf   = outbuf;
comm.c:  d->outsize *= 2;
comm.c:    strncpy( d->outbuf + d->outtop, txt, length );
comm.c:    d->outtop += length;
comm.c:        nBlock = UMIN( length - iStart, 4096 );
comm.c:  /* This is here so we wont get warnings.  ch = NULL anyways - Kahn */
comm.c:  ch    = d->character;
comm.c:  switch ( d->connected )
comm.c:      bug( "Nanny: bad d->connected %d.", d->connected );
comm.c:        if( ++d->trytimes > _MAX_TRYTIMES_ ) {
comm.c:      sprintf( log_buf, "Pre-name check: %s", argument );
comm.c:      ch   = d->character;
comm.c:      if ( IS_SET( ch->act, PLR_DENY ) )
comm.c:        if( IS_NPC(ch) || time(NULL) <= ch->pcdata->denied ){
comm.c:        else REMOVE_BIT(ch->act, PLR_DENY);
comm.c:      for( check1 = descriptor_list;check1;check1 = check1->next)
comm.c:        //    if ( d == check1 || !check1->character || check1->character->deleted || IS_NPC(check1->character))
comm.c:        if ( (!check1->character 
comm.c:              || check1->character->deleted 
comm.c:              || IS_NPC(check1->character)) &&
comm.c:            (!check1->original || !check1->original->name ) )
comm.c:        if (!str_cmp( d->character->name, check1->character->name) 
comm.c:            && (!IS_IMMORTAL( check1->character )
comm.c:              || ( check1->original 
comm.c:                && !str_cmp(check1->original->name, d->character->name))) )
comm.c:          if (check1->character->desc) 
comm.c:            d->connected = CON_GET_NAME;
comm.c:            if( ++d->trytimes > _MAX_TRYTIMES_ ) close_socket(d);
comm.c:      for( check = char_list;check;check = check->next)
comm.c:        if ( check->deleted 
comm.c:            || IS_SET(check->act, PLR_HORSE))
comm.c:      if (!str_cmp( d->character->name, check->name) 
comm.c:          if (check->desc) 
comm.c:            d->connected = CON_GET_NAME;
comm.c:            if( ++d->trytimes > _MAX_TRYTIMES_ ) close_socket(d);
comm.c:            &&  !IS_SET( ch->act, PLR_WIZBIT ) 
comm.c:        if ( ch->level <= numlock
comm.c:            && !IS_SET( ch->act, PLR_WIZBIT )
comm.c:          if ( ch->level == 0 )
comm.c:      if ( /*!IS_SET( ch->act, PLR_REPLACE ) &&*/ ch->level < L_APP )
comm.c:        if ( check_playing( d, ch->name ) )
comm.c:        d->connected = CON_GET_OLD_PASSWORD;
comm.c:        d->connected = CON_CONFIRM_NEW_NAME;
comm.c:      if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:        d->connected = CON_GET_NAME;
comm.c:        if( ++d->trytimes > _MAX_TRYTIMES_ ) close_socket( d );
comm.c:      if ( check_reconnect( d, ch->name, TRUE ) )
comm.c:      if ( check_playing( d, ch->name) )
comm.c:      sprintf( log_buf, "%s, $U@$H has connected.", ch->name );
comm.c:      lines = ch->pcdata->pagelen;
comm.c:      ch->pcdata->pagelen = 40;
comm.c:      ch->pcdata->pagelen = lines;
comm.c:      d->connected = CON_READ_MOTD;
comm.c:      //  ch->next  = char_list;
comm.c:          set_cname( ch, ch->name );
comm.c:              ch->name, echo_off_str );
comm.c:          d->connected = CON_GET_NEW_PASSWORD;
comm.c:          free_char( d->character );
comm.c:          d->character = NULL;
comm.c:          d->connected = CON_GET_NAME;
comm.c:      pwdnew = crypt( argument, ch->name );
comm.c:      free_string( ch->pcdata->pwd );
comm.c:      ch->pcdata->pwd        = str_dup( pwdnew );
comm.c:      d->connected = CON_CONFIRM_NEW_PASSWORD;
comm.c:      if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:        d->connected = CON_GET_NEW_PASSWORD;
comm.c:      d->connected = CON_DISPLAY_RACE;
comm.c:      d->connected = CON_GET_NEW_RACE;
comm.c:          ch->race = race_lookup( race_table[iRace].name );
comm.c:      do_help( ch, race_table[ch->race].name );
comm.c:      d->connected = CON_CONFIRM_NEW_RACE;
comm.c:                  d->connected = CON_DISPLAY_RACE;
comm.c:      d->connected = CON_GET_NEW_SEX;
comm.c:        case 'm': case 'M': ch->sex = SEX_MALE;    break;
comm.c:        case 'f': case 'F': ch->sex = SEX_FEMALE;  break;
comm.c:        case 'n': case 'N': ch->sex = SEX_NEUTRAL; break;
comm.c:      d->connected = CON_DISPLAY_CLASS;
comm.c:      d->connected = CON_GET_NEW_CLASS;
comm.c:          ch->class = iClass;
comm.c:      switch ( ch->class )
comm.c:        bug( "Nanny CON_GET_NEW_CLASS:  ch->class (%d) not valid",
comm.c:            ch->class );
comm.c:      d->connected = CON_CONFIRM_CLASS;
comm.c:                  d->connected = CON_DISPLAY_CLASS;
comm.c:      sprintf( log_buf, "%s, $U@$H new player.", ch->name );
comm.c:      ch->pcdata->pagelen = 20;
comm.c:      //  ch->dodge += race_table[ ch->race ].nature_dodge;
comm.c:      //  ch->armor += race_table[ ch->race ].nature_ac;
comm.c:      d->connected = CON_READ_MOTD;
comm.c:      ch->next  = char_list;
comm.c:      d->connected      = CON_PLAYING;
comm.c:      if ( ch->level == 0 )
comm.c:        switch ( class_table[ch->class].attr_prime )
comm.c:          case APPLY_STR: ch->perm_str = 16; break;
comm.c:          case APPLY_INT: ch->perm_int = 16; break;
comm.c:          case APPLY_WIS: ch->perm_wis = 16; break;
comm.c:          case APPLY_DEX: ch->perm_dex = 16; break;
comm.c:          case APPLY_CON: ch->perm_con = 16; break;
comm.c:        switch ( ch->class )
comm.c:          case MAGE :   ch->pcdata->prime_attr = APPLY_INT;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:          case CLERIC :   ch->pcdata->prime_attr = APPLY_WIS;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:          case THIEF :  ch->pcdata->prime_attr = APPLY_DEX;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:          case WARRIOR :  ch->pcdata->prime_attr = APPLY_STR;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:          case BARBARIAN :ch->pcdata->prime_attr = APPLY_CON;
comm.c:                  ch->pcdata->snd_attr = APPLY_NONE;
comm.c:        ch->level      = 1;
comm.c:        ch->exp    = 1000;
comm.c:        ch->gold  = 10000 + number_fuzzy( 3 )
comm.c:        ch->hit    = ch->max_hit;
comm.c:        ch->mana      = ch->max_mana;
comm.c:        ch->move      = ch->max_move;
comm.c:        sprintf( buf, "- %s",
comm.c:            c_title_table [ch->class] [ch->level]
comm.c:            [ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c:        free_string( ch->pcdata->prompt );
comm.c:        ch->pcdata->prompt = str_dup( "[m<¥Í©R[1;32m%h[mÅ]ªk[1;34m%m[m²¾°Ê[1;35m%v[m> " );
comm.c:        if ( !IS_SET( race_table[ ch->race ].race_abilities, RACE_BEHOLDER ) )
comm.c:              get_obj_index( class_table[ch->class].weapon ),
comm.c:      else if ( ch->in_room )
comm.c:        char_to_room( ch, ch->in_room );
comm.c:        if ( IS_SET( ch->pcdata->ride, 1 ) )
comm.c:        sprintf( log_buf, "Load %s's horse.", ch->name );
comm.c:        horse = load_horse_obj( d, ch->name );
comm.c:        if ( !horse || horse->long_descr[0] == '\0' )
comm.c:        ch->pcdata->ride = 0;
comm.c:        ch->pcdata->horse = NULL;
comm.c:        char_to_room( horse, ch->in_room );
comm.c:        horse->next = char_list;
comm.c:        horse->leader = ch;
comm.c:        ch->pcdata->horse = horse;
comm.c:        horse->pcdata->horse = ch;
comm.c:         if ( ch->gold + ch->bank > 10000000 )
comm.c:         bug( ch->name, 0 );
comm.c:         bug( "gold + bank = %d", ch->gold + ch->bank );
comm.c:         ch->gold = 1000000;
comm.c:         ch->bank = 0;  
comm.c:      if ( !IS_SET( ch->act, PLR_WIZINVIS )
comm.c:      for ( pnote = note_list; pnote; pnote = pnote->next )
comm.c:        if ( is_note_to( ch, pnote ) && str_cmp( ch->name, pnote->sender )
comm.c:            && pnote->date_stamp > ch->last_note )
comm.c:  if( !ch->desc)
comm.c:  ch_d = ch->desc;
comm.c:  for( d = descriptor_list; d; d = d->next )
comm.c:    to = (d->original) ? d->original : d->character;
comm.c:    if( d->connected != CON_PLAYING )
comm.c:    if( !str_cmp( ch->name , to->name )) 
comm.c:    if( !str_cmp( ch_d->host , d->host ))
comm.c:        strcat(buf, to->name);
comm.c:      strcat(buf, ch->name);
comm.c:      pMobIndex  = pMobIndex->next )
comm.c:    if ( is_name( name, pMobIndex->player_name ) )
comm.c: * Look for link-dead player to reconnect.
comm.c:    for ( ch = char_list; ch; ch = ch->next )
comm.c:  if ( ch->deleted || IS_NPC( ch ) || IS_SET(ch->act, PLR_HORSE))
comm.c:  if ( ( !fConn || !ch->desc /*|| IS_SET( ch->act, PLR_REPLACE)*/ )
comm.c:      && !str_cmp( d->character->name, ch->name))
comm.c:    free_string( d->character->pcdata->pwd );
comm.c:    d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:    ch->desc->original->pcdata->switched  = FALSE;
comm.c:    ch->desc->character = horse;
comm.c:    ch->desc->original = NULL;
comm.c:    horse->desc = ch->desc;
comm.c:    ch->desc = NULL;
comm.c:    REMOVE_BIT( horse->pcdata->ride, 2 );
comm.c:    horse->master = NULL;
comm.c:    ch->leader = horse;
comm.c:    horse->leader = NULL;
comm.c:    if( IS_SET(ch->act, PLR_HORSE ) && ch->desc)
comm.c:    else if( ch->pcdata->switched ) {
comm.c:        if( !ch->desc ) {
comm.c:/*  ¦³¨âºØ¨ú¥N¡A¤@¬OÂ_½u¨ú¥N(ch->desc == NULL)¡A¤G¬O¨SÂ_½uµw¨ú¥N(ch->desc != NULL)
comm.c:  ¦pªG¬Oµw¨ú¥N¡A¨S¦³¤U°¨¡A¦ý§Ú­Ì¥i¥H check ch->pcdata->ride == 2 ±oª¾¥¿¦bÃM°¨¡C
comm.c:    if ( IS_SET( ch->pcdata->ride, 2 ) )
comm.c:      do_ride( ch->pcdata->horse, "" );//±j­¢¤U°¨¡AÅý¨Æ±¡³æ¯Â¤Æ¡C
comm.c:    if ( ch->pcdata->switched )//²{¦b¦³µw¨ú¥N¡A¥²¶· check imm switch ªº±¡ªp
comm.c:      for( och = char_list; och; och = och->next )
comm.c:        if ( och->desc && och->desc->original == ch )
comm.c:    if ( ch->desc )
comm.c:      close_socket2( ch->desc );
comm.c:    free_char( d->character );
comm.c:    d->character = ch;
comm.c:    ch->desc     = d;
comm.c:    ch->timer    = 0;
comm.c:    sprintf( log_buf, "%s, $U@$H reconnected.", ch->name );
comm.c:    d->connected = CON_PLAYING;
comm.c:    for ( dold = descriptor_list; dold; dold = dold->next )
comm.c:      && dold->character
comm.c:      && dold->connected != CON_GET_NAME
comm.c:      //&& dold->connected != CON_GET_OLD_PASSWORD
comm.c:      && !str_cmp( name, dold->original
comm.c:      ? dold->original->name : dold->character->name )
comm.c:      && !dold->character->deleted )
comm.c:      d->connected = CON_GET_NAME;
comm.c:      if ( d->character )
comm.c:    free_char( d->character );
comm.c:    d->character = NULL;
comm.c:  || !ch->desc
comm.c:  ||  ch->desc->connected != CON_PLAYING
comm.c:  || !ch->was_in_room
comm.c:  ||  ch->in_room != get_room_index( ROOM_VNUM_LIMBO ) )
comm.c:    ch->timer = 0;
comm.c:    char_to_room( ch, ch->was_in_room );
comm.c:    ch->was_in_room    = NULL;
comm.c:    for ( d = descriptor_list; d; d = d->next )
comm.c:  if ( d->character != NULL )
comm.c:      if ( d->character->in_room == room )
comm.c:    act( txt, d->character, NULL, NULL, TO_CHAR );
comm.c:    for ( d = descriptor_list; d; d = d->next )
comm.c:  if ( d->connected == CON_PLAYING )
comm.c:      send_to_char( text, d->character );
comm.c:    if ( !txt || !ch ||!ch->desc )
comm.c:    if ( ch->desc->showstr_point )
comm.c:        int diff = (int)( ch->desc->showstr_point - ch->desc->showstr_head);
comm.c:        strcpy( buf, ch->desc->showstr_head );
comm.c:        strncat( buf, txt, 50000 - len );
comm.c:        free_string( ch->desc->showstr_head );
comm.c:        ch->desc->showstr_head = str_dup( buf );
comm.c:        ch->desc->showstr_point = ch->desc->showstr_head + diff;
comm.c:        write_to_buffer( ch->desc, txt, strlen( txt ) );
comm.c:        free_string( ch->desc->showstr_head );
comm.c:        ch->desc->showstr_head  = str_dup( txt );
comm.c:        ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:        show_string( ch->desc, "" );
comm.c: /* The heart of the pager.  Thanks to N'Atas-Ha, ThePrincedom
comm.c:    the improvements to the pager was modeled from.  - Kahn */
comm.c:    of EnvyMud Staff - Kahn */
comm.c:  if ( d->showstr_head )
comm.c:      free_string( d->showstr_head );
comm.c:      d->showstr_head = str_dup( "" );
comm.c:  d->showstr_point = 0;
comm.c:    if ( d->original )
comm.c:  pagelines = d->original->pcdata->pagelen;
comm.c:  pagelines = d->character->pcdata->pagelen;
comm.c:  if ( d->showstr_point == d->showstr_head )
comm.c:      line = -1;
comm.c:      if ( *d->showstr_point == '\n' )
comm.c:      d->showstr_point--;
comm.c:  } while( d->showstr_point != d->showstr_head );
comm.c:    if ( *d->showstr_point )
comm.c:      *scan = *d->showstr_point;
comm.c:      d->showstr_point++;
comm.c:      if( *d->showstr_point == 0 )
comm.c:    if ( *d->showstr_point == 0 )
comm.c:      free_string( d->showstr_head );
comm.c:      d->showstr_head  = str_dup( "" );
comm.c:      d->showstr_point = 0;
comm.c:/* - The heart of the pager.  Thanks to N'Atas-Ha, ThePrincedom for porting  */
comm.c:/* - Thanks to Blackstar, hopper.cs.uiowa.edu 4000 for which the improvements*/
comm.c:/*   to the pager was modeled from.  - Kahn            */
comm.c:/* - Safer, allows very large pagelen now, and allows to page while switched */
comm.c:    /* ------------------- */
comm.c:    pagelen = d->original ? d->original->pcdata->pagelen
comm.c:        : d->character->pcdata->pagelen;
comm.c:    /* ----------------------------- */
comm.c:  case 'B': lines = -2 * pagelen;
comm.c:  case 'H': write_to_buffer( d, "B     - Scroll back one page.\n\r", 0 );
comm.c:      write_to_buffer( d, "C     - Continue scrolling.\n\r", 0 );
comm.c:      write_to_buffer( d, "H     - This help menu.\n\r", 0 );
comm.c:      write_to_buffer( d, "R     - Refresh the current page.\n\r",
comm.c:      write_to_buffer( d, "Enter - Continue Scrolling.\n\r", 0 );
comm.c:  case 'R': lines = -1 - pagelen;
comm.c:  default:  free_string( d->showstr_head );
comm.c:      d->showstr_head  = NULL;
comm.c:      d->showstr_point = NULL;
comm.c:    /* ------------------------------------------------------ */
comm.c:  for( start= d->showstr_point; start > d->showstr_head && lines < 0;
comm.c:       start-- )
comm.c:  start = d->showstr_point;
comm.c:    /* ---------------------------------------------- */
comm.c:    d->showstr_point = end;
comm.c:    if ( end - start )
comm.c:  write_to_buffer( d, start, end - start );
comm.c:    /* ------------------------------------------------------ */
comm.c:  free_string( d->showstr_head );
comm.c:  d->showstr_head  = NULL;
comm.c:  d->showstr_point = NULL;
comm.c:     * Discard null and zero-length messages.
comm.c:    if( ch->deleted ) {
comm.c:    if( ! ch->in_room ) {
comm.c:        bug(" Act: no ch->in_room !",0);
comm.c:    to = ch->in_room->people;
comm.c:        if ( !vch->in_room )//amenda 6/2/01 for debug purpose
comm.c:            bug( vch->name, 0 );
comm.c:        to = vch->in_room->people;
comm.c:    for ( ; to; to = to->next_in_room )
comm.c:        if ( ( to->deleted )
comm.c:            || ( !to->desc && IS_NPC( to ) && !(to->pIndexData->progtypes & ACT_PROG ))
comm.c:        else if ( type == TO_ROOM && !IS_NPC(to) && to->position == POS_FIGHTING && !IS_SET( to->act, PLR_COMBAT))
comm.c:        else if ( type == TO_NOTVICT && !IS_NPC(to) && to->position == POS_FIGHTING && !IS_SET( to->act, PLR_COMBAT))
comm.c:                case 'e': i = he_she  [URANGE( 0, ch  ->sex, 2 )];    break;
comm.c:                case 'E': i = he_she  [URANGE( 0, vch ->sex, 2 )];    break;
comm.c:                case 'm': i = him_her [URANGE( 0, ch  ->sex, 2 )];    break;
comm.c:                case 'M': i = him_her [URANGE( 0, vch ->sex, 2 )];    break;
comm.c:                case 's': i = his_her [URANGE( 0, ch  ->sex, 2 )];    break;
comm.c:                case 'S': i = his_her [URANGE( 0, vch ->sex, 2 )];    break;
comm.c:                      ? ( strcpy(name_buf, obj1->short_descr) )
comm.c:                      ? ( strcpy(name_buf, obj2->short_descr) )
comm.c:        *point = '\0';  //Bug-Fix from ED
comm.c:        if ( to->desc )
comm.c:     * Discard null and zero-length messages.
comm.c:    if( ch->deleted ) {
comm.c:    if( ! ch->in_room ) {
comm.c:        bug(" Combat_info: no ch->in_room !",0);
comm.c:    to = ch->in_room->people;
comm.c:        if ( !vch->in_room )//amenda 6/2/01 for debug purpose
comm.c:            bug( vch->name, 0 );
comm.c:        to = vch->in_room->people;
comm.c:        for(;to;to = to->next_in_room ){
comm.c:            if ( ( to->deleted ) || ( !to->desc && IS_NPC( to ) &&
comm.c:                !(to->pIndexData->progtypes & ACT_PROG )) || !IS_AWAKE( to ) )
comm.c:            if(to != ch && (IS_NPC(to) || IS_SET(to->act, PLR_COMBAT)))
comm.c:        for(;to;to = to->next_in_room ){
comm.c:            if ( ( to->deleted ) || ( !to->desc && IS_NPC( to ) &&
comm.c:                !(to->pIndexData->progtypes & ACT_PROG )) || !IS_AWAKE( to ) )
comm.c:            if(to != ch && to != vch && (IS_NPC(to) || IS_SET(to->act, PLR_COMBAT)))
comm.c:    if( ch->deleted ) 
comm.c:	if( ch->position == POS_MORTAL )
comm.c:           //case 'e': i = he_she  [URANGE( 0, ch  ->sex, 2 )];   break;
comm.c:           //case 'E': i = he_she  [URANGE( 0, vch ->sex, 2 )];   break;
comm.c:           case 'm': i = him_her [URANGE( 0, ch  ->sex, 2 )];   break;
comm.c:           case 'M': i = him_her [URANGE( 0, vch ->sex, 2 )];   break;
comm.c:           //case 's': i = his_her [URANGE( 0, ch  ->sex, 2 )];   break;
comm.c:           //case 'S': i = his_her [URANGE( 0, vch ->sex, 2 )];   break;
comm.c:  *point = '\0';  //Bug-Fix from ED
comm.c:  if( to->desc )
comm.c:    tp->tv_sec  = time( NULL );
comm.c:    tp->tv_usec = 0;
comm.c:    tp->tv_sec  = time( NULL );
comm.c:    tp->tv_usec = 0;
comm.c:*//* timeout - handle timeouts *//*
comm.c:*//* rfc931_name - return remote user name *//*
comm.c:    if ( getsockname( desc, (struct sockaddr *) & here, &length ) == -1)
comm.c:    if ( ( s = socket( AF_INET, SOCK_STREAM, 0 ) ) == -1 )
comm.c:    if (connect(s, (struct sockaddr *) &sin, sizeof(sin) ) == -1
comm.c:    *//* Query the RFC 931 server. Would 13-byte writes ever be broken up? *//*
comm.c:    fprintf( fp, "%u,%u\r\n", ntohs(there->sin_port), ntohs(here.sin_port) );
comm.c:  && ntohs(there->sin_port) == remote
const.c://*---------------------------------------------------------------*
const.c://*---------------------------------------------------------------*
const.c://*---------------------------------------------------------------*
const.c://*---------------------------------------------------------------*
const.c://*---------------------------------------------------------------*
const.c:	3018,  85,  8,	 -1,   6,  8, TRUE, { L_APP, L_APP, L_APP, L_APP, L_APP}
const.c:	3003,  80,  8,	 -8,  6, 10, TRUE, { L_APP, L_APP, L_APP, L_APP, L_APP}
const.c:	3028,  75,  8,	 -10,  8, 13, FALSE, { L_APP, L_APP, L_APP, L_APP, L_APP}
const.c:	3022,  75,  8,	 -12,  11, 15, FALSE, { L_APP, L_APP, L_APP, L_APP, L_APP}
const.c:	3221,  70,  8,	 -12,  11, 20, FALSE, { L_APP, L_APP, L_APP, L_APP, L_APP}
const.c:	3018,  99,  2,	 -4,   6,  9, TRUE, { 20, L_APP, L_APP, 36, L_APP}
const.c:	3018,  99,  0,	 -16,   8,  12, TRUE, { 20, L_APP, L_APP, 34, 36}
const.c:	3003,  99,  8,	 -1,  7, 10, TRUE, { L_APP, 20, L_APP, L_APP, L_APP}
const.c:	3003,  99,  5,	 -12,  8, 13, TRUE, { 35, 20, L_APP, L_APP, L_APP}
const.c:	3028,  90,  0,	 -20,  11, 15, FALSE, { L_APP, L_APP, 20, 34, 36}
const.c:	3028,  95,  2,	 -18,  9, 13, TRUE, { L_APP, L_APP, 20, 34, 35}
const.c:	3022,  90,  0,	 -22,   13,  18, FALSE, { 35, 35, 35, 20, 34}
const.c:	3022,  95,  0,	 -22,  11, 15, TRUE, { 36, L_APP, 34, 20, 34}
const.c:	3022,  95,  -2,	 -24,  11, 15, TRUE, { L_APP, 30, L_APP, 20, 30}
const.c:	3221,  90,  2,	 -17,   15,  20, TRUE, { 30, 25, L_APP, L_APP, 20}
const.c:	3018,  99,  5,	 -12,  6, 10, TRUE, { 20, 34, L_APP, L_APP, L_APP}
const.c:	3003,  95,  0,	 -18,   11,  15, TRUE, { L_APP, 20, L_APP, 30, 34}
const.c:	3028,  95,  0,	 -23,  8, 12, TRUE, { 35, 33, 20, 30, 35}
const.c:	3221,  85,  -2,	 -14,  10, 20, FALSE, { L_APP, L_APP, 35, 30, 20}
const.c:	3221,  80,  0,	 -17,   16,  24, FALSE, { L_APP, L_APP, 36, 30, 20}
const.c:	{ "Pick-Pocket",		"Pick-Pocket"			},
const.c:	{ "Cut-Purse",			"Cut-Purse"			},
const.c:	{ "Quick-Blade",		"Quick-Blade"			},
const.c:	{ "Cut-Throat",			"Cut-Throat"			},
const.c:	{ "Pick-Pocket",		"Pick-Pocket"			},
const.c:	{ "Cut-Purse",			"Cut-Purse"			},
const.c:	{ "Quick-Blade",		"Quick-Blade"			},
const.c:	{ "Cut-Throat",			"Cut-Throat"			},
const.c:	{ "Pick-Pocket",		"Pick-Pocket"			},
const.c:	{ "Cut-Purse",			"Cut-Purse"			},
const.c:	{ "Quick-Blade",		"Quick-Blade"			},
const.c:	{ "Cut-Throat",			"Cut-Throat"			},
const.c:	{ "Pick-Pocket",		"Pick-Pocket"			},
const.c:	{ "Cut-Purse",			"Cut-Purse"			},
const.c:	{ "Quick-Blade",		"Quick-Blade"			},
const.c:	{ "Cut-Throat",			"Cut-Throat"			},
const.c:      {   0, -2, -2, -2, -2, -2, -2, -2, -2},   0, 0, "ªÅ¤â¤@À»",
const.c:       SIZE_3,/* Five ATR */ -2, 2, 0, 2,-2, /*HP MP MV Gain*/ 0, 2, 1, /* Drink Eat */ -1, 0,
const.c:      {  -6,  0,  0,  0,  0,  0, -1, -4,  4}, -20, 60, "ªÅ¤â¤@À»",
const.c:      "Demon Drow Ogre Orc Kobold Troll Hobgoblin Dragon Vampire Werewolf Goblin Half-kobold", 50, 80 },
const.c:       SIZE_2,/* Five ATR */  2,-3,-1,-2, 4, /*HP MP MV Gain*/ 2, 0, 0, /* Drink Eat */  0, 1,
const.c:      { -12, -8, -8, -8, -8, -8,  3, -1, -1},  30,-120, "ªÅ¤â¤@À»",
const.c:      "Giant Ogre Orc Kobold Minotaur Troll Hobgoblin Dragon Vampire Werewolf Goblin Half-kobold", 100, 200 },
const.c:       SIZE_4,/* Five ATR */  4,-3,-3, 0, 2, /*HP MP MV Gain*/ 2, 0, 0, /* Drink Eat */  2, 3,
const.c:      {   4,  0, -4, -6,  0, -2, -2,  2, -2},   0,-60, "ªÅ¤â¤@À»",
const.c:       SIZE_2,/* Five ATR */ -2,-2, 2, 4,-2, /*HP MP MV Gain*/ 0, 0, 4, /* Drink Eat */  0, 0,
const.c:      {   0,  0,  0, -1,  1,  0,  0, -5, -5}, -55, 60, "ªÅ¤â¤@À»",
const.c:      "Giant Ogre Orc Kobold Minotaur Troll Hobgoblin Dragon Vampire Werewolf Goblin Half-kobold", 50, 50 },
const.c:       SIZE_2,/* Five ATR */ -4, 4, 2, 2,-4, /*HP MP MV Gain*/ 0, 4, 0, /* Drink Eat */  0,-1,
const.c:      {  -8,  5,  5,  5,  5,  4, -3,  0,  0}, -60, 120, "ªÅ¤â¤@À»",
const.c:      "Kobold Minotaur Angel Goblin Dwarf HalfDwarf Half-elf Half-kobold Beholder", 50, 50 },
const.c:       SIZE_2,/* Five ATR */ -2, 2, 4,-4, 0, /*HP MP MV Gain*/ 0, 1, 0, /* Drink Eat */  0, 1,
const.c:      {  -4, -3,  0,  0, -3, -2, -2, -5,  5},  80, 0, "ªÅ¤â¤@À»",
const.c:       SIZE_3,/* Five ATR */ -3, 3, 2, 1,-3, /*HP MP MV Gain*/ 0, 3, 0, /* Drink Eat */ -1, 0,
const.c:      {  -7,  0,  0,  0,  0,  2, -2,  3, -3}, -30, 100, "ªÅ¤â¤@À»",
const.c:       SIZE_3,/* Five ATR */ -1, 0,-1, 2,-2, /*HP MP MV Gain*/ 0, 0, 2, /* Drink Eat */  4,-1,
const.c:      {  -2,  8, -4, -3,  2,  1,  2,  5, -5}, -30, 0, "¨Ï«l¤@§ì",
const.c:      "Human Elf Half-elf Drow Dwarf Half-dwarf Hobbit Giant Ogre Orc Kobold Minotaur Troll Hobgoblin Werewolf Goblin Angel Gnome Lizardman", 30, 200 },
const.c:       SIZE_1,/* Five ATR */ -5, 6, 4, 0,-5, /*HP MP MV Gain*/ 0, 3, 1, /* Drink Eat */ 1, 1,
const.c:      {  -6,  4,  3,  7,  5,  5,  1,  0, -5}, -40, 80, "»´»´¤@Ä²", 
const.c:       SIZE_4,/* Five ATR */  3,-5,-4, 1, 3, /*HP MP MV Gain*/ 0, 0, 0, /* Drink Eat */ 3, 3,
const.c:      {   6,  2, -5, -2, -2,-11,  0,  0,  0}, -40,-130, "ªÅ¤â¤@À»", 
const.c:      SIZE_4, 3,-5,-5, 3, 4, 0, 0, 0, 2, 3, {8,2,2,2,2,1,0,0,0},-20,-60, "¥[³t½Ä¼²", "Kobold Half-kobold Ghost", 0, 0 },
const.c:      SIZE_8, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0,  {-10,-8,-8,-8,-8,-8,-8,-10,-10},-10, -40, "¹p¾^¤@À»", "", 0, 0 },
const.c:        SIZE_5, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0,  {-9,-4,-4,-4,-4,-4,-6,10,-10}, -5, -115, "ªÅ¤â¤@À»",
const.c:      SIZE_4, 2, 2, 2, 2, 2 ,0, 0, 0, 0, 0,  {-8,-4,-4,-4,-4,-4,-6,-8,8},-30, -60, "ªÅ¤â¤@À»", "Demon", 0, 0 },
const.c:      SIZE_9, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0,  {-9,-7,-7,-7,-7,-10,-3,0,0},  -10, -70, "¨Ï«l¤@§ì", "", 50 ,300 },
const.c:    { "Half-elf",   "¥bºëÆF", RACE_INFRAVISION | RACE_WEAPON_WIELD,
const.c:      SIZE_3,-1, 1, 0, 1,-1, 0, 0, 0, 0, 0,  {-1,0,0,0,0,0,-1,-3,1},-10, 40, "ªÅ¤â¤@À»",
const.c:    { "Half-dwarf", "¥b¸G¤H", RACE_WEAPON_WIELD,
const.c:          SIZE_3, 1,-1, 0,-1, 1, 0, 0, 0, 0, 0,  {-3,-2,1,1,-2,-1,1,-1,-1}, 10, -80, "ªÅ¤â¤@À»",
const.c:    { "Half-kobold", "¥b¦aÆF", RACE_DETECT_ALIGN | RACE_WEAPON_WIELD,
const.c:      SIZE_2,-1, 1, 2,-2, 0, 0, 0, 0, 0, 0, {4,2,-1,2,-1,1,-2,-1,-1}, 10,110, "ªÅ¤â¤@À»", 
const.c:      SIZE_5, 4,-2,-2,-3, 3, 0, 0, 0, 2, 4,  {8,3,3,3,3,1,4,0,0}, 30,-20, "­«­«¤@®±",
const.c:      "Demon Elf Half-elf Dwarf Half-dwarf Hobbit Vampire Werewolf Gnome", 50, 200 },
const.c:      SIZE_5, 4,-3,-2,-1, 2, 0, 0, 0, 0, 2,  {4,1,-4,1,1,0,1,0,-2}, 15, -10, "­«­«¤@®±",
const.c:      "Elf Half-elf Dwarf Half-dwarf Hobbit Vampire Werewolf Gnome", 50, 150 },
const.c:      SIZE_2,-1,-1, 0, 1, 1, 0, 0, 0, 0, 0, {8,4-2,4,-2,2,-1,3,-3},  0,130, "ªÅ¤â¤@À»",
const.c:      "Elf Imp Half-elf Dwarf Half-dwarf Hobbit Vampire Werewolf Gnome Half-kobold", 80, 80 },
const.c:      SIZE_4, 2, 0, 0,-1, 1, 0, 0, 0, 0, 3,  {4,-4,4,4,-4,-2,0,3,-3},  -10, -30, "­«­«¤@®±",
const.c:      "Elf Imp Half-elf Dwarf Half-dwarf Hobbit Vampire Werewolf Gnome", 30, 120 },
const.c:      SIZE_6, 3,-1,-1,-2, 1, 0, 0, 0, 0, 8,  {-2,0,-2,-2,0,0,0,0,0}, -5,100, "­«­«¤@®±",
const.c:      "Human Elf Half-elf Dwarf Half-dwarf Hobbit Vampire Werewolf Gnome", 30, 150 },
const.c:      SIZE_3, 1, 0,-1, 0, 0, 0, 0, 0, 0, 0, {6,5,5,5,5,3,-2,0,0},-10, 90, "ªÅ¤â¤@À»",
const.c:      "Elf Half-elf Dwarf Half-dwarf Hobbit Vampire Werewolf Gnome", 50, 50 },
const.c:      SIZE_0,-4,-4,-4, 0,-4, 0, 0, 0, 0, 0, {12,8,8,8,8,5,-2,0,0},-60, 80, "¥Î¤O¤@«r", "", 0, 0 },
const.c:      SIZE_2, 1,-3,-1, 1, 1, 0, 0, 0, 0, 0, {8,3,3,3,3,2,1,0,0},-20, 80, "¥Î¤O¤@«r", "Kobold Half-kobold Ghost", 0, 0 },
const.c:      SIZE_3, 0, 0, 0, 1,-1, 0, 0, 0,-1,-1,  {0,10,-10,0,-10,8,0,8,-8},15, 75, "»´»´¤@Ä²",
const.c:      "Human Elf Half-elf Drow Dwarf Half-dwarf Hobbit Giant Ogre Orc Kobold Minotaur Troll Hobgoblin Goblin Angel Gnome Animal", 0, 200 },
const.c:      SIZE_3, 0,-1,-1, 2, 0, 0, 0, 0, 0, 0,  {-3,5,5,5,5,2,-2,3,-3}, -5, 85, "¨Ï«l¤@§ì",
const.c:      "Human Imp Elf Half-elf Dwarf Half-dwarf Hobbit Gnome", 30, 30 },
const.c:      SIZE_3, 1, 0, 0,-1, 1, 0, 0, 0, 0, 3,  {4,2,2,2,2,1,0,0,0},  0, 35, "ºµ´x¤@§ì", "", 0, 0 },
const.c:          SIZE_3, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0,  {-6,6,-6,-6,6,2,-10,5,-5}, -5, 75, "ªÅ¤â¤@À»", "Mindflayer", 50, 150 },
const.c:      SIZE_4, 1, 0, 0, 0, 1, 0, 0, 0,-2,-2,  {0,-12,-12,-12,-12,0,-10,0,0},-30, 40, "ªÅ¤â¤@À»", "", 0, 0 },
const.c:      SIZE_0,/* Five ATR */ -2, 0, -1, 4,-3, /*HP MP MV */ 0, 0, 4, /* Drink Eat */0, 0, 
const.c:      {   4,  6,  6,  6,  6,  2,  0,  0,  0},-50,120, "¥Î¤O¤@«r", "", 0, 0 },
const.c:      SIZE_2, 0, 0, 0,-2, 1, 0, 0, 0,-1,-1,  {-10,20,10,-10,-20,10,4,0,0}, 100,150, "²ô¸­¤@´§", "", 0, 0 },
const.c:      SIZE_0,-1, 0, 0, 2,-1, 0, 0, 0, 0, 0, {6,5,5,5,5,3,0,0,-2},-20, 95, "¥Î¤O¤@«r", "", 0, 0 },
const.c:       SIZE_3,/* Five ATR */  2,-3,-1, 2, 3, /* HP MP MV */ 1, 0, 0, /* Drink Eat */  0, 5,
const.c:      {  -4,  6, -2, -2, -2,  4,  1,  0, -2}, -15, -30, "¨Ï«l¤@§ì",
const.c:      "Human Elf Half-elf Drow Dwarf Half-dwarf Hobbit Giant Ogre Orc Kobold Minotaur Troll Hobgoblin Goblin Angel Gnome", 100, 100},
const.c:      SIZE_2,-1,-1,-1, 1, 0, 0, 0, 0, 0, 0, {6,5,5,5,5,3,-1,0,0}, -5,100, "ªÅ¤â¤@À»",
const.c:      "Elf Half-elf Dwarf Half-dwarf Hobbit Vampire Werewolf Gnome", 50, 50 },
const.c:      SIZE_2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, {0,5,0,0,0,2,-2,1,-1},-20,100, "¥Î¤O¤@«r", "", 0, 0 },
const.c:    { "Mind-flayer","¹Ü¤ßÅ]", RACE_INFRAVISION | RACE_WEAPON_WIELD,
const.c:       SIZE_3, 1, 2, 1,-1, 0, 0, 6, 0, 0, 0, {-6,-6,6,6,-6,2,-3,3,-3},-30, 90, "ªÅ¤â¤@À»", "Githyanki", 100, 100 },
const.c:      SIZE_2, 3, 0, 0, 0, 3, 0, 0, 0,-2,-2, {-20,10,10,10,10,10,3,0,0} ,100,170, "¥Î¤O¤@¼²", "", 0, 0 },
const.c:      SIZE_0, 0, 0, 0, 3, 0, 0, 0, 0,-2,-2,  {-5,-5,-5,10,-5,-5,-3,0,0},-50, 140, "Ãú®ð¤@¼Q", "", 0, 0 },
const.c:      SIZE_2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,  {0,3,3,3,3,2,0,0,0},-10, 80, "¥Î¤O¤@«r", "", 0, 0 },
const.c:      SIZE_2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {6,3,3,-10,-10,5,-1,0,0},  5,115, "¥Î¤O¤@«r", "", 0, 0 },
const.c:      SIZE_1, 0, 0, 0, 2, 0, 0, 0, 0,-2, 0,  {6,10,10,-10,-10,0,8,0,0},-10, 80, "¥Î¤O¤@±½", "", 0, 0 },
const.c:      SIZE_8, 2, 0, 0,-1, 2, 0, 0, 0, 0, 0,  {-5,-4,-4,-4,-4,-4,4,0,0}, -10, 90, "¥Î¤O¤@«r", "", 50, 200 },
const.c:      SIZE_1,-1, 0, 0, 1, 0, 0, 0, 0, 0, 0, {12,-3,-3,-3,-3,-1,0,0,0},-15, 85, "§À¤Ú¤@±½", "", 0, 0 },
const.c:      SIZE_1,-5, 4, 2, 3,-4, 0, 0, 0, 0,-1, {-4,2,2,2,2,1,-3,0,0},-45, 65, "ªÅ¤â¤@À»",
const.c:      "Ogre Kobold Minotaur Goblin Hobgoblin Dwarf HalfDwarf Half-elf Half-kobold Beholder", 30, 30 },
const.c:      SIZE_4, 1, 0, 0, 0, 1, 0, 0, 0,-2,-2,  {5,-8,-8,-8,-8,-8,0,0,0},-20, 50, "ªÅ¤â¤@À»", "", 30, 30 },
const.c:      SIZE_0, 0, 0, 0, 3, 0, 0, 0, 0,-2,-2,  {-8,0,3,6,-10,-5,0,0,0},-50, 40, "Ãú®ð¤@¼Q", "", 0, 0 },
const.c:        SIZE_5, 1, 0, 0,-5, 4, 0, 0, 0,-2,-2,  {-10, 0, 0,-10,10,10,-10,0,0}, 50, 0, "²r¯P¤@¼²", "", 0, 0 },
const.c:        SIZE_5, 0, 0, 0, 0, 0, 0, 0, 0,-2,-2,  {-10,5,5,5,5,5,5,0,0}, 10, 70, "²r¯P¤@¼²", "", 0, 0 },
const.c:      SIZE_0,-1, 0, 0, 2,-1, 0, 0, 0,-1,-1, {-5,3,3,3,3,2,0,8,-8},-30, 70, "»´»´¤@Ä²",
const.c:      SIZE_2, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0,  {0,0,0,0,0,0,1,-5,-5},-10, 80, "ªÅ¤â¤@À»", "", 100, 100 },
const.c:      SIZE_5, 2,-3,-1, 2, 2, 0, 0, 0, 0, 0, {8,3,3,3,3,2,0,0,0},-20,  0, "§Q¤ö¶Ã§S", "Kobold Half-kobold Ghost", 0, 0 },
const.c:      SIZE_4, 0, 0, 0, 4, 2, 0, 0, 0, 0, 0, {-5,-2,2,-2,-2,0,0,0,0},-80,  0, "ÅK¿á¤@ÃÞ", "Kobold Ghost Vampire Orc Troll Goblin", 50, 50 },
const.c:      SIZE_9, 3, -2, -2, 0, 3, 0, 0, 0, 0, 0,  {2,-3,-3,-3,-3,-10,0,0,0},  50, -100, "¨Ï«l¤@§ì", "", 0, 0 },
const.c:      SIZE_5, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0,  {0,-2,-2,-2,-2,-4,-4,0,0},  0, 20, "¨Ï«l¤@§ì", "", 50, 50 },
const.c:      SIZE_8, 4, 1, 1, 0, 3, 0, 0, 0, 0, 0,  {0,-5,-5,-5,-5,-7,0,0,0},  20, -20, "¥¨§À¤@±½", "", 50, 200 },
const.c:      SIZE_6, 1, 0, 0, 3, 0, 0, 0, 0, 0, 0,  {-2,-2,-2,-2,-2,-4,4,0,0}, -10, 50, "¨Ï«l¤@§ì", "", 50, 150 },
const.c:      SIZE_3, 0,-1,-1, 2, 0, 0, 0, 0, 0, 0,  {-3,5,5,5,5,-2,0,0}, -5, 85, "¨Ï«l¤@°Ö","", 30, 30 },
const.c:      SIZE_2,-4, 4, 2, 2,-4, 0, 4, 0, 0,-1, {-8,5,5,5,5,4,-1,3,-3},-60, 120, "ªÅ¤â¤@À»",
const.c:      "Kobold Minotaur Angel Goblin Dwarf HalfDwarf Half-elf Half-kobold Beholder", 50, 50 },
const.c:        SIZE_3, 0, 1, 0, 1, 0, 0, 0, 0, -1, 0, {1, 5, -5, 5, -5, -5, 3,0,0}, -20, 0, "ªÅ¤â¤@À»",
const.c:        "Vampire Lizardman Drow Dinosaur Kuo-toa", 50, 50 },
const.c:    { "Kuo-toa", "±FÀÜ³½¤H", RACE_WEAPON_WIELD | RACE_WATERBREATH | RACE_INFRAVISION,
const.c:        SIZE_4, 2, -1, -1, 0, 1, 0, 0, 0, -1, 0, {1, 5, -5, 5, -5, -5, 3,0,0}, 0, -20, "ªÅ¤â¤@À»",
const.c:        SIZE_3, 12, -12, -12, -12, -12, 0, 0, 0, 0, 0, {20,20,20,20,20,20,20,20,20},500,500, "ÀH¦a¦R·ð",
const.c:       SIZE_3,/* Five ATR */  2,-1, 0,-1,-2, /*HP MP MV Gain*/ 1, 0, 0, /* Drink Eat */ -1, 1,
const.c:      {   0,  8, -2,  3, -3,  2,  0,  5, -5}, 0, 20, "¨Ï«l¤@§ì",
const.c:      "Human Elf Half-elf Drow Dwarf Half-dwarf Hobbit Giant Ogre Orc Minotaur Hobgoblin Goblin Angel Gnome", 30, 200 },
const.c:       SIZE_3,/* Five ATR */  -3, 0, 1, 3, -3, /*HP MP MV Gain*/ 1, 0, 0, /* Drink Eat */ -1, 1,
const.c:      {  -2,  5, -5,  8, -3, -5,  2,  5, -5}, -30, 0, "¨Ï«l¤@§ì",
const.c:      "Human Elf Half-elf Drow Dwarf Half-dwarf Hobbit Giant Ogre Orc Minotaur Hobgoblin Goblin Angel Gnome", 30, 200 }
const.c:    { -60, -5,	0,  0,0,0 },  /* 0	*/
const.c:    { -50, -5,	3,  1,0,1 },  /* 1	*/
const.c:    { -40, -4,	3,  2,1,2 },
const.c:    { -30, -3,  10,  3,1,3 },  /* 3	*/
const.c:    { -25, -2,  25,  4,2,4 },
const.c:    { -20, -1,  55,  5,2,6 },  /* 5	*/
const.c:    { -15, -1,  80,  6,3,8 },
const.c:    { -10,  0, 100,  7,4,10 },
const.c:    { 0,-12 },	/*  0 */
const.c:    { 0,-11 },	/*  1 */
const.c:    { 0 ,-10},
const.c:    { 0,-9 },	/*  3 */
const.c:    { 0,-8 },
const.c:    { 1,-7 },	/*  5 */
const.c:    { 1 ,-6},
const.c:    { 1 ,-5},
const.c:    { 1 ,-4},
const.c:    { 2 ,-3},
const.c:    { 2 ,-2},	/* 10 */
const.c:    { 3 ,-1},
const.c:    {	50 ,-12},	/* 0 */
const.c:    {	40 ,-11},	/* 1 */
const.c:    {	30 ,-10},
const.c:    {	20 ,-9},
const.c:    {	10 ,-8},
const.c:    {	0 ,-7},	/* 5 */
const.c:    {	-10 ,-6},
const.c:    {	-20 ,-5},
const.c:    {	-30 ,-4},
const.c:    {	-40 ,-3},
const.c:    {	-50 ,-2},	/* 10 */
const.c:    {	-70 ,-1},
const.c:    {	-90 ,0},
const.c:    {	-110 ,1},
const.c:    {	-130 ,2},
const.c:    { - 150 ,3},	/* 15 */
const.c:    { - 170 ,4},
const.c:    { - 195 ,5},
const.c:    { - 220 ,6},
const.c:    { - 245 ,7},
const.c:    { - 270 ,8},	/* 20 */
const.c:    { - 295 ,9},
const.c:    { - 320 ,10},
const.c:    { - 350 ,11},
const.c:    { - 380 ,13},
const.c:    { - 410 ,15},	/* 25 */
const.c:    { - 450 ,110},
const.c:    { - 490 ,120},
const.c:    { - 530 ,130},
const.c:    { - 570 ,140},
const.c:    { - 610 ,150}	/* 30 */
const.c:    {  -4, 20,   25 },    /* Con  0 */
const.c:    {  -3, 25,   20 },
const.c:    {  -3, 30,   15 },    
const.c:    {  -3, 35,   10 },    // Increased by 10
const.c:    {  -2, 40,    0 },
const.c:    {  -2, 45,  -10 },    /* Con  5 */
const.c:    {  -1, 50,  -20 },
const.c:    {  -1, 55,  -30 },
const.c:    {   0, 60,  -40 },    // Increased by 15
const.c:    {   0, 65,  -55 },
const.c:    {   0, 70,  -70 },	  /* Con 10 */
const.c:    {   0, 75,  -85 },
const.c:    {   1, 80, -100 },
const.c:    {   2, 85, -115 },    // Increased by 20
const.c:    {   3, 88, -135 },
const.c:    {   4, 90, -155 },    /* Con 15 */
const.c:    {   5, 95, -175 },
const.c:    {   6, 97, -195 },
const.c:    {   7, 99, -215 },    // Increased by 25
const.c:    {   8, 99, -240 },
const.c:    {   9, 99, -265 },    /* Con 20 */
const.c:    {  10, 99, -290 },
const.c:    {  11, 99, -315 },
const.c:    {  12, 99, -340 },    // Increased by 30
const.c:    {  13, 99, -370 },
const.c:    {  14, 99, -400 },    /* Con 25 */
const.c:    {  15, 99, -430 },
const.c:    {  16, 99, -460 },
const.c:    {  17, 99, -490 },    // Increased by 40
const.c:    {  18, 99, -530 },
const.c:    {  19, 99, -570 }
const.c:    { "slime mold juice",	"green",	{  0, 4, -8 }	},
const.c:    { "blood",			"red",		{  0, 2, -1 }	},
const.c:    { "salt water",		"clear",	{  0, 1, -2 }	},
const.c:    { "¶Â³Á°s",	"dark-ale",	"·t´Ä¦âªº",		{  1, 2,  5 }	},
const.c:    { "«C¯ó¥Ä","slime mold juice",	"ºñ¦âªº",	{  0, 4, -8 }	},
const.c:    { "¦å",	"blood",		"ÂA¬õ¦âªº",		{  0, 2, -1 }	},
const.c:    { "ÆQ¤ô",	"salt water",	"³z©úµL¦âªº",	{  0, 1, -2 }	},
const.c:    { "¥iº¸¥²´µ",	"calpis",	"¨Å¥Õ¦âªº",	{  0, -1, 4 }	}, /* 20 */
const.c:            "pained lungs",  "§A¤£¯à¦b¤ô¤¤©I§l¤F.", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Create Water!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Cure Blindness!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Cure Poison!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!destroy cursed!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Detect Poison!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Know Alignment!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "ºØ±Ú²§ÅÜ³N",   "§Aªº¨­Åé¤SÅÜ¦^­ì¼Ë¤F." , ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Remove Alignment!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Remove Curse!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Remove Silence!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Sober!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Teleport!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Ventriloquate!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Word of Recall!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "§A¤£¦A¨º»ò¿³¾Ä.", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            SKILL_APP, SKILL_APP, SKILL_LIMIT(-1, 85,6), SKILL_APP, SKILL_APP },
const.c:            SKILL_LIMIT(15, 45,6), SKILL_LIMIT(1,95,6), SKILL_LIMIT(-1,95,6), SKILL_LIMIT(-1,95,6), SKILL_LIMIT(5,80,6), 
const.c:            "",   "!Hide!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!hunt!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Peek!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "!Pick!", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "§A°±¤î¼ç¦æ¡C", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "!Scan!",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "°ª¯à®ÖÃz", "!High Explosive Ammo!",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            SKILL_APP, SKILL_APP, SKILL_LIMIT(20,99,6), SKILL_LIMIT(-1,99,6), SKILL_APP, 
const.c:            "§l¦å°­¤§§k", "§A·P¨ì¤@°}¹¡¨¬.",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "³±­·«ã¸¹", "!wind screaming!",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "«ã¤õ­·¼É", "!angry fire storm!",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "¤õÀð³N", "¤õÀð½w½w¦aº¶·À¤F¡C",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "§A©P³òªº¤õµK¨¾¾À®ø¥¢¤F¡C. ", ATTR_ALL, {-1,-1,5,4,-1}
const.c:            "",   "§A©P³òªº´H¦B¨¾¾À®ø¥¢¤F¡C. ", ATTR_ALL, {-1,-1,5,4,-1}
const.c:            "",   "§A©P³òªº¯e­·¨¾¾À®ø¥¢¤F¡C. ", ATTR_ALL, {-1,-1,5,4,-1}
const.c:            "",   "§A©P³òªº¤j¦a¨¾¾À®ø¥¢¤F¡C. ", ATTR_ALL, {-1,-1,5,4,-1}
const.c:            "",   "§A©P³òªº¯«¸t¨¾¾À®ø¥¢¤F¡C. ", ATTR_ALL, {-1,-1,5,4,-1}
const.c:            "",   "", ATTR_ALL, {-1,-1,5,4,-1}
const.c:            "",   "¦º¤`ªº³±¼v³vº¥Â÷§A»·¥h¡C", ATTR_ALL, {-1,-1,7,5,-1}
const.c:            "¾Ô§Å¤Ñ«ã", "", ATTR_ALL, { 8,-1,5,6,-1}
const.c:            "²b¤Æ¤§ºq",   "²b¤Æ¤§ºq", ATTR_ALL, {-1,6,-1,4,-1}
const.c:    // this skill is for war-kni
const.c:            SKILL_APP, SKILL_APP, SKILL_LIMIT(32,90,6), SKILL_LIMIT(-1,90,6), SKILL_APP, 
const.c:            SKILL_APP, SKILL_LIMIT(-1,90,6), SKILL_APP, SKILL_APP, SKILL_APP },
const.c:            "",   "§A²´¤¤ªº¯«¥ú³vº¥«ì´_¥¿±`¡C", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "§Aªþ¥[¦b½b¤Wªº¤O¶q®ø¥¢¤F¡C", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            SKILL_APP, SKILL_APP, SKILL_LIMIT(-1,95,6), SKILL_LIMIT(-1,95,6), SKILL_APP,
const.c:            SKILL_APP, SKILL_LIMIT(-1,80,6), SKILL_APP, SKILL_LIMIT(-1,85,6), SKILL_LIMIT(-1,70,6),
const.c:            SKILL_LIMIT(-1,80,6), SKILL_LIMIT(-1,85,6), SKILL_LIMIT(-1,80,6), SKILL_APP, SKILL_APP },
const.c:            "¯e¯f³N", "§AÄ±±oµÎªA¦h¤F.", ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "",   "§A©P³òªº°{¹q¨¾¾À®ø¥¢¤F¡C. ", ATTR_ALL, {-1,-1,5,4,-1}
const.c:            "¨F®öÂ½ÄË", "§A·PÄ±²×©ó±q¨F°ï¸Ì±Ã²æ¥X¨Ó.",ATTR_ALL, {-1,4,2,3,-1}
const.c:            "³à§¯¼FÀz", "§A·PÄ±³ø³à¤k§¯ªº­úÀz®ø¥¢¤F.",ATTR_ALL, {-1,4,2,3,-1}
const.c:            "¾yÅ]­»§k", "§A·PÄ±¾yÅ]±aµ¹§Aªº¿E±¡º¥º¥»·Â÷.",ATTR_ALL, {-1,4,2,3,-1}
const.c:            "·N§Ó­n¶ë", "§A·PÄ±°í±jªº·N§ÓªZ¸ËºCºC±Y¸¨.",ATTR_ALL, {-1,7,2,4,-1}
const.c:            "¤ßÆFÃz¾_", "§A¤ßÆFºCºC±q¼Ò½k¤¤¦^¯«.",ATTR_ALL, {-1,3,2,2,-1}
const.c:            "¤Û¶H°£·À", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "¦Ê°­©]¦æ", "§A·PÄ±¥|©P°­¾yªº¥æ½ÍÁn²×©ó®ø¥¢.",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "¤¸¯ÀÅ]ªk±Ù", "",ATTR_ALL, {-1,-1,-1,-1,-1}
const.c:            "¥Û¤Æ",  "¨­Åéªº¥Û¤Æª¬ºAº¥º¥®ø¥¢¤F.", ATTR_ALL, {-1,-1,-1,-1,-1}
db.c://*---------------------------------------------------------------*
db.c://*---------------------------------------------------------------*
db.c://*---------------------------------------------------------------*
db.c://*---------------------------------------------------------------*
db.c://*---------------------------------------------------------------*
db.c: * Semi-locals.
db.c: * Non-Envy Loading procedures.
db.c:  lhour   = ( current_time - 650336715 )
db.c:      if ( strArea[0] == '-' )
db.c:  pSymbol->str = str_dup(word);
db.c:  pSymbol->num = fread_number( fp , &status);
db.c:  if( !isalpha(pSymbol->str[0]) )
db.c:      log_string(pSymbol->str);
db.c:  letter = LOWER(pSymbol->str[0])-'a';
db.c:  pSymbol->next = symbol_hash[letter];
db.c:    pArea->reset_first  = NULL;          * OLC-Removed
db.c:    pArea->reset_last = NULL;          */
db.c:    pArea->name   = fread_string( fp, &stat );
db.c:    pArea->recall = ROOM_VNUM_TEMPLE;
db.c:    pArea->area_flags = AREA_LOADING;   /* OLC */
db.c:    pArea->security = 1;      /* OLC */
db.c:    pArea->builders = str_dup( "None" );  /* OLC */
db.c:    pArea->lvnum  = 0;      /* OLC */
db.c:    pArea->uvnum  = 0;      /* OLC */
db.c:    pArea->vnum   = top_area;   /* OLC */
db.c:    pArea->filename = str_dup( strArea ); /* OLC */
db.c:    pArea->age    = 15;
db.c:    pArea->nplayer  = 0;
db.c:  area_last->next = pArea;
db.c:  REMOVE_BIT(area_last->area_flags, AREA_LOADING);  /* OLC */
db.c:    pArea->next = NULL;
db.c:    pArea->reset_first  = NULL;          * OLC-Removed
db.c:    pArea->reset_last = NULL;          */
db.c://    pArea->name   = fread_string( fp, &stat );
db.c:    pArea->recall = ROOM_VNUM_TEMPLE;
db.c:    pArea->area_flags = AREA_LOADING;   /* OLC */
db.c:    pArea->security = 1;      /* OLC */
db.c:    pArea->builders = str_dup( "None" );  /* OLC */
db.c:    pArea->lvnum  = 0;      /* OLC */
db.c:    pArea->uvnum  = 0;      /* OLC */
db.c:    pArea->vnum   = top_area;   /* OLC */
db.c:    pArea->filename = str_dup( strArea ); /* OLC */
db.c:    pArea->age    = 15;
db.c:    pArea->nplayer  = 0;
db.c:    pArea->f_toggle = 0;
db.c:  pArea->name   = fread_string( fp, &stat );
db.c:  pArea->builders   = diw_fread_string( fp, &stat );
db.c:  pArea->translator = diw_fread_string( fp, &stat );
db.c:  pArea->modifier   = diw_fread_string( fp, &stat );
db.c:  pArea->identity   = fread_string( fp, &stat );
db.c:  pArea->f_toggle = fread_number( fp, &stat );
db.c:  area_last->next = pArea;
db.c:  REMOVE_BIT(area_last->area_flags, AREA_LOADING);  /* OLC */
db.c:    pArea->next = NULL;
db.c:    pArea->age    = 15;
db.c:    pArea->nplayer  = 0;
db.c:    pArea->filename = str_dup( strArea );
db.c:    pArea->vnum   = top_area;
db.c:    pArea->name   = str_dup( "New Area" );
db.c:    pArea->builders = str_dup( "" );
db.c:    pArea->security = 1;
db.c:    pArea->lvnum  = 0;
db.c:    pArea->uvnum  = 0;
db.c:    pArea->area_flags = 0;
db.c:    pArea->recall = ROOM_VNUM_TEMPLE;
db.c:    pArea->death  = 0;
db.c:    pArea->f_toggle = 0;
db.c:    pArea->reborn       = 0;
db.c:      SKEY( "Name", pArea->name );
db.c://    bug(pArea->name,0);
db.c:      SKEY( "Identity", pArea->identity );
db.c:    for( cn = clan_list; cn; cn = cn->next )
db.c:      if ( !str_cmp( pArea->identity, cn->founder ) )
db.c:        pArea->clan = cn;
db.c:      SKEY( "Builders", pArea->builders );
db.c:      SKEY( "Translator", pArea->translator );
db.c:      SKEY( "Modifier", pArea->modifier );
db.c:       KEY( "Security", pArea->security, fread_number( fp, &stat ) );
db.c:    pArea->lvnum = fread_number( fp, &stat );
db.c:    pArea->uvnum = fread_number( fp, &stat );
db.c:        area_last->next = pArea;
db.c:     pArea->next = NULL;
db.c:     if( pArea->death < 1 ) {
db.c:         if( pArea->recall == ROOM_VNUM_TEMPLE)
db.c:       pArea->death = ROOM_VNUM_ALTAR;
db.c:       pArea->death = pArea->recall;
db.c:        KEY( "Recall", pArea->recall, fread_number( fp, &stat ) );
db.c:      KEY( "Areborn", pArea->reborn, fread_number( fp, &stat) );
db.c:       KEY( "Death", pArea->death, fread_number( fp, &stat ) );
db.c:       KEY( "F_toggle", pArea->f_toggle, fread_number( fp, &stat ) );
db.c:    if ( area_last->lvnum == 0 || area_last->uvnum == 0 )
db.c:  area_last->lvnum = area_last->uvnum = vnum;
db.c:    if ( vnum != URANGE( area_last->lvnum, vnum, area_last->uvnum ) )
db.c:  if ( vnum < area_last->lvnum )
db.c:      area_last->lvnum = vnum;
db.c:      area_last->uvnum = vnum;
db.c:  pHelp->level  = level;
db.c:  pHelp->keyword  = keyword;
db.c:  pHelp->text = fread_string( fp, &stat );
db.c:  if ( !str_cmp( pHelp->keyword, "GREETING" ) && num_greeting < MAX_GREETING)
db.c:      help_greeting[num_greeting++] = pHelp->text;
db.c:      help_last->next = pHelp;
db.c:  pHelp->next = NULL;
db.c:    pArea->recall = fread_number( fp, &stat );
db.c:    if ( pArea->recall < 1 )
db.c:  sprintf( buf, "Load_recall:  %s invalid recall point", pArea->name );
db.c:  pArea->recall = ROOM_VNUM_TEMPLE;
db.c:        pMobIndex->vnum     = vnum;
db.c:        pMobIndex->area     = area_last;    /* OLC */
db.c:        pMobIndex->player_name    = fread_string( fp, &stat );
db.c:        pMobIndex->short_descr    = fread_string( fp, &stat );
db.c:        /*pMobIndex->cname    = fread_string( fp, &stat );*/
db.c:        pMobIndex->long_descr   = fread_string( fp, &stat );
db.c:        pMobIndex->description    = fread_string( fp, &stat );
db.c:        pMobIndex->long_descr[0]  = UPPER( pMobIndex->long_descr[0]  );
db.c:        pMobIndex->description[0] = UPPER( pMobIndex->description[0] );
db.c:        pMobIndex->act      = fread_number( fp, &stat ) | ACT_IS_NPC;
db.c:        pMobIndex->affected_by    = fread_number( fp, &stat );
db.c:        pMobIndex->pShop    = NULL;
db.c:        pMobIndex->alignment    = fread_number( fp, &stat );
db.c:        pMobIndex->level    = number_fuzzy( fread_number( fp,
db.c:        if ( pMobIndex->level < 36 ) fAutoset = FALSE;   //added by Razgriz    20050720
db.c:         * The unused stuff is for imps who want to use the old-style
db.c:         * stats-in-files method.
db.c:           pMobIndex->hitroll   = fread_number( fp, &stat );   
db.c:           pMobIndex->ac      = fread_number( fp, &stat );   
db.c:           pMobIndex->hitnodice   = fread_number( fp, &stat );  
db.c:           pMobIndex->hitsizedice   = fread_number( fp, &stat );  
db.c:           pMobIndex->hitplus   = fread_number( fp, &stat ); 
db.c:           pMobIndex->damnodice   = fread_number( fp, &stat );   
db.c:           pMobIndex->damsizedice   = fread_number( fp, &stat );   
db.c:           pMobIndex->damplus   = fread_number( fp, &stat );  
db.c:           pMobIndex->gold      = fread_number( fp, &stat );   
db.c:        pMobIndex->mod_hitplus    = fread_number( fp, &stat );  
db.c:        pMobIndex->mod_mana   = fread_number( fp, &stat );  
db.c:        pMobIndex->mod_hitroll    = fread_number( fp, &stat );  
db.c:        pMobIndex->mod_damroll    = fread_number( fp, &stat );   
db.c:        pMobIndex->mod_ac   = fread_number( fp, &stat );  
db.c:        pMobIndex->mod_svs[0]   = fread_number( fp, &stat );   
db.c:        pMobIndex->dodge    = fread_number( fp, &stat );   
db.c:        pMobIndex->mod_pp   = fread_number( fp, &stat );
db.c:        pMobIndex->gold     = fread_number( fp, &stat );  
db.c:        pMobIndex->sex      = fread_number( fp, &stat );
db.c:           pMobIndex->race = race_lookup( race );
db.c:           if ( pMobIndex->race < 0 )
db.c:           pMobIndex->race = 0;
db.c:            bug( "Load_mobiles: vnum %d non-S.", vnum );
db.c:                            pMobIndex->mod_str += mod;
db.c:                            //  pMobIndex->str += mod;
db.c:                            pMobIndex->mod_dex += mod;
db.c:                            //      pMobIndex->dex += mod;
db.c:                            pMobIndex->mod_int += mod;    
db.c:                            //      pMobIndex->int += mod;
db.c:                            pMobIndex->mod_wis += mod;    
db.c:                            //      pMobIndex->wis += mod;
db.c:                            pMobIndex->mod_con += mod;          
db.c:                            //      pMobIndex->con += mod;
db.c:                            pMobIndex->sex+= mod; 
db.c:                            pMobIndex->race = abs( pMobIndex->race + mod); 
db.c:                            pMobIndex->mod_mana += mod; 
db.c:                            pMobIndex->mod_hitplus += mod; 
db.c:                            /* pMobIndex->mod_move    += mod;*/ 
db.c:                            pMobIndex->mod_exp += mod;
db.c:                            pMobIndex->mod_ac += mod; 
db.c:                            pMobIndex->mod_hitroll += mod; 
db.c:                            pMobIndex->mod_damroll += mod; 
db.c:                            pMobIndex->mod_svs[0] += mod; 
db.c:                            pMobIndex->mod_svs[MAGIC_BREATH] += mod; 
db.c:                            pMobIndex->mod_svs[0] += mod; 
db.c:                            pMobIndex->mod_svs[MAGIC_EARTH] += mod;
db.c:                            pMobIndex->mod_svs[MAGIC_SAINT] += mod;
db.c:                            pMobIndex->mod_svs[MAGIC_FIRE] += mod; 
db.c:                            pMobIndex->mod_svs[MAGIC_COLD] += mod; 
db.c:                            pMobIndex->mod_svs[MAGIC_LIGHTNING] += mod;
db.c:                            pMobIndex->mod_svs[MAGIC_WIND] += mod; 
db.c:                            pMobIndex->mod_svs[MAGIC_DARK] += mod;
db.c:                            pMobIndex->mod_svs[0] += mod;
db.c:                            pMobIndex->mod_svs[MAGIC_FIRE] += mod; 
db.c:                            pMobIndex->mod_svs[MAGIC_WIND] += mod; 
db.c:                            pMobIndex->mod_svs[MAGIC_COLD] += mod; 
db.c:                            pMobIndex->mod_svs[MAGIC_EARTH]+= mod;
db.c:                            pMobIndex->mod_svs[MAGIC_LIGHTNING] += mod; 
db.c:                            pMobIndex->mod_svs[MAGIC_BREATH] += mod; break;
db.c:                         *  pMobIndex->mod_svs[MAGIC_SPELL] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_ANCIENT] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_SPIRIT] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_FIRE] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_COLD] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_LIGHTNING] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_EARTH] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_WIND] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_SAINT] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_DARK] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_POISON] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_NATURE] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_GOOD] += mod; 
db.c:                         *  pMobIndex->mod_svs[MAGIC_EVIL] += mod; 
db.c:                            pMobIndex->pdr += mod;
db.c:                            pMobIndex->mdr += mod; 
db.c:                            pMobIndex->apdr += mod;
db.c:                            pMobIndex->amdr += mod;
db.c:                            pMobIndex->pad += mod; 
db.c:                            pMobIndex->mad += mod; 
db.c:                            pMobIndex->mod_pp += mod;
db.c:                            pMobIndex->dodge += mod; 
db.c:                                    type, pMobIndex->vnum);
db.c:                    pMobIndex->race = race_lookup( race );
db.c:                    if ( pMobIndex->race < 0 )
db.c:                        pMobIndex->race = 0;
db.c:                    pMobIndex->class = fread_number( fp, &stat );
db.c:                    pMobIndex->replica = fread_number(fp,&stat );
db.c:                    pMobIndex->special = fread_number( fp, &stat );
db.c:                    pMobIndex->psk = fread_string( fp, &stat );
db.c:                    pMobIndex->jcl = fread_string( fp, &stat );
db.c:                    weak->name  = fread_string( fp, &stat );
db.c:                    weak->percent = fread_number( fp, &stat );
db.c:                    weak->damage = fread_number( fp, &stat );
db.c:                    if( pMobIndex->weakness ) 
db.c:                        weak->next = pMobIndex->weakness;
db.c:                    pMobIndex->weakness = weak;
db.c:        pMobIndex->fAutoset = fAutoset;   //Added by Razgriz    20050720
db.c:        pMobIndex->next = mob_index_hash[iHash];
db.c:        kill_table[URANGE( 0, pMobIndex->level, MAX_LEVEL-1 )].number++;
db.c:  pObjIndex->vnum     = vnum;
db.c:  pObjIndex->area     = area_last;    /* OLC */
db.c:  pObjIndex->name     = fread_string( fp, &stat );
db.c:  pObjIndex->short_descr    = fread_string( fp, &stat );
db.c:  /*pObjIndex->cname    = fread_string( fp, &stat );*/
db.c:  pObjIndex->description    = fread_string( fp, &stat );
db.c:  pObjIndex->short_descr[0] = LOWER( pObjIndex->short_descr[0] );
db.c:  pObjIndex->description[0] = UPPER( pObjIndex->description[0] );
db.c:  pObjIndex->item_type    = fread_number( fp, &stat );
db.c:  pObjIndex->extra_flags    = fread_number( fp, &stat );
db.c:  pObjIndex->wear_flags   = fread_number( fp, &stat );
db.c:  pObjIndex->weight   = fread_number( fp, &stat );
db.c:  pObjIndex->cost     = fread_number( fp, &stat );
db.c:   * Check here for the redundancy of invisible light sources - Kahn
db.c:  if ( pObjIndex->item_type == ITEM_LIGHT
db.c:      && IS_SET( pObjIndex->extra_flags, ITEM_INVIS ) )
db.c:      REMOVE_BIT( pObjIndex->extra_flags, ITEM_INVIS );
db.c:      paf->type   = -1;
db.c:      paf->duration   = -1;
db.c:      paf->location   = fread_number( fp, &stat );
db.c:      paf->modifier   = fread_number( fp, &stat );
db.c:      paf->bitvector    = 0;
db.c:      paf->next   = pObjIndex->affected;
db.c:      pObjIndex->affected = paf;
db.c:      paf->type   = -1;
db.c:      paf->duration   = -1;
db.c:      paf->location   = 0;
db.c:      paf->modifier   = 0;
db.c:      paf->bitvector    = fread_number( fp, &stat );
db.c:      paf->next   = pObjIndex->affected;
db.c:      pObjIndex->affected = paf;
db.c:          hp->vnum    = vnum;
db.c://        hp->hp_name = skill_table[fread_number( fp, &stat )].name;
db.c:        hp->hp_name = diw_fread_string( fp, &stat );
db.c:            hp->hp_name = fread_string( fp, &stat );
db.c:          hp->percent   = fread_number( fp, &stat );
db.c:          hp->level   = fread_number( fp, &stat );
db.c:          hp->event   = fread_number( fp, &stat );
db.c:          //hp->next    = obj_hp_list;
db.c:      hp->next    = pObjIndex->hp;
db.c:        pObjIndex->hp   = hp;
db.c:          pObjIndex->level  = fread_number( fp, &stat );
db.c:          pObjIndex->timer  = fread_number( fp, &stat );
db.c:          pObjIndex->cost   = fread_number( fp, &stat );
db.c:                        if( pObjIndex->cost < 0 ) {
db.c:                            bug("Obj's cost < 0, vnum = %d", pObjIndex->vnum);
db.c:                            pObjIndex->cost = 0;
db.c:          pObjIndex->class  = fread_number( fp, &stat );
db.c:      vrace->race = race_lookup( buf );
db.c:      vrace->hr_mod_q = fread_number( fp, &stat);
db.c:      vrace->hr_mod_p = fread_number( fp, &stat);
db.c:      vrace->dr_mod_q = fread_number( fp, &stat);
db.c:      vrace->dr_mod_p = fread_number( fp, &stat);
db.c:      vrace->next = pObjIndex->vrace;
db.c:      pObjIndex->vrace = vrace;
db.c:          pObjIndex->race   = fread_number( fp, &stat );
db.c:   * - Thelonius
db.c:  switch ( pObjIndex->item_type )
db.c:      pObjIndex->value[0] = atoi( value[0] );
db.c:      pObjIndex->value[1] = atoi( value[1] );
db.c:      pObjIndex->value[2] = atoi( value[2] );
db.c:      pObjIndex->value[3] = atoi( value[3] );
db.c:      pObjIndex->value[0] = atoi( value[0] );
db.c:      pObjIndex->value[1] = skill_lookup( value[1] );
db.c:      pObjIndex->value[2] = skill_lookup( value[2] );
db.c:      pObjIndex->value[3] = skill_lookup( value[3] );
db.c:      pObjIndex->value[0] = atoi( value[0] );
db.c:      pObjIndex->value[1] = atoi( value[1] );
db.c:      pObjIndex->value[2] = atoi( value[2] );
db.c:      pObjIndex->value[3] = skill_lookup( value[3] );
db.c:      pObjIndex->vnum = 1;
db.c:      pObjIndex->vnum = material_list->vnum + 1;
db.c:      pObjIndex->next = material_list;
db.c:  pObjIndex->vnum     = vnum;
db.c:  pObjIndex->area     = area_last;    /* OLC */
db.c:  free_string( pObjIndex->name );
db.c:  pObjIndex->name     = fread_string( fp, &stat );
db.c:  free_string( pObjIndex->short_descr );
db.c:  pObjIndex->short_descr    = fread_string( fp, &stat );
db.c:  /*pObjIndex->cname    = fread_string( fp, &stat );*/
db.c:  free_string( pObjIndex->description );
db.c:  pObjIndex->description    = fread_string( fp, &stat );
db.c:  pObjIndex->short_descr[0] = LOWER( pObjIndex->short_descr[0] );
db.c:  pObjIndex->description[0] = UPPER( pObjIndex->description[0] );
db.c:  pObjIndex->item_type    = fread_number( fp, &stat );
db.c:  pObjIndex->extra_flags    = fread_number( fp, &stat );
db.c:  pObjIndex->wear_flags   = fread_number( fp, &stat );
db.c:  pObjIndex->weight   = fread_number( fp, &stat );
db.c:  pObjIndex->cost     = fread_number( fp, &stat );
db.c:        if( pObjIndex->cost < 0 ) {
db.c:            bug("Obj's cost < 0, vnum = %d", pObjIndex->vnum);
db.c:            pObjIndex->cost = 0;
db.c:  pObjIndex->max_level =      fread_number( fp, &stat );   /* Unused */
db.c:   * Check here for the redundancy of invisible light sources - Kahn
db.c:  if ( pObjIndex->item_type == ITEM_LIGHT
db.c:      && IS_SET( pObjIndex->extra_flags, ITEM_INVIS ) )
db.c:      REMOVE_BIT( pObjIndex->extra_flags, ITEM_INVIS );
db.c:      paf->type   = -1;
db.c:      paf->duration   = -1;
db.c:      paf->location   = fread_number( fp, &stat );
db.c:      paf->modifier   = fread_number( fp, &stat );
db.c:      paf->bitvector    = 0;
db.c:      paf->next   = pObjIndex->affected;
db.c:      pObjIndex->affected = paf;
db.c:      ed->keyword   = fread_string( fp, &stat );
db.c:      ed->description   = fread_string( fp, &stat );
db.c:      ed->next    = pObjIndex->extra_descr;
db.c:      pObjIndex->extra_descr  = ed;
db.c:          hp->vnum    = vnum;
db.c://        hp->hp_name = skill_table[fread_number( fp, &stat )].name;
db.c:        hp->hp_name = diw_fread_string( fp, &stat );
db.c:          hp->hp_name   = fread_string( fp, &stat );
db.c:          hp->percent   = fread_number( fp, &stat );
db.c:          hp->level   = fread_number( fp, &stat );
db.c:          hp->event   = fread_number( fp, &stat );
db.c:          //hp->next    = obj_hp_list;
db.c:      hp->next    = pObjIndex->hp;
db.c:        pObjIndex->hp   = hp;
db.c:          pObjIndex->level  = fread_number( fp, &stat );
db.c:          pObjIndex->timer  = fread_number( fp, &stat );
db.c:          pObjIndex->horse  = fread_number( fp, &stat );
db.c:          pObjIndex->cost   = fread_number( fp, &stat );
db.c:                        if( pObjIndex->cost < 0 ) {
db.c:                            bug("Obj's cost < 0, vnum = %d", pObjIndex->vnum);
db.c:                            pObjIndex->cost = 0;
db.c:          pObjIndex->class  = fread_number( fp, &stat );
db.c:      vrace->race = race_lookup( buf );
db.c:      vrace->hr_mod_q = fread_number( fp, &stat);
db.c:      vrace->hr_mod_p = fread_number( fp, &stat);
db.c:      vrace->dr_mod_q = fread_number( fp, &stat);
db.c:      vrace->dr_mod_p = fread_number( fp, &stat);
db.c:      vrace->next = pObjIndex->vrace;
db.c:      pObjIndex->vrace = vrace;
db.c:        hp->vnum    = vnum;
db.c:        hp->hp_name   = fread_string( fp, &stat );
db.c:        hp->percent   = fread_number( fp, &stat );
db.c:        hp->level   = fread_number( fp, &stat );
db.c:        hp->event   = fread_number( fp, &stat );
db.c:            hp->p_race = NUM_BIT( material_lookup( str1 ) );
db.c:        //hp->next    = obj_hp_list;
db.c:      hp->next    = pObjIndex->hp;
db.c:        pObjIndex->hp   = hp;
db.c:        pObjIndex->hp_use_align = fread_number( fp, &stat );
db.c:        pObjIndex->hp_use_race = fread_number( fp, &stat );
db.c:        pObjIndex->hp_use_class = fread_number( fp, &stat );
db.c:        pObjIndex->hp_use_sex = fread_number( fp, &stat );
db.c:        pObjIndex->souvenir = fread_number( fp, &stat );
db.c:        //pObjIndex->special_limitation = fread_number( fp, &stat );
db.c:          pObjIndex->hp_affect_align = ALLOW_BIT + fread_number( fp, &stat );
db.c:          pObjIndex->hp_affect_sex = fread_number( fp, &stat );
db.c:          pObjIndex->hp_affect_race += NUM_BIT( race_lookup( fread_string( fp, &stat ) ) );
db.c:          pObjIndex->hp_affect_class += NUM_BIT( class_lookup( fread_string( fp, &stat ) ) );
db.c:          pObjIndex->hp_noeffect_race += NUM_BIT( race_lookup( fread_string( fp, &stat ) ) );
db.c:          pObjIndex->hp_noeffect_class += NUM_BIT( class_lookup( fread_string( fp, &stat ) ) );
db.c:        align_af->type    = -1;
db.c:        align_af->duration    = -1;
db.c:        align_af->location    = fread_number( fp, &stat );
db.c:        align_af->modifier    = fread_number( fp, &stat );
db.c:        align_af->bitvector   = 0;
db.c:        align_af->next    = pObjIndex->align_affected;
db.c:        pObjIndex->affected = align_af;
db.c:        pObjIndex->hp_use_align = fread_number( fp, &stat );
db.c:        pObjIndex->hp_use_race = fread_number( fp, &stat );
db.c:        pObjIndex->hp_use_class = fread_number( fp, &stat );
db.c:        pObjIndex->hp_use_sex = fread_number( fp, &stat );
db.c:      pObjIndex->material = material_lookup(buf);
db.c:          pObjIndex->race   = fread_number( fp, &stat );
db.c:      paf->type   = -1;
db.c:      paf->duration   = -1;
db.c:      paf->location   = 0;
db.c:      paf->modifier   = 0;
db.c:      paf->bitvector    = fread_number( fp, &stat );
db.c:      paf->next   = pObjIndex->affected;
db.c:      pObjIndex->affected = paf;
db.c:      pObjIndex->replica  = fread_number(fp, &stat);
db.c:      SET_BIT(pObjIndex->extra_flags, ITEM_UNIQUE);
db.c:      SET_BIT(pObjIndex->extra_flags, ITEM_NOSAVE);
db.c:        pObjIndex->on_message = fread_string( fp, &stat );
db.c:        pObjIndex->off_message  = fread_string( fp, &stat );
db.c:        pObjIndex->hit_message = fread_string(fp, &stat);
db.c:  if( !pObjIndex->material ) pObjIndex->material = material_lookup( "Generic");
db.c:   * - Thelonius
db.c:  switch ( pObjIndex->item_type )
db.c:      pObjIndex->value[0] = atoi( value[0] );
db.c:      pObjIndex->value[1] = atoi( value[1] );
db.c:      pObjIndex->value[2] = atoi( value[2] );
db.c:      pObjIndex->value[3] = atoi( value[3] );
db.c:      pObjIndex->value[0] = atoi( value[0] );
db.c:      pObjIndex->value[1] = skill_lookup( value[1] );
db.c:      pObjIndex->value[2] = skill_lookup( value[2] );
db.c:      pObjIndex->value[3] = skill_lookup( value[3] );
db.c:      pObjIndex->value[0] = atoi( value[0] );
db.c:      pObjIndex->value[1] = atoi( value[1] );
db.c:      pObjIndex->value[2] = atoi( value[2] );
db.c:      pObjIndex->value[3] = skill_lookup( value[3] );
db.c:  pObjIndex->next   = obj_index_hash[iHash];
db.c:    pr = pR->reset_last;
db.c:  pR->reset_first = pReset;
db.c:  pR->reset_last  = pReset;
db.c:  pR->reset_last->next = pReset;
db.c:  pR->reset_last       = pReset;
db.c:  pR->reset_last->next = NULL;
db.c:  pReset->command = letter;
db.c:  pReset->arg1  = fread_number( fp, &stat );
db.c:  pReset->arg2  = fread_number( fp, &stat );
db.c:  pReset->arg3  = ( letter == 'G' || letter == 'R' )
db.c:      get_mob_index  ( pReset->arg1 );
db.c:      if ( ( pRoomIndex = get_room_index ( pReset->arg3 ) ) )
db.c:    iLastRoom = pReset->arg3;
db.c:      get_obj_index  ( pReset->arg1 );
db.c:      if ( ( pRoomIndex = get_room_index ( pReset->arg3 ) ) )
db.c:    iLastObj = pReset->arg3;
db.c:      get_obj_index  ( pReset->arg1 );
db.c:      get_mob_index  ( abs( pReset->arg1 ) );
db.c:      get_mob_index  ( abs( pReset->arg3 ) );
db.c:      get_obj_index  ( pReset->arg1 );
db.c:      pRoomIndex = get_room_index( pReset->arg1 );
db.c:      if (   pReset->arg2 < 0
db.c:    || pReset->arg2 > 5
db.c:    || !( pexit = pRoomIndex->exit[pReset->arg2] )
db.c:    || !IS_SET( pexit->rs_flags, EX_ISDOOR ) )
db.c:    bug( "Load_resets: 'D': exit %d not door.", pReset->arg2 );
db.c:      switch ( pReset->arg3 ) /* OLC 1.1b */
db.c:        bug( "Load_resets: 'D': bad 'locks': %d." , pReset->arg3);
db.c:    case 1: SET_BIT( pexit->rs_flags, EX_CLOSED );
db.c:    case 2: SET_BIT( pexit->rs_flags, EX_CLOSED | EX_LOCKED );
db.c:/*      if ( pReset->arg3 < 0 || pReset->arg3 > 2 )
db.c:    bug( "Load_resets: 'D': bad 'locks': %d.", pReset->arg3 );
db.c:/*      pRoomIndex    = get_room_index( pReset->arg1 );
db.c:      if ( pReset->arg2 < 0 || pReset->arg2 > 6 ) /* Last Door. */
db.c:    bug( "Load_resets: 'R': bad exit %d.", pReset->arg2 );
db.c:      if ( ( pRoomIndex = get_room_index( pReset->arg1 ) ) )
db.c:/*  if ( !area_last->reset_first )
db.c:      area_last->reset_first  = pReset;
db.c:  if (  area_last->reset_last  )
db.c:      area_last->reset_last->next = pReset;
db.c:  area_last->reset_last = pReset;
db.c:  pReset->next    = NULL;
db.c:  pRoomIndex->people    = NULL;
db.c:  pRoomIndex->contents    = NULL;
db.c:  pRoomIndex->extra_descr   = NULL;
db.c:  pRoomIndex->area    = area_last;
db.c:  pRoomIndex->vnum    = vnum;
db.c:  pRoomIndex->name    = fread_string( fp, &stat );
db.c:  pRoomIndex->description   = fread_string( fp, &stat );
db.c:  pRoomIndex->room_flags    = fread_number( fp, &stat ) ;
db.c:  pRoomIndex->room_flags ^= area_last->f_toggle;
db.c:  pRoomIndex->sector_type   = fread_number( fp, &stat );
db.c:  pRoomIndex->light   = 0;
db.c:      pRoomIndex->exit[door] = NULL;
db.c:      pRoomIndex->fall = fread_number( fp, &stat );
db.c:    pexit->description  = fread_string( fp, &stat );
db.c:    pexit->keyword    = fread_string( fp, &stat );
db.c:    pexit->exit_info  = 0;
db.c:    pexit->rs_flags   = 0;      /* OLC */
db.c:    pexit->key    = fread_number( fp, &stat );
db.c:    pexit->vnum   = fread_number( fp, &stat );
db.c:    case 1: pexit->rs_flags = EX_ISDOOR;      break;
db.c:    case 2: pexit->rs_flags = EX_ISDOOR + EX_PICKPROOF; break;
db.c:    case 3: pexit->rs_flags = EX_ISDOOR + EX_PASSPROOF; break;
db.c:    case 4: pexit->rs_flags = EX_ISDOOR + EX_PICKPROOF + EX_PASSPROOF;     break;
db.c:    case 5: pexit->rs_flags = EX_ISDOOR + EX_BASHPROOF; break;
db.c:    case 6: pexit->rs_flags = EX_ISDOOR + EX_PICKPROOF
db.c:    case 7: pexit->rs_flags = EX_ISDOOR + EX_PASSPROOF
db.c:    case 8: pexit->rs_flags = EX_ISDOOR + EX_PICKPROOF
db.c:    pRoomIndex->exit[door]   = pexit;
db.c:    ed->keyword   = fread_string( fp, &stat );
db.c:    ed->description   = fread_string( fp, &stat );
db.c:    ed->next    = pRoomIndex->extra_descr;
db.c:    pRoomIndex->extra_descr = ed;
db.c:  pRoomIndex->next  = room_index_hash[iHash];
db.c:  pRoomIndex->people    = NULL;
db.c:  pRoomIndex->contents    = NULL;
db.c:  pRoomIndex->extra_descr   = NULL;
db.c:  pRoomIndex->area    = area_last;
db.c:  pRoomIndex->vnum    = vnum;
db.c:  pRoomIndex->name    = fread_string( fp, &stat );
db.c:  pRoomIndex->description   = fread_string( fp, &stat );
db.c:  pRoomIndex->room_flags    = fread_number( fp, &stat ) ;
db.c:  pRoomIndex->room_flags ^= area_last->f_toggle;
db.c:  pRoomIndex->sector_type   = fread_number( fp, &stat );
db.c:  pRoomIndex->light   = 0;
db.c:      pRoomIndex->exit[door] = NULL;
db.c:      pRoomIndex->fall = fread_number( fp, &stat );
db.c:    pexit->description  = fread_string( fp, &stat );
db.c:    pexit->keyword    = fread_string( fp, &stat );
db.c:    pexit->exit_info  = locks;
db.c:    pexit->rs_flags   = locks;
db.c:    pexit->key    = fread_number( fp, &stat );
db.c:    pexit->vnum   = fread_number( fp, &stat );
db.c:    case 1: pexit->rs_flags = EX_ISDOOR;      break;
db.c:    case 2: pexit->rs_flags = EX_ISDOOR + EX_PICKPROOF; break;
db.c:    case 3: pexit->rs_flags = EX_ISDOOR + EX_PASSPROOF; break;
db.c:    case 4: pexit->rs_flags = EX_ISDOOR + EX_PICKPROOF + EX_PASSPROOF;     break;
db.c:    case 5: pexit->rs_flags = EX_ISDOOR + EX_BASHPROOF; break;
db.c:    case 6: pexit->rs_flags = EX_ISDOOR + EX_PICKPROOF
db.c:    case 7: pexit->rs_flags = EX_ISDOOR + EX_PASSPROOF
db.c:    case 8: pexit->rs_flags = EX_ISDOOR + EX_PICKPROOF
db.c:    pRoomIndex->exit[door]    = pexit;
db.c:    ed->keyword   = fread_string( fp, &stat );
db.c:    ed->description   = fread_string( fp, &stat );
db.c:    ed->next    = pRoomIndex->extra_descr;
db.c:    pRoomIndex->extra_descr = ed;
db.c:  pRoomIndex->next  = room_index_hash[iHash];
db.c:  pShop->keeper   = keeper;
db.c:      pShop->buy_type[iTrade] = fread_number( fp, &stat );
db.c:  pShop->profit_buy = fread_number( fp, &stat );
db.c:  pShop->profit_sell  = fread_number( fp, &stat );
db.c:  pShop->open_hour  = fread_number( fp, &stat );
db.c:  pShop->close_hour = fread_number( fp, &stat );
db.c:  pMobIndex   = get_mob_index( pShop->keeper );
db.c:  pMobIndex->pShop  = pShop;
db.c:  if( pShop->profit_buy < 100 ){
db.c:      pShop->profit_buy = 120;
db.c:  if( pShop->profit_sell > 100 ){
db.c:      pShop->profit_sell = 80;
db.c:      shop_last->next = pShop;
db.c:  pShop->next = NULL;
db.c:      pMobIndex->spec_fun = spec_lookup ( fread_word   ( fp, &stat ) );
db.c:      if ( pMobIndex->spec_fun == 0 )
db.c:    bug( "Load_specials: 'M': vnum %d.", pMobIndex->vnum );
db.c:  pnote->sender   = fread_string( fp, &stat );
db.c:  pnote->csender    = fread_string( fp, &stat );
db.c:  pnote->date   = fread_string( fp, &stat );
db.c:  pnote->date_stamp = fread_number( fp, &stat );
db.c:  pnote->to_list    = fread_string( fp, &stat );
db.c:  pnote->subject    = fread_string( fp, &stat );
db.c:  pnote->text   = fread_string( fp, &stat );
db.c:      pnotelast->next = pnote;
db.c:  check_time->tm_sec = 59 ;
db.c:  check_time->tm_min = 59 ;
db.c:  check_time->tm_hour = 23 ;
db.c:  if( check_time->tm_mon == 1
db.c:      || check_time->tm_mon == 3
db.c:      || check_time->tm_mon == 5
db.c:      || check_time->tm_mon == 7
db.c:      || check_time->tm_mon == 8
db.c:      || check_time->tm_mon == 10)
db.c:  	  if( check_time->tm_mday == 31)
db.c:  	  	  check_time->tm_mday = 1;
db.c:  	  	  check_time->tm_mon += 1;
db.c:  	  	  check_time->tm_mday += 1 ;
db.c:  else if( check_time->tm_mon == 2 )
db.c:  	  if( check_time->tm_yday == 365 )
db.c:  	      if( check_time->tm_mday == 29)
db.c:  	      	  check_time->tm_mday = 1;
db.c:  	      	  check_time->tm_mon += 1;
db.c:  	      	  check_time->tm_mday += 1 ;
db.c:  	      if( check_time->tm_mday == 28)
db.c:  	      	  check_time->tm_mday = 1;
db.c:  	      	  check_time->tm_mon += 1;
db.c:  	      	  check_time->tm_mday += 1 ;
db.c:  else if( check_time->tm_mon == 12 )
db.c:  	  if( check_time->tm_mday == 31)
db.c:  	  	  check_time->tm_mday = 1;
db.c:  	  	  check_time->tm_mon = 0;
db.c:  	  	  check_time->tm_year += 1;
db.c:  	  	  check_time->tm_mday += 1 ;
db.c:  	  if( check_time->tm_mday == 30)
db.c:  	  	  check_time->tm_mday = 1;
db.c:  	  	  check_time->tm_mon = 1;
db.c:  	  	  check_time->tm_year += 1;
db.c:  	  	  check_time->tm_mday += 1 ;
db.c:  warning2   = down_time - 150;
db.c:  warning1   = warning2  - 150;
db.c:  warning0   = warning2 - 1800;
db.c:          warning2   = down_time - 150;
db.c:          warning1   = warning2  - 75;
db.c:          warning0   = warning2 - 1800;
db.c:            warning2   = down_time - 150;
db.c:            warning1   = warning2  - 150;
db.c:            warning0   = warning2 - 1800;
db.c:      ban_free = ban_free->next;
db.c:  pban->name   = fread_string( fp, &stat );
db.c:  pban->next   = ban_list;
db.c:        pRoomIndex  = pRoomIndex->next )
db.c:    if ( ( pexit = pRoomIndex->exit[door] ) )
db.c:        if ( pexit->vnum <= 0 )
db.c:      pexit->to_room = NULL;
db.c:      pexit->to_room = get_room_index( pexit->vnum );
db.c:    SET_BIT( pRoomIndex->room_flags, ROOM_NO_MOB );
db.c:        pRoomIndex  = pRoomIndex->next )
db.c:    if (   ( pexit     = pRoomIndex->exit[door]   )
db.c:        && ( to_room   = pexit->to_room     )
db.c:        && ( pexit_rev = to_room->exit[rev_dir[door]] )
db.c:        &&   pexit_rev->to_room != pRoomIndex )
db.c:        sprintf( buf, "Fix_exits: %d:%d -> %d:%d -> %d.",
db.c:          pRoomIndex->vnum, door,
db.c:          to_room->vnum,    rev_dir[door],
db.c:          ( !pexit_rev->to_room ) ? 0
db.c:          :  pexit_rev->to_room->vnum );
db.c:    for ( pArea = area_first; pArea; pArea = pArea->next )
db.c:  if ( ++pArea->age < 3 )
db.c:  if ( pArea->reborn != 0)
db.c:    if ( pArea->nplayer > 0 && pArea->age == pArea->reborn -1)
db.c:        for ( pch = char_list; pch; pch = pch->next )
db.c:          && pch->in_room
db.c:          && pch->in_room->area == pArea )
db.c:    if ( pArea->nplayer == 0 || pArea->age >= pArea->reborn )
db.c:       pArea->age = 0;
db.c:    if ( pArea->nplayer > 0 && pArea->age == 15 - 1 )
db.c:        for ( pch = char_list; pch; pch = pch->next )
db.c:          && pch->in_room
db.c:          && pch->in_room->area == pArea )
db.c:    if ( pArea->nplayer == 0 || pArea->age >= 15 )
db.c:       pArea->age = number_range( 0, 3 );
db.c:       if ( pRoomIndex && pArea == pRoomIndex->area )
db.c:      pArea->age = 15 - 3;
db.c://use this to create eqs from lv31 - 37
db.c:    case 0:  number -= 5; break;
db.c:    case 1:  number -= 4; break;
db.c:    case 2:  number -= 3; break;
db.c:    case 3:  number -= 2; break;
db.c:    case 4:  number -= 1; break;
db.c:  if ( ( pExit = pRoom->exit[iExit] ) )
db.c://    && !IS_SET( pExit->exit_info, EX_BASHED ) ) /* Skip Bashed. */
db.c:      pExit->exit_info = pExit->rs_flags;
db.c:      if ( ( pExit->to_room != NULL )
db.c:        && ( ( pExit = pExit->to_room->exit[rev_dir[iExit]] ) ) )
db.c:    pExit->exit_info = pExit->rs_flags;
db.c:    for ( pReset = pRoom->reset_first; pReset != NULL; pReset = pReset->next )
db.c:  switch ( pReset->command )
db.c:    bug( "Reset_room: bad command %c.", pReset->command );
db.c:      if ( !( pMobIndex = get_mob_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_room: 'M': bad vnum %d.", pReset->arg1 );
db.c:      if ( ( pMobIndex->spec_fun == spec_lookup( "spec_cast_ghost" ) &&
db.c:      if ( pMobIndex->count >= pReset->arg2 )
db.c:    SET_BIT(pMob->affected_by, AFF_INFRARED);
db.c:    pRoomIndexPrev = get_room_index( pRoom->vnum - 1 );
db.c:        && IS_SET( pRoomIndexPrev->room_flags, ROOM_PET_SHOP ) )
db.c:        SET_BIT( pMob->act, ACT_PET);
db.c:      level  = URANGE( 1, pMob->level - 2, 41 );
db.c:      if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_room: 'O': bad vnum %d.", pReset->arg1 );
db.c:      if ( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )
db.c:    bug( "Reset_room: 'O': bad vnum %d.", pReset->arg3 );
db.c:      if ( pRoom->area->nplayer > 0
db.c:        || count_obj_list( pObjIndex, pRoom->contents ) > 0 )
db.c:    if ( pRoom->area->clan && pRoom->area->clan->construct < 100 )
db.c:            if( IS_SET(pObj->extra_flags, ITEM_CLAN)){
db.c:                REMOVE_BIT(pObj->wear_flags, ITEM_TAKE);
db.c:                SET_BIT(pObj->extra_flags, ITEM_NOSAC);
db.c:      pObj->cost = 0;
db.c:    if ( pRoom->area->clan )
db.c:      switch( pObj->item_type )
db.c:        case ITEM_ARMOR : pRoom->area->clan->construct -=3; break;
db.c:        case ITEM_WEAPON : pRoom->area->clan->construct -=8; break;
db.c:        default : pRoom->area->clan->construct--; break;
db.c:      if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_room: 'P': bad vnum %d.", pReset->arg1 );
db.c:      if ( !( pObjToIndex = get_obj_index( pReset->arg3 ) ) )
db.c:    bug( "Reset_room: 'P': bad vnum %d.", pReset->arg3 );
db.c:      if ( pRoom->area->nplayer > 0
db.c:        ||( LastObj->in_room != pRoom ) 
db.c:        || ( LastObj->carried_by && !IS_NPC(LastObj->carried_by))
db.c:        || count_obj_list( pObjIndex, LastObj->contains ) > 0 )
db.c:    if ( pRoom->area->clan && pRoom->area->clan->construct < 100 )
db.c:    if ( pRoom->area->clan )
db.c:      switch( pObj->item_type )
db.c:        case ITEM_ARMOR : pRoom->area->clan->construct -=3; break;
db.c:        case ITEM_WEAPON : pRoom->area->clan->construct -=8; break;
db.c:        default : pRoom->area->clan->construct--; break;
db.c:            if ( LastObj->item_type == ITEM_CONTAINER )
db.c:                LastObj->value[1] = LastObj->pIndexData->value[1];
db.c:            if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
db.c:                bug( "Reset_room: 'E' or 'G': bad vnum %d.", pReset->arg1 );
db.c:                        pReset->arg1 );
db.c:            if ( pRoom->area->clan && pRoom->area->clan->construct < 100 )
db.c:            if ( LastMob->pIndexData->pShop ) /* Shop-keeper? */
db.c:                switch ( pObjIndex->item_type )
db.c:                                        if( pObjIndex->level )
db.c:                                            olevel = pObjIndex->level;
db.c:                                        else if ( pReset->command == 'G' )
db.c:                if ( pReset->command == 'G' )
db.c:                    SET_BIT( pObj->extra_flags, ITEM_INVENTORY );
db.c:                if( !IS_SET( LastMob->special,EXPERT ) ) {
db.c:                        level = number_range( 25,level); // mid-level mob
db.c:            if ( pRoom->area->clan ){
db.c:                switch( pObj->item_type )
db.c:                    case ITEM_ARMOR : pRoom->area->clan->construct -=3; break;
db.c:                    case ITEM_WEAPON : pRoom->area->clan->construct -=8; break;
db.c:                    default : pRoom->area->clan->construct--; break;
db.c:            if( IS_SET(LastMob->act, ACT_CLAN)){
db.c:                SET_BIT( pObj->extra_flags, ITEM_INVENTORY );
db.c:            if ( pReset->command == 'E' )
db.c:                equip_char( LastMob, pObj, pReset->arg3 );
db.c:      if ( !( pMobIndex = get_mob_index( abs( pReset->arg1 ) ) ) )
db.c:    bug( "Reset_area: 'F': bad vnum %d.", pReset->arg1 );
db.c:      for( lch = char_list; lch; lch = lch->next )
db.c:      if ( lch->pIndexData == pMobIndex )
db.c:      if ( !( pMobIndex = get_mob_index( abs( pReset->arg3 ) ) ) )
db.c:    bug( "Reset_area: 'F': bad vnum %d.", pReset->arg3 );
db.c:      for( vch = char_list; vch; vch = vch->next )
db.c:      if ( vch->pIndexData == pMobIndex )
db.c:      if ( vch->master )
db.c:            if( !lch->group ) {
db.c:            //victim->leader = ch;
db.c:      //vch->leader = lch;
db.c:      if ( pReset->arg2 != 0 )
db.c:        /*vch->protecting = lch;
db.c:    vch->next_in_protect = lch->protector;
db.c:        lch->protector = vch;*/
db.c:      if ( !( pRoomIndex = get_room_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_area: 'D': bad vnum %d.", pReset->arg1 );
db.c:      if ( !( pexit = pRoomIndex->exit[pReset->arg2] ) )
db.c:      if ( !IS_SET( pexit->exit_info, EX_BASHED ) )
db.c:    switch ( pReset->arg3 )
db.c:        REMOVE_BIT( pexit->exit_info, EX_CLOSED );
db.c:        REMOVE_BIT( pexit->exit_info, EX_LOCKED );
db.c:        SET_BIT(  pexit->exit_info, EX_CLOSED );
db.c:        REMOVE_BIT( pexit->exit_info, EX_LOCKED );
db.c:        SET_BIT(  pexit->exit_info, EX_CLOSED );
db.c:        SET_BIT(  pexit->exit_info, EX_LOCKED );
db.c:      if ( !( pRoomIndex = get_room_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_room: 'R': bad vnum %d.", pReset->arg1 );
db.c:    for ( d0 = 0; d0 < pReset->arg2 - 1; d0++ )
db.c:        d1       = number_range( d0, pReset->arg2-1 );
db.c:        pExit    = pRoomIndex->exit[d0];
db.c:        pRoomIndex->exit[d0] = pRoomIndex->exit[d1];
db.c:        pRoomIndex->exit[d1] = pExit;
db.c:    for ( pReset = pArea->reset_first; pReset; pReset = pReset->next )
db.c:  switch ( pReset->command )
db.c:      bug( "Reset_area: bad command %c.", pReset->command );
db.c:      if ( !( pMobIndex = get_mob_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_area: 'M': bad vnum %d.", pReset->arg1 );
db.c:      if ( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )
db.c:    bug( "Reset_area: 'R': bad vnum %d.", pReset->arg3 );
db.c:      if ( ( pMobIndex->spec_fun == spec_lookup( "spec_cast_ghost" )
db.c:      level = URANGE( 0, pMobIndex->level - 2, LEVEL_HERO );
db.c:         of in world. -Kahn */ /*
db.c:         moves it.  Dislike such specific coding.  Shrug.  -Kahn */ /*
db.c:      if ( IS_SET( pMobIndex->act, ACT_SENTINEL )
db.c:    && pMobIndex->vnum != MOB_VNUM_MIDGAARD_MAYOR )
db.c:    for ( ch = pRoomIndex->people; ch; ch = ch->next_in_room )
db.c:        if ( IS_NPC( ch ) && ch->pIndexData == pMobIndex )
db.c:    if ( count >= pReset->arg2 )
db.c:    if ( pMobIndex->count >= pReset->arg2 )
db.c:    pRoomIndexPrev = get_room_index( pRoomIndex->vnum - 1 );
db.c:        && IS_SET( pRoomIndexPrev->room_flags, ROOM_PET_SHOP ) )
db.c:        SET_BIT( mob->act, ACT_PET);
db.c:    SET_BIT( mob->affected_by, AFF_INFRARED );
db.c:      level = URANGE( 0, mob->level - 2, LEVEL_HERO );
db.c:      if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_area: 'O': bad vnum %d.", pReset->arg1 );
db.c:      if ( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )
db.c:    bug( "Reset_area: 'R': bad vnum %d.", pReset->arg3 );
db.c:      if ( pArea->nplayer > 0
db.c:    || count_obj_list( pObjIndex, pRoomIndex->contents ) > 0 )
db.c:      obj->cost = 0;
db.c:      if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_area: 'P': bad vnum %d.", pReset->arg1 );
db.c:      if ( !( pObjToIndex = get_obj_index( pReset->arg3 ) ) )
db.c:    bug( "Reset_area: 'P': bad vnum %d.", pReset->arg3 );
db.c:      if ( pArea->nplayer > 0
db.c:    || count_obj_list( pObjIndex, obj_to->contains ) > 0 )
db.c:      obj = create_object( pObjIndex, number_fuzzy( obj_to->level ) );
db.c:      if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_area: 'E' or 'G': bad vnum %d.", pReset->arg1 );
db.c:        pReset->arg1 );
db.c:      if ( mob->pIndexData->pShop )
db.c:    switch ( pObjIndex->item_type )
db.c:    case ITEM_WEAPON: if ( pReset->command == 'G' )
db.c:    if ( pReset->command == 'G' )
db.c:        SET_BIT( obj->extra_flags, ITEM_INVENTORY );
db.c:      if ( pReset->command == 'E' )
db.c:    equip_char( mob, obj, pReset->arg3 );
db.c:      if ( !( pMobIndex = get_mob_index( abs( pReset->arg1 ) ) ) )
db.c:    bug( "Reset_area: 'F': bad vnum %d.", pReset->arg1 );
db.c:      for( lch = char_list; lch; lch = lch->next )
db.c:      if ( lch->pIndexData == pMobIndex )
db.c:      if ( !( pMobIndex = get_mob_index( abs( pReset->arg3 ) ) ) )
db.c:    bug( "Reset_area: 'F': bad vnum %d.", pReset->arg3 );
db.c:      for( vch = char_list; vch; vch = vch->next )
db.c:      if ( vch->pIndexData == pMobIndex )
db.c:      if ( vch->master )
db.c:      vch->leader = lch;
db.c:      if ( !( pRoomIndex = get_room_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_area: 'D': bad vnum %d.", pReset->arg1 );
db.c:      if ( !( pexit = pRoomIndex->exit[pReset->arg2] ) )
db.c:      if ( !IS_SET( pexit->exit_info, EX_BASHED ) )
db.c:    switch ( pReset->arg3 )
db.c:        REMOVE_BIT( pexit->exit_info, EX_CLOSED );
db.c:        REMOVE_BIT( pexit->exit_info, EX_LOCKED );
db.c:        SET_BIT(  pexit->exit_info, EX_CLOSED );
db.c:        REMOVE_BIT( pexit->exit_info, EX_LOCKED );
db.c:        SET_BIT(  pexit->exit_info, EX_CLOSED );
db.c:        SET_BIT(  pexit->exit_info, EX_LOCKED );
db.c:      if ( !( pRoomIndex = get_room_index( pReset->arg1 ) ) )
db.c:    bug( "Reset_area: 'R': bad vnum %d.", pReset->arg1 );
db.c:    for ( d0 = 0; d0 < pReset->arg2 - 1; d0++ )
db.c:        d1       = number_range( d0, pReset->arg2-1 );
db.c:        pexit    = pRoomIndex->exit[d0];
db.c:        pRoomIndex->exit[d0] = pRoomIndex->exit[d1];
db.c:        pRoomIndex->exit[d1] = pexit;
db.c:    for ( vnum = pArea->lvnum; vnum <= pArea->uvnum; vnum++ )
db.c:  char_free = char_free->next;
db.c:      ch->pcdata  = alloc_mem( sizeof( *ch->pcdata ) );
db.c:      ch->pcdata  = pcdata_free;
db.c:      pcdata_free = pcdata_free->next;
db.c:  *ch->pcdata = pcdata_zero;
db.c:  ch->saving_throw[i] = 0;
db.c:    ch->deleted = FALSE;
db.c:    ch->mdr = 0;
db.c:    ch->dodge = 0;
db.c:    ch->pdr = 0;
db.c:    ch->pp = 0;
db.c:    ch->protector = NULL;
db.c:    ch->protecting = NULL;
db.c:    ch->next_in_protect = NULL;
db.c:    ch->tracking = NULL;
db.c:    ch->tracked = NULL;
db.c:    ch->next_in_track = NULL;
db.c:    ch->hunting = NULL;
db.c:    ch->hunted = NULL;
db.c:    ch->next_in_hunt = NULL;
db.c:    ch->rembch = NULL;
db.c:    ch->rembed = NULL;
db.c:    ch->rrembed = NULL;
db.c:    ch->next_in_rember = NULL;
db.c:    ch->assassinating = NULL;
db.c:    ch->assassinated = NULL;
db.c:    ch->next_in_ass = NULL;
db.c:    ch->perm_str = 0;
db.c:    ch->perm_dex = 0;
db.c:    ch->perm_int = 0;
db.c:    ch->perm_wis = 0;
db.c:    ch->perm_con = 0;
db.c:    ch->pad = 0;
db.c:    ch->mad = 0;
db.c:    ch->amdr = 0;
db.c:    ch->apdr = 0;
db.c:    ch->mod_str = 0;
db.c:    ch->mod_dex = 0;
db.c:    ch->mod_int = 0;
db.c:    ch->mod_wis = 0;
db.c:    ch->clan = NULL;
db.c:    ch->mod_con = 0;
db.c:    ch->group = NULL;
db.c:    affect_free = affect_free->next;
db.c:  obj_free = obj_free->next;
db.c:    obj->deleted = FALSE;
db.c:    obj->material = NULL;
db.c:    obj->vrace = NULL;
db.c:    obj->next = NULL;
db.c:    obj->next_content = NULL;
db.c:    obj->in_eqbank = FALSE;
db.c:    obj->in_room = NULL;
db.c:    obj->carried_by = NULL;
db.c:    obj->contains = NULL;
db.c:    obj->in_obj = NULL;
db.c:    obj->extra_descr = NULL;
db.c:    obj->affected = NULL;
db.c:    obj->pIndexData = NULL;
db.c:    obj->hp = NULL;
db.c:    obj->name = NULL;
db.c:    obj->short_descr = NULL;
db.c:    obj->description = NULL;
db.c:    obj->orembch = NULL;
db.c:    obj->next_in_orember = NULL;
db.c:    obj->value[0] = 0;
db.c:    obj->value[1] = 0;
db.c:    obj->value[2] = 0;
db.c:    obj->value[3] = 0;
db.c:    obj->value[4] = 0;
db.c:    ( obj->extra_value ).used = FALSE;   //Added by Razgriz 20050918
db.c:    ( obj->extra_value ).v[0] = 0;       //Added by Razgriz 20050918
db.c:    ( obj->extra_value ).v[1] = 0;       //Added by Razgriz 20050918
db.c:    ( obj->extra_value ).t[0] = -1;      //Added by Razgriz 20050918
db.c:    ( obj->extra_value ).t[1] = -1;      //Added by Razgriz 20050918
db.c:    extra_descr_free = extra_descr_free->next;
db.c:    mob->pIndexData = pMobIndex;
db.c:    mob->name   = str_dup( pMobIndex->player_name );
db.c:    mob->short_descr  = str_dup( pMobIndex->short_descr );
db.c:/*    mob->cname    = str_dup( pMobIndex->short_descr );*/
db.c:    mob->long_descr = str_dup( pMobIndex->long_descr  );
db.c:    mob->description  = str_dup( pMobIndex->description );
db.c:    mob->spec_fun = pMobIndex->spec_fun;
db.c:    mob->level    = number_fuzzy( pMobIndex->level );
db.c:    mob->act    = pMobIndex->act;
db.c:    mob->affected_by  = pMobIndex->affected_by;
db.c:    mob->alignment  = pMobIndex->alignment;
db.c:    mob->sex    = pMobIndex->sex;
db.c:    mob->race   = pMobIndex->race;
db.c:    mob->exp            = pMobIndex->mod_exp;
db.c:    mob->protecting = NULL;
db.c:    mob->special  = pMobIndex->special;
db.c:    mob->protector = NULL;
db.c:    mob->next_in_protect = NULL;
db.c:    mob->next = NULL;
db.c:    mob->rembch = NULL;
db.c:    mob->rembed = NULL;
db.c:    mob->next_in_rember = NULL;
db.c:    mob->rrembed = NULL;
db.c:  mob->clan = pMobIndex->area->clan;
db.c:    mob->weakness = pMobIndex->weakness;
db.c:    mob->pdr = pMobIndex->pdr;
db.c:    mob->mdr = pMobIndex->mdr;
db.c:    mob->pad = pMobIndex->pad;
db.c:    mob->mad = pMobIndex->mad;
db.c:    mob->apdr = pMobIndex->apdr;
db.c:    mob->amdr = pMobIndex->amdr;
db.c:  mob->track_times = 0;
db.c:  mob->attacked = NULL;
db.c:    if( IS_SET(mob->special, EXPERT ) ){
db.c:  value = 13 + race_table[mob->race].str_mod;
db.c:  mob->perm_str = UMIN( 25 /*MAX_STR*/, value + mob->level/5 );
db.c:  value = 13 + race_table[mob->race].int_mod;
db.c:  mob->perm_int = UMIN( 25 /*MAX_STR*/, value + mob->level/5 );
db.c:  value = 13 + race_table[mob->race].dex_mod;
db.c:  mob->perm_dex = UMIN( 25 /*MAX_STR*/, value + mob->level/5 );
db.c:  value = 13 + race_table[mob->race].wis_mod;
db.c:  mob->perm_wis = UMIN( 25 /*MAX_STR*/, value + mob->level/5 );
db.c:  value = 13 + race_table[mob->race].con_mod;
db.c:  mob->perm_con = UMIN( 25 /*MAX_STR*/, value + mob->level/5 );
db.c:  if ( ( mob->gold = pMobIndex->gold ) < 0 )
db.c:    mob->gold   = number_fuzzy( 50 )
db.c:      * number_fuzzy( pMobIndex->level )
db.c:      * UMAX( (mob->level / 7 ), 1 )
db.c:      * UMAX( (mob->level / 17 ), 1 )
db.c:      * number_range( race_table[ mob->race ].glow, race_table[ mob->race ].ghigh ) / 100;
db.c:  mob->armor    = pMobIndex->mod_ac + ( (mob->level>36) ? interpolate1(36, -40, 45, -290, mob->level-36) :
db.c:    interpolate( mob->level, 100, -80 ) )
db.c:      + ( ( mob->level > 30 ) ? race_table[ mob->race ].nature_ac : 40 );
db.c:  if( mob->level > 45 ) mob->armor -= mob->level * 4;
db.c:  if( mob->level > 55 ) mob->armor -= mob->level * 2;
db.c:  mob->dodge    = pMobIndex->dodge + ( (mob->level>36) ? 
db.c:    interpolate1(36, 0, 44, -140, mob->level-36) :
db.c:    interpolate( mob->level, 250,-90) )
db.c:      + ( ( mob->level > 30 ) ? race_table[ mob->race ].nature_dodge : 0 );
db.c:  if( mob->level > 54 ) mob->dodge = mob->dodge - (mob->level/6);
db.c:  if( mob->level > 59 ) mob->dodge = mob->dodge - (mob->level/5);
db.c:  mob->max_hit  = pMobIndex->mod_hitplus + 
db.c:      number_range( mob->level * mob->level / 2, 
db.c:        mob->level * (mob->level + mob->level /2 ) ) +
db.c:      ( ( mob->level > 30 ) ? mob->level * 60 : mob->level * 10 );
db.c:  if( mob->level > 49 )
db.c:      mob->max_hit += mob->level * 15;
db.c:  if( mob->level > 54 )
db.c:      mob->max_hit += mob->level * 20;
db.c:  mob->hit    = mob->max_hit;
db.c:  mob->max_mana = mob->max_hit / 2;
db.c:  mob->mana = mob->max_mana;
db.c:  mob->hitroll  = pMobIndex->mod_hitroll + ( (mob->level>28) ? interpolate1(28, 30, 45, 40, mob->level-28) :
db.c:    interpolate(mob->level, 5, 25) );
db.c:  mob->damroll  = pMobIndex->mod_damroll + ( (mob->level > 30) ? interpolate1(30, 40, 40, 65, mob->level-30) : 
db.c:    interpolate(mob->level, 3, 50) );
db.c:      mob->saving_throw[i]  = pMobIndex->mod_svs[i] + ( (mob->level>42) ? interpolate1(42, -15, 60, -20, mob->level-42) :
db.c:        interpolate(mob->level, 5, -15) );
db.c:      mob->saving_throw[i] += race_table[pMobIndex->race].nature_svs[i];
db.c:  value = 13 + race_table[mob->race].str_mod;
db.c:  mob->perm_str = UMIN( 25 /*MAX_STR*/, value + mob->level/8 );
db.c:  value = 13 + race_table[mob->race].int_mod;
db.c:  mob->perm_int = UMIN( 25 /*MAX_STR*/, value + mob->level/8 );
db.c:  value = 13 + race_table[mob->race].dex_mod;
db.c:  mob->perm_dex = UMIN( 25 /*MAX_STR*/, value + mob->level/8 );
db.c:  value = 13 + race_table[mob->race].wis_mod;
db.c:  mob->perm_wis = UMIN( 25 /*MAX_STR*/, value + mob->level/8 );
db.c:  value = 13 + race_table[mob->race].con_mod;
db.c:  mob->perm_con = UMIN( 25 /*MAX_STR*/, value + mob->level/8 );
db.c:  if ( ( mob->gold = pMobIndex->gold ) < 0 )
db.c:    mob->gold   = number_fuzzy( 50 )
db.c:      * number_fuzzy( pMobIndex->level )
db.c:      * UMAX( (mob->level / 9 ), 1 )
db.c:      * UMAX( (mob->level / 20 ), 1 )
db.c:      * number_range( race_table[ mob->race ].glow, race_table[ mob->race ].ghigh ) / 100;
db.c:  mob->armor    = pMobIndex->mod_ac + ( (mob->level>36) ? interpolate1(36, -20, 45, -200, mob->level-36) :
db.c:    interpolate( mob->level, 110, -60 ) )
db.c:      + ( ( mob->level > 36 ) ? race_table[ mob->race ].nature_ac : 60 );
db.c:  if( mob->level > 45 ) mob->armor -= mob->level * 4;
db.c:  mob->dodge    = pMobIndex->dodge + ( (mob->level>34) ? interpolate1(34, 60, 44, -90, mob->level-34) :
db.c:    interpolate( mob->level, 300, 0 ) )
db.c:      + ( ( mob->level > 36 ) ? race_table[ mob->race ].nature_dodge : 0 );
db.c:  mob->max_hit  = pMobIndex->mod_hitplus + 
db.c:      number_range( mob->level * mob->level / 2, 
db.c:        mob->level * mob->level ) +
db.c:      ( ( mob->level > 34 ) ? mob->level * 45 : mob->level * 10 );
db.c:  mob->hit    = mob->max_hit;
db.c:  mob->max_mana = UMAX( 50, mob->max_hit / 5);
db.c:  mob->mana = mob->max_mana;
db.c:  mob->hitroll  = pMobIndex->mod_hitroll + ( (mob->level>28) ? interpolate1(28, 20, 45, 30, mob->level-28) :
db.c:    interpolate(mob->level, 5, 25) );
db.c:  mob->damroll  = pMobIndex->mod_damroll + ( (mob->level > 33) ? interpolate1(33, 35, 40, 47, mob->level-33) : 
db.c:    interpolate(mob->level, 3, 50) );
db.c:      mob->saving_throw[i]  = pMobIndex->mod_svs[i] + ( (mob->level>42) ? interpolate1(42, -8, 60, -20, mob->level-42) :
db.c:        interpolate(mob->level, 5, -15) );
db.c:      mob->saving_throw[i] += race_table[pMobIndex->race].nature_svs[i];
db.c:  mob->max_move = mob->max_mana;
db.c:  mob->move   = mob->mana;
db.c:  mob->pp     = pMobIndex->mod_pp;
db.c:    mob->class    = pMobIndex->class;
db.c:    mob->psk    = pMobIndex->psk;
db.c:    mob->jcl    = pMobIndex->jcl;
db.c:    mob->armor = ( mob->armor * 6) / 5;
db.c:    if ( ( pmob_action = pMobIndex->mob_action ) )
db.c:      mob_action_free = mob_action_free->next_in_list;
db.c:    if ( !mob->mob_action )/* used in free_char() */
db.c:      mob->mob_action = mob_action;
db.c:    mob_action->owner = mob;
db.c:    mob_action->com_list = pmob_action->com_list;
db.c:    mob_action->old_com_list = pmob_action->com_list;
db.c:    mob_action->start_time = pmob_action->start_time;
db.c:    mob_action->mode = 0;
db.c:    mob_action->next = NULL;
db.c:      mob_action_list->prev_in_list = mob_action;
db.c:      if ( mob_action_list->owner == mob )
db.c:        mob_action_list->next = mob_action;
db.c:    mob_action->next_in_list = mob_action_list;
db.c:    pmob_action = pmob_action->next;
db.c:        if ( mob->pIndexData->fAutoset )
db.c:           mob->pdr    = (int) ( mob->perm_con * 8 + mob->level * 2 ) / 3; //pdr
db.c:           mob->mdr    = (int) ( mob->perm_wis * 4 +
db.c:                                 mob->perm_con * 4 + mob->level * 2 ) / 3; //mdr
db.c:           mob->apdr   = (int) ( mob->perm_str * 6 + mob->level * 4 ) / 4; //pd
db.c:           mob->amdr   = (int) ( mob->perm_int * 6 + mob->level * 4 ) / 4; //md
db.c:           mob->pp     = (int) ( mob->perm_wis * 2 + mob->level     ) / 2; //pp
db.c:    mob->next   = char_list;
db.c:    pMobIndex->count++;
db.c:    if( IS_SET(pObjIndex->extra_flags, ITEM_UNIQUE)) {
db.c:  if( ( obj = get_obj_index_vnum( pObjIndex->vnum ) )) {
db.c:      tmp = get_obj_index( pObjIndex->replica );
db.c:    bug( "Create_object: Unique weapon without replica. %d", pObjIndex->vnum);
db.c:    obj->pIndexData = pObjIndex;
db.c:    obj->in_room  = NULL;
db.c:    //if ( pObjIndex->level )
db.c:    //  obj->level  = pObjIndex->level;
db.c:    //obj->level    = level;
db.c:    obj->wear_loc = -1;
db.c:    if( !pObjIndex->material )
db.c:  pObjIndex->material = material_lookup( "Generic");
db.c:    obj->material = pObjIndex->material;
db.c:    obj->level = UMAX( level, pObjIndex->level );
db.c:    obj->level    = UMAX( obj->level, obj->material->level );
db.c:    //obj->level    = UMIN( 38, obj->level );
db.c:                obj->level = 40;
db.c:                obj->level = number_range( 36, 39 );//LEVEL_IMMORTAL - 2, LEVEL_HERO );
db.c:                obj->level = number_range( 36, 38 );//LEVEL_IMMORTAL - 2, LEVEL_HERO );
db.c:    obj->name   = str_dup( pObjIndex->name    );
db.c:    obj->short_descr  = str_dup( pObjIndex->short_descr );
db.c:/*    obj->cname    = str_dup( pObjIndex->cname );*/
db.c:    obj->description  = str_dup( pObjIndex->description );
db.c:    obj->item_type  = pObjIndex->item_type;
db.c:    obj->extra_flags  = pObjIndex->extra_flags;
db.c:    obj->wear_flags = pObjIndex->wear_flags;
db.c:    obj->value[0] = pObjIndex->value[0];
db.c:    obj->value[1] = pObjIndex->value[1];
db.c:    obj->value[2] = pObjIndex->value[2];
db.c:    obj->value[3] = pObjIndex->value[3];
db.c:    obj->weight   = pObjIndex->weight;
db.c:    obj->serial   = time(NULL);
db.c:    obj->vrace    = pObjIndex->vrace;
db.c:    if ( pObjIndex->cost )
db.c:      obj->cost = pObjIndex->cost;
db.c:  obj->cost   = number_fuzzy( 4 )
db.c:    obj->timer    = pObjIndex->timer;
db.c:    obj->class    = pObjIndex->class;
db.c:    obj->race   = pObjIndex->race;
db.c:  if ( pObjIndex->hp ){
db.c:    for( php = pObjIndex->hp; php; php = php->next )
db.c:      hp->vnum  = pObjIndex->vnum;
db.c:      hp->hp_name = str_dup( php->hp_name );
db.c:      hp->percent = php->percent;
db.c:      hp->level = php->level;
db.c:      hp->event = php->event;
db.c:      hp->next  = obj->hp;
db.c:      obj->hp   = hp;
db.c:    obj->deleted  = FALSE;
db.c:    // material-depedent hack
db.c:    obj->cost   = (obj->cost * obj->material->cost) / 100;
db.c:    obj->extra_flags  |= obj->material->extra_flags;
db.c:    switch ( obj->item_type )
db.c:  bug( "Read_object: vnum %d bad type.", pObjIndex->vnum );
db.c:  dmgbase = level  + obj->weight / 3 ;
db.c:  if( obj->value[1] == 0 )
db.c:      obj->value[1] = number_fuzzy( number_fuzzy( dmgbase ) );
db.c:      //bugf("arrow [%d] has value1 != 0 ", pObjIndex->vnum);
db.c:      dmgbase = obj->value[1];
db.c:      obj->value[1] = number_fuzzy( number_fuzzy( dmgbase ) - 2);
db.c:  if( obj->value[2] == 0 )
db.c:      obj->value[2] = number_fuzzy( number_fuzzy( dmgbase  ) + 6);
db.c:      //bugf("arrow [%d] has value2 != 0 ", pObjIndex->vnum);
db.c:      dmgbase = obj->value[2];
db.c:      //obj->value[2] = number_fuzzy( number_fuzzy( dmgbase + 6 ) );
db.c:  if( IS_SET(obj->extra_flags, ITEM_EVIL)){
db.c:      dmgbase = (obj->level/9) + 1;
db.c:      obj->value[1] += dmgbase;
db.c:      obj->value[2] += dmgbase;
db.c:  obj->value[0] = number_fuzzy( obj->value[0] );
db.c:  obj->value[0] = number_fuzzy( obj->value[0] );
db.c:  obj->value[1] = number_fuzzy( obj->value[1] );
db.c:  obj->value[2] = obj->value[1];
db.c:  weight = obj->weight * 2;
db.c:  switch( obj->value[3] ) {
db.c:  if( obj->value[1] == 0 )
db.c:      obj->value[1] = number_fuzzy( number_fuzzy( dmgbase ) );
db.c:      //bugf("weapon [%d] has value1 != 0 ", pObjIndex->vnum);
db.c:      dmgbase = obj->value[1];
db.c:      obj->value[1] = number_fuzzy( number_fuzzy( dmgbase ) );
db.c:  if( obj->value[2] == 0 )
db.c:      obj->value[2] = number_fuzzy( number_fuzzy( dmgbase + avgdif ) );
db.c:      //bugf("weapon [%d] has value2 != 0 ", pObjIndex->vnum);
db.c:      dmgbase = obj->value[2];
db.c:      obj->value[2] = number_fuzzy( number_fuzzy( dmgbase + avgdif ) );
db.c:  switch( obj->value[3] ) {
db.c:    obj->value[1] += 1;
db.c:    obj->value[2] -= 1;
db.c:    obj->value[1] -= 3;
db.c:    obj->value[2] += 3;
db.c:    obj->value[1] -= 1;
db.c:    obj->value[2] += 1;
db.c:    obj->value[1] -= 5;
db.c:    obj->value[2] -= 2;
db.c:    obj->value[1] += 2;
db.c:    obj->value[2] -= 2;
db.c:    obj->value[1] += 2;
db.c:    obj->value[2] += 4;
db.c:    obj->value[1] -= 1;
db.c:    obj->value[2] += 2;
db.c:    obj->value[1] += 3;
db.c:    obj->value[2] += 1;
db.c:    obj->value[1] -= 1;
db.c:    obj->value[2] -= 1;
db.c:    obj->value[1] += 2;
db.c:    obj->value[2] -= 1;
db.c:    obj->value[1] += 3;
db.c:    obj->value[2] -= 1;
db.c:    obj->value[1] -= 2;
db.c:    obj->value[2] += 1;
db.c:    obj->value[1] += 1;
db.c:    obj->value[2] += 4;
db.c:  if( IS_SET(obj->extra_flags, ITEM_EVIL)){
db.c:      dmgbase = (obj->level/9) + 1;
db.c:      obj->value[1] += dmgbase;
db.c:      obj->value[2] += dmgbase;
db.c:  if( obj->value[0] == DURA_AUTO ){
db.c:      obj->value[0] = obj->material->value[3];
db.c:  else if( obj->value[0] >= DURA_MAX ) {
db.c:            int du = obj->value[0];
db.c:            du -= ( du % 10000 );
db.c:            obj->value[0] = du ;
db.c:  if( obj->value[0] == 0 ){
db.c:      obj->value[0] = number_fuzzy( level / 4 + 2 );
db.c:      if( obj->level >= 38 && obj->value[0] == 12){ 
db.c:        obj->value[0] = 13;
db.c:        obj->value[0] = 14;
db.c:      //bug("armor [%d] has value0 != 0 ", pObjIndex->vnum);
db.c:      //obj->value[0] = number_fuzzy( level / 4 + 2 );
db.c:      if( obj->level >= 38 && obj->value[0] == 12){ 
db.c:        obj->value[0] = 13;
db.c:        obj->value[0] = 14;
db.c:  if( IS_SET(obj->extra_flags, ITEM_HOLY)){
db.c:      obj->value[0] += (obj->level / 13) +1;
db.c:      if( obj->level >= 38 && number_bits( 13 ) == 1)
db.c:    obj->value[0] = UMIN( obj->value[0], 15);
db.c:      else if ( obj->level >= 36 && number_bits( 5 ) == 1)
db.c:    obj->value[0] = UMIN( obj->value[0], 14);
db.c:    obj->value[0] = UMIN( obj->value[0], 13);
db.c:  if( obj->value[2] == DURA_AUTO ) {
db.c:      obj->value[2] = obj->material->value[3];
db.c:  else if( obj->value[2] >= DURA_MAX ) {
db.c:            int du = obj->value[2];
db.c:            du -= ( du % 10000 );
db.c:            obj->value[2] = du ;
db.c:  obj->value[0] = number_fuzzy( number_fuzzy( obj->value[0] ) );
db.c:  obj->value[0] = obj->cost;
db.c:    obj->weight   = (obj->weight * obj->material->weight) / 100;
db.c:    obj->next   = object_list;
db.c:    pObjIndex->count++;
db.c:    if( IS_SET(pObjIndex->extra_flags, ITEM_UNIQUE)) {
db.c:  if( ( obj = get_obj_index_vnum( pObjIndex->vnum ) )) {
db.c:      tmp = get_obj_index( pObjIndex->replica );
db.c:    bug( "Create_object: Unique weapon without replica. %d", pObjIndex->vnum);
db.c:    obj->pIndexData = pObjIndex;
db.c:    obj->in_room  = NULL;
db.c:    //if ( pObjIndex->level )
db.c:    //  obj->level  = pObjIndex->level;
db.c:    //obj->level    = level;
db.c:    //obj->level = UMAX( level, pObjIndex->level );
db.c:    obj->level = level;
db.c:    obj->wear_loc = -1;
db.c:    if( !pObjIndex->material )
db.c:  pObjIndex->material = material_lookup( "Generic");
db.c:    obj->material = pObjIndex->material;
db.c:   // obj->level    = UMAX( obj->level, obj->material->level );
db.c:    //obj->level    = UMIN( 38, obj->level );
db.c:    //if( obj->level < LEVEL_HERO + 1 && obj->level > LEVEL_HERO - 3) {
db.c://  obj->level = number_range( LEVEL_HERO - 5, LEVEL_HERO );
db.c:    obj->name   = str_dup( pObjIndex->name    );
db.c:    obj->short_descr  = str_dup( pObjIndex->short_descr );
db.c:/*    obj->cname    = str_dup( pObjIndex->cname );*/
db.c:    obj->description  = str_dup( pObjIndex->description );
db.c:    obj->item_type  = pObjIndex->item_type;
db.c:    obj->extra_flags  = pObjIndex->extra_flags;
db.c:    obj->wear_flags = pObjIndex->wear_flags;
db.c:    obj->value[0] = pObjIndex->value[0];
db.c:    obj->value[1] = pObjIndex->value[1];
db.c:    obj->value[2] = pObjIndex->value[2];
db.c:    obj->value[3] = pObjIndex->value[3];
db.c:    obj->weight   = pObjIndex->weight;
db.c:    obj->serial   = time(NULL);
db.c:    obj->vrace    = pObjIndex->vrace;
db.c:    if ( pObjIndex->cost )
db.c:      obj->cost = pObjIndex->cost;
db.c:  obj->cost   = number_fuzzy( 4 )
db.c:    obj->timer    = pObjIndex->timer;
db.c:    obj->class    = pObjIndex->class;
db.c:    obj->race   = pObjIndex->race;
db.c:  if ( pObjIndex->hp ){
db.c:    for( php = pObjIndex->hp; php; php = php->next )
db.c:      hp->vnum  = pObjIndex->vnum;
db.c:      hp->hp_name = str_dup( php->hp_name );
db.c:      hp->percent = php->percent;
db.c:      hp->level = php->level;
db.c:      hp->event = php->event;
db.c:      hp->next  = obj->hp;
db.c:      obj->hp   = hp;
db.c:    obj->deleted  = FALSE;
db.c:    // material-depedent hack
db.c:    obj->cost   = (obj->cost * obj->material->cost) / 100;
db.c:    obj->extra_flags  |= obj->material->extra_flags;
db.c:    switch ( obj->item_type )
db.c:  bug( "Read_object: vnum %d bad type.", pObjIndex->vnum );
db.c:  dmgbase = level  + obj->weight / 3 ;
db.c:  if( obj->value[1] == 0 )
db.c:      obj->value[1] = number_fuzzy( number_fuzzy( dmgbase ) );
db.c:      //bugf("arrow [%d] has value1 != 0 ", pObjIndex->vnum);
db.c:      dmgbase = obj->value[1];
db.c:      obj->value[1] = number_fuzzy( number_fuzzy( dmgbase ) - 2);
db.c:  if( obj->value[2] == 0 )
db.c:      obj->value[2] = number_fuzzy( number_fuzzy( dmgbase  ) + 6);
db.c:      //bugf("arrow [%d] has value2 != 0 ", pObjIndex->vnum);
db.c:      dmgbase = obj->value[2];
db.c:      //obj->value[2] = number_fuzzy( number_fuzzy( dmgbase + 6 ) );
db.c:  if( IS_SET(obj->extra_flags, ITEM_EVIL)){
db.c:      dmgbase = (obj->level/9) + 1;
db.c:      obj->value[1] += dmgbase;
db.c:      obj->value[2] += dmgbase;
db.c:  obj->value[0] = number_fuzzy( obj->value[0] );
db.c:  obj->value[0] = number_fuzzy( obj->value[0] );
db.c:  obj->value[1] = number_fuzzy( obj->value[1] );
db.c:  obj->value[2] = obj->value[1];
db.c:  weight = obj->weight * 2;
db.c:  switch( obj->value[3] ) {
db.c:  if( obj->value[1] == 0 )
db.c:      obj->value[1] = number_fuzzy( number_fuzzy( dmgbase ) );
db.c:      //bugf("weapon [%d] has value1 != 0 ", pObjIndex->vnum);
db.c:      dmgbase = obj->value[1];
db.c:      obj->value[1] = number_fuzzy( number_fuzzy( dmgbase ) );
db.c:  if( obj->value[2] == 0 )
db.c:      obj->value[2] = number_fuzzy( number_fuzzy( dmgbase + avgdif ) );
db.c:      //bugf("weapon [%d] has value2 != 0 ", pObjIndex->vnum);
db.c:      dmgbase = obj->value[2];
db.c:      obj->value[2] = number_fuzzy( number_fuzzy( dmgbase + avgdif ) );
db.c:  switch( obj->value[3] ) {
db.c:    obj->value[1] += 1;
db.c:    obj->value[2] -= 1;
db.c:    obj->value[1] -= 3;
db.c:    obj->value[2] += 3;
db.c:    obj->value[1] -= 1;
db.c:    obj->value[2] += 1;
db.c:    obj->value[1] -= 5;
db.c:    obj->value[2] -= 2;
db.c:    obj->value[1] += 2;
db.c:    obj->value[2] -= 2;
db.c:    obj->value[1] += 2;
db.c:    obj->value[2] += 4;
db.c:    obj->value[1] -= 1;
db.c:    obj->value[2] += 2;
db.c:    obj->value[1] += 3;
db.c:    obj->value[2] += 1;
db.c:    obj->value[1] -= 1;
db.c:    obj->value[2] -= 1;
db.c:    obj->value[1] += 2;
db.c:    obj->value[2] -= 1;
db.c:    obj->value[1] += 3;
db.c:    obj->value[2] -= 1;
db.c:    obj->value[1] -= 2;
db.c:    obj->value[2] += 1;
db.c:    obj->value[1] += 1;
db.c:    obj->value[2] += 4;
db.c:  if( IS_SET(obj->extra_flags, ITEM_EVIL)){
db.c:      dmgbase = (obj->level/9) + 1;
db.c:      obj->value[1] += dmgbase;
db.c:      obj->value[2] += dmgbase;
db.c:  if( obj->value[0] == DURA_AUTO ){
db.c:      obj->value[0] = obj->material->value[3];
db.c:  else if( obj->value[0] > DURA_MAX ) {
db.c:            int du = obj->value[0];
db.c:            du -= ( du % 10000 );
db.c:            obj->value[0] = du ;
db.c:  if( obj->value[0] == 0 ){
db.c:      obj->value[0] = number_fuzzy( level / 4 + 2 );
db.c:      if( obj->level >= 38 && obj->value[0] == 12){ 
db.c:        obj->value[0] = 13;
db.c:        obj->value[0] = 14;
db.c:      //bug("armor [%d] has value0 != 0 ", pObjIndex->vnum);
db.c:      //obj->value[0] = number_fuzzy( level / 4 + 2 );
db.c:      if( obj->level >= 38 && obj->value[0] == 12){ 
db.c:        obj->value[0] = 13;
db.c:        obj->value[0] = 14;
db.c:  if( IS_SET(obj->extra_flags, ITEM_HOLY)){
db.c:      obj->value[0] += (obj->level / 13) +1;
db.c:      if( obj->level >= 38 && number_bits( 10 ) == 1)
db.c:    obj->value[0] = UMIN( obj->value[0], 15);
db.c:      else if ( obj->level >= 38 )
db.c:    obj->value[0] = UMIN( obj->value[0], 14);
db.c:    obj->value[0] = UMIN( obj->value[0], 13);
db.c:  if( obj->value[2] == DURA_AUTO ) {
db.c:      obj->value[2] = obj->material->value[3];
db.c:        else if( obj->value[2] > DURA_MAX ) {
db.c:            int du = obj->value[2];
db.c:            du -= ( du % 10000 );
db.c:            obj->value[2] = du ;
db.c:  obj->value[0] = number_fuzzy( number_fuzzy( obj->value[0] ) );
db.c:  obj->value[0] = obj->cost;
db.c:    obj->weight   = (obj->weight * obj->material->weight) / 100;
db.c:    obj->next   = object_list;
db.c:    pObjIndex->count++;
db.c:    ch->name      = &str_empty[0];
db.c:/*    ch->cname     = &str_empty[0];*/
db.c:    ch->short_descr   = &str_empty[0];
db.c:    ch->long_descr    = &str_empty[0];
db.c:    ch->description   = &str_empty[0];
db.c:    ch->last_note   = 0;
db.c:    ch->logon     = current_time;
db.c:    ch->armor     = 100;
db.c:    ch->position    = POS_STANDING;
db.c:    ch->level     = 0;
db.c:    ch->race      = 0;
db.c:    ch->practice    = 21;
db.c:    ch->hit     = 20;
db.c:    ch->max_hit     = 20;
db.c:    ch->mana      = 100;
db.c:    ch->max_mana    = 100;
db.c:    ch->move      = 100;
db.c:    ch->max_move    = 100;
db.c:    ch->leader      = NULL;
db.c:    ch->master      = NULL;
db.c:    ch->deleted     = FALSE;
db.c:    ch->protecting = NULL;
db.c:    ch->protector = NULL;
db.c:    ch->next_in_protect = NULL;
db.c:    ch->hunting = NULL;
db.c:    ch->hunted = NULL;
db.c:    ch->next_in_hunt = NULL;
db.c:    ch->tracking = NULL;
db.c:    ch->tracked = NULL;
db.c:    ch->next_in_track = NULL;
db.c:    ch->assassinating = NULL;
db.c:    ch->assassinated = NULL;
db.c:    ch->next_in_ass = NULL;
db.c:    ch->rembch = NULL;
db.c:    ch->rembed = NULL;
db.c:    ch->rrembed = NULL;
db.c:    ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
db.c:    for ( obj = ch->carrying; obj; obj = obj_next ){
db.c:        obj_next = obj->next_content;
db.c:        if ( obj->deleted ) continue;
db.c:    for ( paf = ch->affected; paf; paf = paf->next ){
db.c:        if ( paf->deleted ) continue;
db.c:    if ( qmark = ch->qmark ){
db.c:          qmark_next = qmark->next;
db.c:    free_string( ch->name   );
db.c:    free_string( ch->short_descr  );
db.c:    free_string( ch->cname    );
db.c:    free_string( ch->long_descr   );
db.c:    free_string( ch->description  );
db.c:    if ( ch->pcdata ){
db.c:        free_string( ch->pcdata->pwd    );
db.c:        free_string( ch->pcdata->bamfin   );
db.c:        free_string( ch->pcdata->bamfout  );
db.c:        free_string( ch->pcdata->immskll  );
db.c:        free_string( ch->pcdata->title    );
db.c:        free_string( ch->pcdata->prompt   );
db.c:        free_string( ch->pcdata->clantitle  );
db.c:        ch->pcdata->ride = 0;
db.c:        ch->pcdata->horse = NULL;
db.c:        if ( ch->pcdata->ba ){
db.c:            free_string( ch->pcdata->ba->ba11 );
db.c:            free_string( ch->pcdata->ba->ba12 );
db.c:            free_string( ch->pcdata->ba->ba13 );
db.c:            free_string( ch->pcdata->ba->ba21 );
db.c:            free_string( ch->pcdata->ba->ba22 );
db.c:            free_string( ch->pcdata->ba->ba23 );
db.c:            free_string( ch->pcdata->ba->ba31 );
db.c:            free_string( ch->pcdata->ba->ba32 );
db.c:            free_string( ch->pcdata->ba->ba33 );
db.c:            ch->pcdata->ba->next = ba_free;
db.c:            ba_free = ch->pcdata->ba;
db.c:            ch->pcdata->ba = NULL;      
db.c:        ch->pcdata->next = pcdata_free;
db.c:        pcdata_free  = ch->pcdata;
db.c:    if ( ( mob_action = ch->mob_action ) ){
db.c://  for ( mob_action = mob_action_list; mob_action; mob_action = mob_action->next_in_list )
db.c://          if ( mob_action->owner == ch )
db.c:            if ( mob_action->prev_in_list ){
db.c:                mob_action->prev_in_list->next_in_list = mob_action->next_in_list;
db.c:                if ( mob_action->next_in_list )
db.c:                    mob_action->next_in_list->prev_in_list = mob_action->prev_in_list;
db.c:                mob_action_list = mob_action->next_in_list;
db.c:                if ( mob_action->next_in_list )
db.c:                    mob_action->next_in_list->prev_in_list = NULL;
db.c:            mob_action->owner = NULL;
db.c:            mob_action->prev_in_list = NULL;
db.c:            mob_action->next_in_list = mob_action_free;
db.c:            mob_action = mob_action->next;
db.c:    ch->next       = char_free;
db.c:    for ( ; ed; ed = ed->next )
db.c:  if ( is_name( name, ed->keyword ) )
db.c:      return ed->description;
db.c:    for ( ; ed; ed = ed->next )
db.c:  if ( is_pfxname( name, ed->keyword ) )
db.c:      return ed->description;
db.c:   * Trapping suggested by Erwin Andreasen  -Kahn
db.c:       pMobIndex  = pMobIndex->next )
db.c:     if( pMobIndex->vnum == vnum )
db.c:     * Trapping suggested by Erwin Andreasen  -Kahn
db.c:    pObjIndex  = pObjIndex->next )
db.c:  if ( pObjIndex->vnum == vnum )
db.c:     * Trapping suggested by Erwin Andreasen  -Kahn
db.c:    pRoomIndex  = pRoomIndex->next )
db.c:  if ( pRoomIndex->vnum == vnum )
db.c:        pArea2 = pArea2->next;
db.c:    { bug( ch->name, 0 );
db.c:"-----------------------------------------+---------------------------------\n\r");
db.c:        strncpy( buf_an, pArea1->name, 26);
db.c:        sprintf( buf2, "%-27s%-7s", buf_an, (pArea1->clan) ? pArea1->translator : pArea1->builders);
db.c:        sprintf( buf2, "%-27s%-7s", buf_an, pArea1->translator);
db.c:        sprintf( buf2, "%-27s%-7s", buf_an, pArea1->modifier);
db.c:        strncpy( buf_an, pArea2->name, 26);
db.c:            sprintf( buf3, "%-27s%-7s", buf_an, (pArea2->clan) ? pArea2->translator : pArea2->builders);
db.c:            sprintf( buf3, "%-27s%-7s", buf_an, pArea2->translator);
db.c:            sprintf( buf3, "%-27s%-7s", buf_an, pArea2->modifier);
db.c:    sprintf( buf, "%-37s|%-37s\n\r", buf2, buf3 );
db.c:    pArea1 = pArea1->next;
db.c:        pArea2 = pArea2->next;
db.c:"-----------------------------------------+----------------------------------\n\r");
db.c:    case 0:  number -= 1; break;
db.c:    if ( ( to = to - from + 1 ) <= 1 )
db.c:    while ( ( number = number_mm( ) & ( power - 1 ) ) >= to )
db.c:    while ( ( door = number_mm( ) & ( 8-1 ) ) > 5 )
db.c:    return number_mm( ) & ( ( 1 << width ) - 1 );
db.c: * I've gotten too many bad reports on OS-supplied random number generators.
db.c: * This is the Mitchell-Moore algorithm from Knuth Volume II.
db.c: * -- Furey
db.c:    piState[-2] = 55 - 55;
db.c:    piState[-1] = 55 - 24;
db.c:    piState[0]  = ( (int) current_time ) & ( ( 1 << 30 ) - 1 );
db.c:        piState[iState] = (  piState[iState-1] + piState[iState-2] )
db.c:                           & ( ( 1 << 30 ) - 1 );
db.c:    iState1   = piState[-2];
db.c:    iState2   = piState[-1];
db.c:      & ( ( 1 << 30 ) - 1 );
db.c:    piState[-2]   = iState1;
db.c:    piState[-1]   = iState2;
db.c:    return value_00 + level * ( value_42 - value_00 ) / 42;
db.c:    return value1 + level * ( value2 - value1 ) / ( level2 - level1 );
db.c:    ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c:    strtime[strlen( strtime )-1] = '\0';
db.c: * -- Furey
db.c:*   * Got it from Erwin S.A. source - Zen
db.c:    if( ch->clan ) return FALSE;
fight.c://*---------------------------------------------------------------*
fight.c://*---------------------------------------------------------------*
fight.c://*---------------------------------------------------------------*
fight.c://*---------------------------------------------------------------*
fight.c://*---------------------------------------------------------------*
fight.c://*  PURPOSE     :         ­×§ï violence_update(),¦b ch->wait ¬° 0*
fight.c://*              :         ®É, ²¾±¼ qmark -- earthquake_stun      *
fight.c://*---------------------------------------------------------------*
fight.c://*              :         ¤@¤è­±, ¥[¤W¹ï qmark -- earthquake_stun*
fight.c://*---------------------------------------------------------------*
fight.c://*---------------------------------------------------------------*
fight.c://*---------------------------------------------------------------*
fight.c:  for ( ch = char_list; ch; ch = ch->next )
fight.c:    if ( !ch->in_room || ch->deleted )
fight.c:      if( ch->fighting && ch->position == POS_RESTING ){
fight.c:        ch->position = POS_FIGHTING;
fight.c:        ch->wait += 9;
fight.c:      if( ch->wait ){
fight.c:        ch->wait = UMAX( 0, ch->wait - 9 );
fight.c:    if ( !ch->desc  ) {
fight.c:      if( ch->wait ){
fight.c:        ch->wait = UMAX( 0, ch->wait - 6 );
fight.c:      if( ch->fighting && ch->position == POS_RESTING ){
fight.c:        ch->position = POS_FIGHTING;
fight.c:        ch->wait += 6;
fight.c:    if ( ( victim = ch->fighting ) )
fight.c:      if ( victim->deleted || ch->in_room != victim->in_room )
fight.c:      if( IS_SET(ch->in_room->room_flags, ROOM_SAFE ) ) {
fight.c:      if( ch->master == victim ) {
fight.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
fight.c:      if( victim->master == ch ) {
fight.c:        if(victim->pIndexData != NULL && IsSorGateMob(victim->pIndexData->vnum)){
fight.c:      if ( IS_SET( race_table[ ch->race ].race_abilities, RACE_VAMPIRE )
fight.c:            ( !IS_NPC( victim ) && victim->pcdata->clanpk 
fight.c:              && IS_SET(victim->in_room->room_flags, ROOM_PK) ) )
fight.c:          ch->hit += ch->level / 4 + nRaceSklv + nRaceSklv * nRaceSklv / 2;
fight.c:          ch->hit += ch->level + nRaceSklv * 5 + nRaceSklv * nRaceSklv * 2;
fight.c:        ch->hit = UMIN( ch->hit, ch->max_hit);
fight.c:        //      ch->hit = ( ch->hit > ch->max_hit ) ? ch->max_hit : ch->hit;
fight.c:            ( !IS_NPC( victim ) && victim->pcdata->clanpk 
fight.c:              && IS_SET(victim->in_room->room_flags, ROOM_PK) ) )
fight.c:          ch->hit += ch->level / 4 + nRaceSklv + nRaceSklv * nRaceSklv / 2;
fight.c:          ch->hit += ch->level + nRaceSklv * 5 + nRaceSklv * nRaceSklv * 2;
fight.c:        ch->hit = UMIN( ch->hit, ch->max_hit);
fight.c:				ch->mana -= 8 + nRaceSklv * 2;
fight.c:				if(ch->mana < 0){
fight.c:					ch->mana = 0;
fight.c:        ch->hit = UMIN( ch->max_hit, ch->hit + ch->level );
fight.c:            && (        IS_SET( race_table[ ch->race ].race_abilities, RACE_REGENERACY )
fight.c:                  || (  IS_NPC( ch ) && IS_SET( ch->act, ACT_REGENERACY ) )
fight.c:                  || ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_regeneracy] > 0 ) ) && ch != victim )
fight.c:          ch->hit += ch->level * 10;
fight.c:          if ( ch->hit > ch->max_hit )
fight.c:            ch->hit = ch->max_hit;
fight.c:        else if ( ch != ch->fighting )
fight.c:          int difflv = victim->level - ( ch->level > 36 ? 36 : ch->level ) + UMAX(0, sklv - 4) * 2;
fight.c:          if( IS_SET( race_table[ ch->race ].race_abilities, RACE_REGENERACY )){
fight.c:               if(nRaceSklv > 3) nCurrCon += (nRaceSklv - 3) * 2; if(nCurrCon > 25) nCurrCon = 25;
fight.c:          else if ( difflv > -2 ) factor = 100;
fight.c:          else if ( difflv > -8 ) factor = 80;
fight.c:          else if ( difflv > -10 ) factor = 30;
fight.c:          else if ( difflv > -15 ) factor = 10;
fight.c:          /*if ( ch->level <= victim->level )
fight.c:            ch->move += get_curr_con( ch ) * (sklv);
fight.c:            if( ch->move > ch->max_move )
fight.c:              ch->move = ch->max_move;
fight.c:          if( ch->hit < ch->max_hit )
fight.c:                ( !IS_NPC( victim ) && victim->pcdata->clanpk 
fight.c:                  && IS_SET(victim->in_room->room_flags, ROOM_PK) ) )
fight.c:              ch->hit += (( UMAX( 1, ( nCurrCon - 10 ) ) * base * factor ) / 100 / 
fight.c:                  ( ( victim->level - ch->level > 5 ) ? 4 : 7))/8 ;
fight.c:              ch->hit += ( UMAX( 1, ( nCurrCon - 10 ) ) * base * factor ) / 100 / 
fight.c:                ( ( victim->level - ch->level > 5 ) ? 4 : 7) ;
fight.c:            if ( ch->hit > ch->max_hit )
fight.c:              ch->hit = ch->max_hit;
fight.c:      if( ch->wait == 0 )
fight.c:      	 * deal with qmark -- earthquake_stun
fight.c:      if( !ch->fighting || victim->deleted || ch->in_room != victim->in_room
fight.c:          || IS_SET( ch->in_room->room_flags, ROOM_SAFE ) ) 
fight.c:      if ( IS_AWAKE( ch ) && (victim = ch->fighting) && !victim->deleted )
fight.c:        if ( ( IS_AFFECTED( victim, AFF_CHARM ) || IS_AFFECTED( victim, AFF_SUMMONED ) || (IS_NPC(victim) && victim->clan) )
fight.c:            && victim->master && victim->in_room && victim->in_room == victim->master->in_room && victim->master != ch
fight.c:            //      && number_percent() > 50 && can_see( ch, victim->master ) )
fight.c:          && number_percent() > 30 )//&& can_see( ch, victim->master ))
fight.c:            multi_hit( ch, victim->master, TYPE_UNDEFINED );
fight.c:        if( !IS_NPC(ch) && ch->position == POS_RESTING ) continue;
fight.c:        if( !ch->fighting || ch->fighting->deleted ) continue;
fight.c:    || ( IS_NPC( ch ) && ch->pIndexData->pShop ) )
fight.c:  for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
fight.c:        || rch->deleted
fight.c:        || !( rch->fighting ) )
fight.c:      if ( IS_NPC( ch ) && !IS_AFFECTED( ch, AFF_CHARM ) && !IS_AFFECTED( ch, AFF_SUMMONED ) && !ch->clan
fight.c:        && IS_NPC( rch ) && !IS_AFFECTED( rch, AFF_CHARM ) && !IS_AFFECTED ( rch, AFF_SUMMONED ) && !rch->clan)
fight.c:  if ( !rch || !(rch->fighting))
fight.c:  victim = rch->fighting;
fight.c:      for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
fight.c:      if ( ( rch->pIndexData != ch->pIndexData && number_bits( 3 ) != 0 )
fight.c:        || abs( victim->level - ch->level ) > 5 )
fight.c:          || IS_SET(ch->act, PLR_ASSIST) )
fight.c:          if( !ch->fighting )
fight.c:              ch->position = POS_FIGHTING;
fight.c:    for( ch = char_list; ch; ch = ch->next )
fight.c:      if(ch && !IS_NPC(ch) && ch->fighting)
fight.c:            show_vs_graphy(ch, ch->fighting);
fight.c:      && victim->hit > 0 
fight.c:      && victim->position == POS_RESTING ) 
fight.c:  if ( victim->hit > 0 )
fight.c:    if ( victim->position <= POS_STUNNED )
fight.c:      victim->position = POS_STANDING;
fight.c:    else if( victim->position == POS_PARALYZED )
fight.c:      victim->position = POS_STANDING;
fight.c:    else if( victim->position == POS_FIGHTING 
fight.c:        && ( !victim->fighting 
fight.c:          || victim->fighting->in_room != victim->in_room ))
fight.c:      victim->position = POS_STANDING;
fight.c:  if ( IS_NPC( victim ) || victim->hit <= -21 )
fight.c:    victim->position = POS_DEAD;
fight.c:  if ( victim->hit <= -6 ) victim->position = POS_MORTAL;
fight.c:  else if ( victim->hit <= -3 ) victim->position = POS_INCAP;
fight.c:  else        victim->position = POS_STUNNED;
fight.c:  //Modified by Keric for hp = -20 will not autoupdate position. 2005/2/14 
fight.c:  if ( victim->hit < 0 ) victim->hit -= 3;
fight.c:  if(!victim || victim->deleted)
fight.c:  if( ch->fighting )
fight.c:           ch->short_descr, ch->name, victim->short_descr, victim->name,
fight.c:          (victim->in_room) ? victim->in_room->vnum : 0);
fight.c:  ch->fighting = victim;
fight.c:  if( !IS_NPC(ch) && ch->position == POS_RESTING ) return;
fight.c:  if( !ch->fighting || ch->fighting->deleted ) return;
fight.c:  ch->position = POS_FIGHTING;
fight.c:  if( !IS_NPC(victim) && victim->position == POS_RESTING ) return;
fight.c:  victim->position = POS_FIGHTING;
fight.c:  REMOVE_BIT(ch->affected_by, AFF_CAST_ACC);
fight.c:  for ( fch = char_list; fch; fch = fch->next )
fight.c:      fch->fighting = NULL;
fight.c:      fch->position = POS_STANDING;
fight.c:    else if ( fBoth && fch->fighting == ch && !fch->deleted )
fight.c:      for( vch = fch->in_room->people; vch; vch = vch->next_in_room )
fight.c:        if ( vch->fighting == fch && !vch->deleted )
fight.c:          fch->fighting = vch;
fight.c:      fch->fighting = NULL;
fight.c:      fch->position = POS_STANDING;
fight.c: * and add handle for qmark -- earthquake_stun
fight.c:	REMOVE_BIT ( ch->affected_by, AFF_CAST_ACC );
fight.c:	for ( fch = char_list; fch; fch = fch->next )
fight.c:		else if ( fBoth && fch->fighting == ch && !fch->deleted )
fight.c:			for( vch = fch->in_room->people; vch; vch = vch->next_in_room )
fight.c:				if ( vch->fighting == fch && !vch->deleted && vch != ch ) {
fight.c:					fch->fighting = vch;
fight.c:					fch->attacked = NULL;                       //Added by Razgriz 20060822
fight.c:					fch->fighting = NULL;
fight.c:					fch->position = POS_STANDING;
fight.c:					fch->attacked = NULL;                       //Added by Razgriz 20060822
fight.c:					//deal with qmark -- earthquake_stun
fight.c:						fch->wait = 0;//trade-off
fight.c:		tch->fighting = NULL;
fight.c:		tch->position = POS_STANDING;
fight.c:		tch->attacked = NULL;                                   //Added by Razgriz 20060822
fight.c:		//deal with qmark -- earthquake_stun
fight.c:			tch->wait = 0;//trade-off
fight.c:  if ( ( killer == ch ) && ( ch->attacked ) )
fight.c:    killer = ch->attacked;
fight.c:     * object_list to obj_free.      --- Thelonius (Monk)
fight.c:    name      = ch->name;
fight.c:    corpse->timer = number_range( 8, 14 );
fight.c:    sprintf( buf, corpse->name, name );
fight.c:    free_string( corpse->name );
fight.c:    corpse->name = str_dup( buf );
fight.c:    if( IS_NPC( killer ) && IS_SET(killer->act,ACT_CORPSE_COUNT) )
fight.c:      sprintf(buf_q, "corpse_count_%d", killer->pIndexData->vnum);
fight.c:        sprintf( buf, "%s ", ch->name );
fight.c:        sprintf( buf, "%s ", ch->name );
fight.c:        sprintf( buf, "%s ", ch->name );
fight.c:    name        = ch->name;
fight.c:    corpse->timer = 100;
fight.c:  corpse->value[0] = 0;
fight.c:  corpse->value[1] = 0;
fight.c:  corpse->value[2] = 0;
fight.c:  corpse->value[3] = 0;
fight.c:  if ( ch->gold > 0 )
fight.c:    int gold = ch->gold;    
fight.c:    if( !IS_NPC( killer ) && IS_NPC(ch ) && killer->class > BARBARIAN){
fight.c:      int difflv = killer->level - ch->level;
fight.c:    ch->gold = 0;
fight.c:  sprintf( buf, corpse->name, name );
fight.c:  free_string( corpse->name );
fight.c:  corpse->name = str_dup( buf );
fight.c:    sprintf( buf, corpse->short_descr, ch->short_descr );
fight.c:    sprintf( buf, corpse->short_descr, name );
fight.c:  free_string( corpse->short_descr );
fight.c:  corpse->short_descr = str_dup( buf );
fight.c:  sprintf( buf, corpse->description, ch->short_descr, killer->short_descr );
fight.c:  free_string( corpse->description );
fight.c:  corpse->description = str_dup( buf );
fight.c:  corpse->level = ch->level;
fight.c:  for ( obj = ch->carrying; obj; obj = obj_next )
fight.c:    obj_next = obj->next_content;
fight.c:    if ( obj->deleted )
fight.c:    if ( IS_SET( obj->extra_flags, ITEM_INVENTORY ) ||
fight.c:        ( IS_NPC( ch ) && ch->pIndexData->pShop ) )
fight.c:      if( IS_SET( obj->wear_flags , ITEM_WEAR_RIDE ) && !IS_NPC(ch) && get_skill_level(ch,gsn_ride) < 4 )
fight.c:        if (  get_mob_index(obj->pIndexData->horse)  == NULL )
fight.c:          bug( "Ride - Bad mob vnum: vnum %d.", obj->pIndexData->vnum );
fight.c:        horse = create_mobile( get_mob_index( obj->pIndexData->horse) );
fight.c:        for( obj_horse = obj->contains; obj_horse ; obj_horse = obj_horse_next )
fight.c:          obj_horse_next = obj_horse->next_content;
fight.c:        char_to_room( horse, ch->in_room);
fight.c:        SET_BIT( horse->act,     ACT_HORSE    );
fight.c:        SET_BIT( horse->act,  ACT_SENTINEL      );
fight.c:      if( IS_SET(obj->extra_flags, ITEM_PERSONAL) && !IS_NPC(ch))
fight.c:        obj_to_obj( obj, corpse ); /* eq upon death - Kahn      */
fight.c:  obj_to_room( corpse, ch->in_room );
fight.c:    name    = ch->name;
fight.c:    cname   = ch->short_descr;
fight.c:    obj->timer  = number_range( 4, 7 );
fight.c:    sprintf( buf, obj->short_descr, cname );
fight.c:    free_string( obj->short_descr );
fight.c:    obj->short_descr = str_dup( buf );
fight.c:    sprintf( buf, obj->name, name );
fight.c:    free_string( obj->name );
fight.c:    obj->name = str_dup( buf );
fight.c:    sprintf( buf, obj->description, cname, name );
fight.c:    free_string( obj->description );
fight.c:    obj->description = str_dup( buf );
fight.c:      obj->value[3] = 1;
fight.c:    obj_to_room( obj, ch->in_room );
fight.c:  was_in_room = ch->in_room;
fight.c:    if ( ( pexit = was_in_room->exit[door] )
fight.c:        && pexit->to_room
fight.c:        && pexit->to_room != was_in_room )
fight.c:      ch->in_room = pexit->to_room;
fight.c:  ch->in_room = was_in_room;
fight.c:	ch->armor = 100;
fight.c:  ch->dodge = 0;
fight.c:  if( ch->class > BARBARIAN ){
fight.c:    ch->armor  += race_table[ch->race]. nature_ac;
fight.c:    ch->dodge  += race_table[ch->race]. nature_dodge;
fight.c:  ch->position   = POS_RESTING;
fight.c:  if ( IS_SET( race_table[ ch->race ].race_abilities, RACE_VAMPIRE 
fight.c:        || ch->class < WIZARD 
fight.c:        || ch->level < 31 ) ){
fight.c:    ch->hit  = ((ch->max_hit*10)/ 100);
fight.c:    ch->hit    = UMAX( 1, ch->hit  );
fight.c:  ch->mana     = UMAX( 1, ch->mana );
fight.c:  ch->move     = UMAX( 1, ch->move );
fight.c:  ch->hitroll  = 0;
fight.c:  ch->damroll  = 0;
fight.c:  if(IS_SET(race_table[ ch->race ].race_abilities, RACE_FLY)){
fight.c:    ch->dodge -= nRaceSklv * 2 + (nRaceSklv * nRaceSklv) / 2;
fight.c:		ch->dodge += race_table[ ch->race ].size * 5;
fight.c:  switch(ch->level) {
fight.c:      ch->pp = 0;
fight.c:      ch->pdr = 0;
fight.c:      ch->mdr = 0;
fight.c:      ch->pp = 3;
fight.c:      ch->pdr = 4;
fight.c:      ch->mdr = 4;
fight.c:      ch->pp = 7;
fight.c:      ch->pdr = 12;
fight.c:      ch->mdr = 12;
fight.c:      ch->pp = 13;
fight.c:      ch->pdr = 25;
fight.c:      ch->mdr = 25;
fight.c:	ch->pdr += GetArmorMasteryPdrBonus(ch);
fight.c:  ch->apdr = 0;
fight.c:  ch->amdr = 0;
fight.c:  ch->pad = 0;
fight.c:  ch->mad = 0;
fight.c:  ch->pcdata->autocombat = AUTOC_NORMAL;
fight.c:    ch->saving_throw[i] = 0;
fight.c:	ch->mod_str = 0;
fight.c:  ch->mod_int = 0;
fight.c:  ch->mod_wis = 0;
fight.c:  ch->mod_dex = 0;
fight.c:  ch->mod_con = 0;
fight.c:    if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
fight.c:      if(ch->master != NULL) ch = ch->master;
fight.c:    if( IS_SET(victim->act, ACT_MPROG_DEATH))
fight.c:    SET_BIT(victim->act, ACT_MPROG_DEATH);
fight.c:    if ( victim->attacked )
fight.c:      mprog_death_trigger( ch, victim->attacked );
fight.c:    ch->pcdata->pkwin += 1;
fight.c:    victim->pcdata->pklose += 1;
fight.c:  if ( victim->deleted )//for the 'mppurge self' in mprog_death_trigger condition
fight.c:    for ( paf = victim->affected; paf; paf = paf->next )
fight.c:      if ( paf->deleted )
fight.c:    victim->pIndexData->killed++;
fight.c:    kill_table[URANGE( 0, victim->level, MAX_LEVEL-1 )].killed++;
fight.c:  logf_envy("%s is killed by %s.", victim->name, ch->name);
fight.c:  for ( paf = victim->affected; paf; paf = paf->next )
fight.c:    if ( paf->deleted )
fight.c:    if(paf->type == gsn_polymorph || paf->type == gsn_morphing )
fight.c:        if( paf->type == gsn_morphing )
fight.c:            victim->temp_race = '\0' ; //NULL;
fight.c:    if( paf->type == gsn_flying )
fight.c:          && victim->in_room 
fight.c:          && IS_SET(victim->in_room->room_flags, ROOM_PK) )
fight.c:        || ( victim->level < 4 && victim->class < 5 )
fight.c:        || victim->pcdata->clanpk ) )
fight.c:  //    if ( IS_NPC( victim ) || IS_SET( victim->act, PLR_HORSE ) )
fight.c:    if ( ch->class == WARLORD && (victim->level >= ch->level || victim->level > 36 )
fight.c:      if( ch->hitroll > 20 - sklv * 3 ) {
fight.c:        if( ch->level > victim->level )
fight.c:        af.modifier  = - 3 + (sklv > 3 ? 1 : 0 ) + (sklv > 5 ? 1 : 0);
fight.c:        if( ch->level > victim->level )
fight.c:    cn  = ch->clan;
fight.c:    if ( cn && victim->level > ch->level && victim->pIndexData->killed < 4 
fight.c:        && IS_SET( victim->act, ACT_AGGRESSIVE ) )
fight.c:      cn->construct++;
fight.c:    if ( victim->level > 39 && cn && !victim->pIndexData->pShop && !victim->clan
fight.c:        && !IS_SET( victim->act, ACT_PRACTICE ) && victim->pIndexData->vnum != cn->kill[0] )
fight.c:      vicvnum = victim->pIndexData->vnum;
fight.c:      tempa = cn->kill[0];
fight.c:      cn->kill[0] = vicvnum;
fight.c:      for( i = 0; i < CLAN_KILL - 1; i++ )//remembered the last 10 killed mob
fight.c:        if ( vicvnum == cn->kill[i+1] )
fight.c:          cn->kill[i+1] = tempa;
fight.c:        tempb = cn->kill[i+1];
fight.c:        cn->kill[i+1] = tempa;
fight.c:      if ( i == CLAN_KILL - 1 ) //not found in cn->kill list, add hire points
fight.c:        if ( victim->level < 45 )
fight.c:          cn->hire += 1;
fight.c:        else if ( victim->level < 50 )
fight.c:          cn->hire += 3;
fight.c:        else if ( victim->level < 55 )
fight.c:          cn->hire += 10;
fight.c:        else if ( victim->level < 60 )
fight.c:          cn->hire += 20;
fight.c:        else if ( victim->level < 65 )
fight.c:          cn->hire += 40;
fight.c:          cn->hire += 80;
fight.c:    if ( victim->clan )
fight.c:      victim->clan->hire -= ( 10 + UMAX( 0, victim->level - 35 ) * 3
fight.c:          + UMAX( 0, victim->level - 38 ) * 5 );
fight.c:      if ( victim->spec_fun )
fight.c:        victim->clan->hire -= 15;
fight.c:      if ( victim->class != 0 )
fight.c:        victim->clan->hire -= 15;
fight.c:  if ( IS_SET( victim->act, PLR_KILLER ) )
fight.c:    REMOVE_BIT( victim->act, PLR_KILLER );
fight.c:  for ( obj = victim->carrying; obj; obj = obj_next )
fight.c:    obj_next = obj->next_content;
fight.c:    if ( obj->deleted )
fight.c:    if( IS_SET( obj->wear_flags , ITEM_WEAR_RIDE ) )
fight.c:      if (  get_mob_index(obj->pIndexData->horse)  == NULL )
fight.c:        bug( "Ride - Bad mob vnum: vnum %d.", obj->pIndexData->vnum );
fight.c:      horse = create_mobile( get_mob_index( obj->pIndexData->horse) );
fight.c:      for( obj_horse = obj->contains; obj_horse ; obj_horse = obj_horse_next )
fight.c:        obj_horse_next = obj_horse->next_content;
fight.c:      char_to_room( horse, victim->in_room);
fight.c:      SET_BIT( horse->act, ACT_HORSE   );
fight.c:      SET_BIT( horse->act, ACT_SENTINEL);
fight.c:  if ( victim->race == race_lookup( "vampire" ) )
fight.c:    victim->pcdata->condition[COND_FULL  ] = 0;
fight.c:    victim->pcdata->condition[COND_THIRST] = 0;
fight.c:  loc = victim->in_room;
fight.c:  if( loc != victim->in_room ) {
fight.c:  if( !ch->in_room )
fight.c:  if( IS_NPC(victim) && IS_SET(victim->act, ACT_MPROG_DEATH)) 
fight.c:      if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
fight.c:          if(ch->master != NULL) ch = ch->master;
fight.c:  for( gch = ch->in_room->people; gch; gch = gch->next_in_room )
fight.c:  lch = ( ch->group && ch->group->leader ) ? ch->group->leader : ch;
fight.c:  if(lch->in_room != ch->in_room) lch = ch;
fight.c:  for( gch = ch->in_room->people; gch; gch = gch->next_in_room )
fight.c:        ( gch != ch->master ||( !IS_AFFECTED( ch, AFF_CHARM ) && !IS_AFFECTED( ch, AFF_SUMMONED ) ) ) )
fight.c:    if( IS_NPC( ch ) && ch->master != gch && (  ch->level - gch->level > 5 || ch->level - gch->level < -5 ) ){
fight.c:    if( gch->level - ch->level >= 6 )
fight.c:    if( gch->level - ch->level <= -6 )
fight.c:    if( !IS_NPC( gch ) && gch->class <= BARBARIAN && !IS_SET( gch->act, PLR_HORSE ) )
fight.c:    if( !str_infix( race_table[lch->race].name,race_table[gch->race].hate) && members > 1 )
fight.c:        xp -= xp/6;
fight.c:    if( gch && found && gch->class > BARBARIAN && gch == lch )
fight.c:    if( IS_SET( gch->act, PLR_HORSE ) )
fight.c:        xp -= xp/3;
fight.c:    if( ch->level > 35 && gch->level < 36 )
fight.c:        xp /= UMAX( 1,( ch->level - gch->level - members + 3 ));
fight.c:    if( ch->level < 37 )
fight.c:    for( obj = gch->carrying; obj; obj = obj_next )
fight.c:         obj_next = obj->next_content;
fight.c:         if( obj->deleted )
fight.c:         if( obj->wear_loc == WEAR_NONE )
fight.c:             if( IS_SET(obj->extra_flags , ITEM_PERSONAL) )
fight.c:               obj_to_room( obj, gch->in_room );
fight.c:         if( obj->pIndexData->max_level > 0 && gch->level > obj->pIndexData->max_level )
fight.c:             sprintf( buf, "§A¥²¶·¦bµ¥¯Å %d ¥H¤º¤~¯à¨Ï¥Î³o¼Ëª««~.\n\r",obj->pIndexData->max_level );
fight.c:  level = gch->level - victim->level;
fight.c:	if(level < -18) level = -18;
fight.c:  if(victim->level < 40 && level < -10) level = -10;
fight.c:  if(gch->class < WIZARD && gch->level < 36) level -= 5;
fight.c:  if( IS_NPC(victim) ) xp += victim->exp;
fight.c:		xp  = xp * (100 - level * 15) / 100;
fight.c:  // xp    = 80 - URANGE( -10, level, 5 ) * 20;
fight.c:      xp += victim->exp;
fight.c:  if ( level < -9 )
fight.c:    xp -= level * 8;
fight.c:  align = gch->alignment - victim->alignment;
fight.c:      gch->alignment += (((( 0 - victim->alignment ) / 200) + ( (align > 0 ) ? (1) : (-1)))) / 2 ;
fight.c:      gch->alignment -= ( (((victim->alignment - GOOD_BASE) * (victim->alignment - GOOD_BASE) / 45000 ) + 3 ) / 5 );
fight.c:      gch->alignment += ( (((EVIL_BASE - victim->alignment ) * (EVIL_BASE - victim->alignment ) / 45000 ) + 3 ) / 5 );
fight.c:      gch->alignment += (((( align) / 300) + ( (align > 0 ) ? (1) : (-1))) / 5 );
fight.c:    else if ( align < -500 )
fight.c:    if ( IS_SET( race_table[ gch->race ].race_abilities, RACE_VAMPIRE ) || 
fight.c:         IS_SET( race_table[ gch->race ].race_abilities, RACE_GARGOYLE ) )
fight.c:      gch->alignment = UMIN( 0, gch->alignment );
fight.c:    gch->alignment = URANGE( -1000, gch->alignment, 1000);
fight.c:      || IS_SET( race_table[ victim->race ].race_abilities, RACE_SANCT ) )
fight.c:  if ( !str_infix( race_table[victim->race].name,
fight.c:        race_table[gch->race].hate ) )
fight.c:  if ( victim->race == gch->race )
fight.c:    bonus -= (float)1/8;
fight.c:    if( IS_SET( victim->special, NO_EXP ) )
fight.c:    if( IS_SET( victim->special, REF_MAGIC ) )
fight.c:    if( IS_SET( victim->special, NO_DM) )
fight.c:    if( IS_SET( victim->special, ALY_SAN ) )
fight.c:    if( IS_SET( victim->special, NO_MUTE) 
fight.c:        ||  IS_SET(victim->special, NO_SEALMAGIC)
fight.c:        ||  IS_SET(victim->special, NO_CRAZY))
fight.c:    if( IS_SET( victim->special, MOBAI_LV2) )
fight.c:    if( IS_SET( victim->special, MOBAI_LV3) )
fight.c:    if( IS_SET( victim->special, NO_PARA) )
fight.c:    if( IS_SET( victim->special, NO_TARDY) )
fight.c:    if( IS_SET( victim->special, ALY_BAR) )
fight.c:    if( IS_SET( victim->special, ANTI_MAGIC ) )
fight.c:    if( IS_SET( victim->special, NO_BLIND))
fight.c:    if( victim->level > 50 && IS_SET(victim->special, EXPERT))
fight.c:      bonus += (float) (0.05)* ( victim->level - 50);
fight.c:    if ( IS_SET( victim->act, ACT_MOB_AI) )
fight.c:    if ( IS_SET( victim->act, ACT_AGGRESSIVE ) )
fight.c:    if( victim->jcl || victim->psk )
fight.c:      bonus -= (float)7/8;
fight.c:    if ( victim->pIndexData->pShop )
fight.c:      bonus -= (float)4/5;
fight.c:    if ( victim->spec_fun )
fight.c:      if (   victim->spec_fun == spec_lookup( "spec_breath_any"     )
fight.c:          || victim->spec_fun == spec_lookup( "spec_cast_psionicist"  )
fight.c:          || victim->spec_fun == spec_lookup( "spec_cast_undead"      )
fight.c:          || victim->spec_fun == spec_lookup( "spec_breath_gas"     )
fight.c:          || victim->spec_fun == spec_lookup( "spec_cast_mage"      ) )
fight.c:      if (   victim->spec_fun == spec_lookup( "spec_breath_fire"      )
fight.c:          || victim->spec_fun == spec_lookup( "spec_breath_cold"      )
fight.c:          || victim->spec_fun == spec_lookup( "spec_breath_acid"      )
fight.c:          || victim->spec_fun == spec_lookup( "spec_breath_lightning" )
fight.c:          || victim->spec_fun == spec_lookup( "spec_cast_cleric"      )
fight.c:          || victim->spec_fun == spec_lookup( "spec_cast_judge"     )
fight.c:          || victim->spec_fun == spec_lookup( "spec_cast_ghost"     ) )
fight.c:      if (   victim->spec_fun == spec_lookup( "spec_poison"     )
fight.c:          || victim->spec_fun == spec_lookup( "spec_thief"      ) )
fight.c:      if ( victim->spec_fun == spec_lookup( "spec_cast_adept"     ) )
fight.c:        bonus -= (float)3/4;
fight.c:      if ( gch->class == CLERIC || gch->class == SAVANT )
fight.c:      if ( gch->class > BARBARIAN && !IS_SET(victim->special, EXPERT) && gch->level > 29 )
fight.c:        bonus -= (float)7/8;
fight.c:      else if ( gch->class > BARBARIAN )
fight.c:        bonus -= 0.4f;
fight.c:      if ( !strcmp( race_table[ gch->race ].name, "Gnome" ) )
fight.c:    bonus += (bonus - 1) * 0.1;
fight.c:   *   -1/8 for each target over  'par' (down to - 75%)
fight.c:   * the xp PC gets will degenerate till -50%, on the other
fight.c:    if  (!IS_SET(victim->act, ACT_NOPAR))  /* mud school protection */
fight.c:      level  = URANGE( 0, victim->level, MAX_LEVEL - 1 );
fight.c:      extra  = victim->pIndexData->killed - kill_table[level].killed
fight.c:      xp    -= xp * URANGE( -4, extra, 6 ) / 8;
fight.c://    xp += victim->exp;
fight.c:  if ( !IS_NPC(victim) && victim->class < 4 )
fight.c:  if ( (race_table[ch->race].size - race_table[victim->race].size ) < -2 )
fight.c:  if( !IS_NPC(victim) && victim->pcdata->learned[gsn_swordmaster] == 0)
fight.c:  if ( !IS_NPC( victim ) && victim->pcdata->learned[gsn_swordmaster] > 0 &&
fight.c:      ( get_skill_level(victim, gsn_swordmaster)*2 -get_skill_level(ch, 
fight.c:                                      gsn_barehand)*2- get_skill_level(ch, gsn_disarm)*2+ get_skill_percent(victim,gsn_swordmaster) + ( victim->class == SWORDSMAN ? get_skill_level(victim, gsn_swordmaster) * 3 : 0 ) + 10 * ( get_curr_int( ch ) - 16 ) ) * 4 / 5
fight.c:  if ( IS_NPC( victim ) && ( ( IS_SET( ch->act, ACT_HARD_DIS ) && number_bits( 3 ) != 1 ) || IS_SET( victim->special, NO_DISARM ) ) )
fight.c:  if ( IS_SET( obj->extra_flags, ITEM_NOREMOVE )
fight.c:      || IS_SET( obj->extra_flags, ITEM_NODROP ) ){
fight.c:    obj_to_room( obj, victim->in_room );
fight.c:      || victim->position <= POS_RESTING
fight.c:      || IS_SET(race_table[victim->race].race_abilities, RACE_LIZARDMAN ) )
fight.c:      && ( victim->class == KNIGHT || victim->class == LORD ) 
fight.c:  if( IS_NPC( victim ) && IS_SET( victim->special, NO_TRIP ) )
fight.c:    if( victim->pcdata->autocombat == AUTOC_DODGE ) {
fight.c:      mod -= get_skill_percent(victim, gsn_autododge)/2 + get_skill_level(victim, gsn_autododge);
fight.c:    else if (victim->pcdata->autocombat == AUTOC_PARRY){
fight.c:        ( get_skill_level(victim, gsn_bodycontrol) + (get_skill_level(victim, gsn_bodycontrol) > 5 ? get_skill_level(victim, gsn_bodycontrol) : 0 ) + get_skill_percent(victim, gsn_bodycontrol) + 10 * ( get_curr_wis( victim ) - 15 ) ) * 3 / 4
fight.c:        > (number_percent( ) * mod / 100) + ((IS_SET(race_table[ch->race].race_abilities, RACE_LIZARDMAN)) ? 20 : 0))
fight.c:      || ( IS_NPC(victim) && IS_SET(victim->special, EXPERT) && number_percent()  > ch->level - 20))
fight.c:  if ( victim->wait == 0 )
fight.c:    //if( !IS_NPC( ch ) &&!IS_SET( ch->act, PLR_CHINESE ) )
fight.c:    victim->position = POS_RESTING;
fight.c:  if( victim->in_room && IS_SET(victim->in_room->room_flags, ROOM_SAFE)){
fight.c:    if (   !IS_SET( victim->act, PLR_KILLER )
fight.c:        && !IS_SET( victim->act, PLR_THIEF  )
fight.c:        && !IS_SET( race_table[ victim->race ].race_abilities, RACE_VAMPIRE )
fight.c:        && !IS_SET( victim->in_room->room_flags, ROOM_PK) )
fight.c:        && victim->master && !IS_NPC(victim->master) )
fight.c:  if ( ch->position == POS_FIGHTING )
fight.c:  if( !victim->deleted && victim->fighting != ch && 
fight.c:      victim->in_room == ch->in_room )//victim may flee!
fight.c:  if( victim->in_room && IS_SET(victim->in_room->room_flags, ROOM_SAFE)){
fight.c:  if( !IS_SET( ch->act, PLR_REGISTER ) && (ch->in_room && !IS_SET(ch->in_room->room_flags, ROOM_PK))) {
fight.c:      &&  (!victim->master || IS_NPC(victim->master)))
fight.c:  if ( ch->position == POS_FIGHTING )
fight.c:  //if( victim->master 
fight.c:	int nStun = 6 - sklv * (sklv - 1) / 6;
fight.c:		if(get_skill_level(ch, gsn_ride) > 4) nStun--;
fight.c:  if( ch->deleted ) return;
fight.c:  if( !( victim = ch->fighting ) )
fight.c:  if( !ch->in_room || victim->deleted ) return;
fight.c:  if( IS_SET( ch->in_room->room_flags, ROOM_NO_FLEE ) )
fight.c:  if( ch->move < 20 )
fight.c:      switch( ch->pcdata->prime_attr ) 
fight.c:      switch( ch->pcdata->snd_attr ) 
fight.c:      if( ch->class == ASSASSIN ) 
fight.c:      else if( ch->class == NINJA ) 
fight.c:      else if( ch->class < WIZARD ) 
fight.c:  was_in = ch->in_room;
fight.c:           door = number_door( );/*generate a random number from 0-5*/
fight.c:           if( ( pexit = was_in->exit[door] ) == 0 
fight.c:               || !pexit->to_room
fight.c:               || ( IS_SET( pexit->exit_info, EX_CLOSED )
fight.c:                    && !IS_SET( race_table[ ch->race ].race_abilities, RACE_PASSDOOR ) 
fight.c:                    && ! IS_SET( pexit->exit_info, EX_PASSPROOF ))
fight.c:                    && ( IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB )
fight.c:                         || ( IS_SET( ch->act, ACT_STAY_AREA )
fight.c:                              && pexit->to_room->area != ch->in_room->area ) ) ) )
fight.c:           if( victim->level > 40 || (!IS_NPC(victim) && victim->level > 34))
fight.c:                       if( ch->pcdata->learned[gsn_escape] )
fight.c:                               ch->exp = ch->exp - 20;
fight.c:                           ch->exp = ch->exp-15;
fight.c:           if( ( now_in = ch->in_room ) == was_in )
fight.c:               if( ch->fighting ) stop_fighting(ch, FALSE);
fight.c:               if( victim->fighting ) stop_fighting(victim, FALSE);
fight.c:           ch->in_room = was_in;
fight.c:           act( "$n °k¨«¤F¡I", IS_SET( ch->act, PLR_HORSE ) && ch->desc ? ch->pcdata->horse : ch,
fight.c:           ch->in_room = now_in;
fight.c:               if( ch->pcdata->learned[gsn_escape])
fight.c:                       ch->exp = ch->exp - 25;
fight.c:                   ch->exp = ch->exp - 20;
fight.c:		       ch->attacked = NULL;
fight.c:		       victim->attacked = NULL;
fight.c:           if( victim->level > ch->level/2 + sklv * 2)
fight.c:          if( ch->pcdata->learned[gsn_escape])
fight.c:                  ch->exp = ch->exp -20;
fight.c:              ch->exp = ch->exp -15;
fight.c:      if( ( pexit = was_in->exit[dir] ) == 0
fight.c:            || !pexit->to_room
fight.c:            || ( IS_SET( pexit->exit_info, EX_CLOSED )
fight.c:                 && !IS_SET( race_table[ ch->race ].race_abilities, RACE_PASSDOOR ) 
fight.c:                 && ! IS_SET( pexit->exit_info, EX_PASSPROOF ))
fight.c:                 && ( IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB )
fight.c:                      || ( IS_SET( ch->act, ACT_STAY_AREA )
fight.c:                           && pexit->to_room->area != ch->in_room->area ) ) ) )
fight.c:      if( victim->level > 40 || (!IS_NPC(victim) && victim->level > 34 ))
fight.c:                  if( ch->pcdata->learned[gsn_escape])
fight.c:                        ch->exp -= 20; 
fight.c:                      ch->exp -= 15;
fight.c:    if( ( now_in = ch->in_room ) == was_in )
fight.c:        if( ch->fighting ) stop_fighting(ch, FALSE);
fight.c:        if( victim->fighting ) stop_fighting(victim, FALSE);
fight.c:    ch->in_room = was_in;
fight.c:    act( "$n °k¨«¤F¡I", IS_SET( ch->act, PLR_HORSE ) && ch->desc ? ch->pcdata->horse : ch,
fight.c:    ch->in_room = now_in;
fight.c:        if( ch->pcdata->learned[gsn_escape])
fight.c:              ch->exp=ch->exp-25;
fight.c:            gain_exp( ch, -20 );
fight.c:	ch->attacked = NULL;
fight.c:	victim->attacked = NULL;
fight.c:    if( victim->level > ch->level/2)
fight.c:  for( fch = room->people ; fch ; fch = fch->next_in_room ) {
fight.c:    if( fch->fighting == ch && fch != victim ) return fch;
fight.c:  if(!ch || !victim || !victim->in_room || !ch->in_room || !was_in) return;
fight.c:  for( vch = was_in->people; vch; vch = vch_next_in_room )
fight.c:    vch_next_in_room = vch->next_in_room;
fight.c:    if ( vch != victim || vch->deleted || !can_see( vch, ch ) )
fight.c:    if ( IS_NPC( vch ) && IS_SET( vch->act, ACT_HUNT ) )
fight.c:      if ( ( hch = vch->hunting ) )
fight.c:        if ( hch->hunted == vch )
fight.c:          hch->hunted = vch->next_in_hunt;
fight.c:          for( rch = hch->hunted; rch; rch = rch->next_in_hunt )
fight.c:            if ( rch->next_in_hunt == vch )
fight.c:              rch->next_in_hunt = vch->next_in_hunt;
fight.c:        vch->hunting = ch;
fight.c:        vch->next_in_hunt = ch->hunted;
fight.c:        ch->hunted = vch;
fight.c:        vch->hunting = ch;
fight.c:        vch->next_in_hunt = ch->hunted;
fight.c:        ch->hunted = vch;
fight.c:      for(auction = auction_list ; auction; auction = auction->next ){
fight.c:        if( auction->owner == vch || auction->buyer == vch )
fight.c:    if ( ( IS_NPC( vch ) && !IS_SET( vch->act, ACT_TRACK ) ) 
fight.c:        ||  ( !IS_NPC( vch ) && ( vch->tracking != ch ||
fight.c:            number_percent() > get_skill_percent(vch, gsn_track) - get_skill_level(ch,gsn_escape) * 3 ) ) )
fight.c:    if ( IS_NPC( vch ) && IS_SET( vch->act, ACT_TRACK ) )
fight.c:      if ( vch->track_times >= 6 )
fight.c:        ch->tracked = vch->next_in_track;
fight.c:        vch->tracking = NULL;
fight.c:        vch->next_in_track = NULL;
fight.c:        vch->track_times = 0;
fight.c:        vch->track_times += 1;
fight.c:    if( was_in == vch->in_room ) return;
fight.c:    if ( ch->in_room == vch->in_room )//ROOM_ENTRY_TRIGGER may mptransfer vch!
fight.c:      if ( ch->position != POS_FIGHTING )
fight.c:    //track_hunt( vch, vch->fighting, was_in, door );
fight.c:    vch_next_in_room = was_in->people;//vch->next_in_room may tracking and leave
fight.c:  if ( !IS_NPC( victim ) && victim->level >= ch->level )
fight.c:	if ( arg[0] == '\0' && !ch->fighting  )
fight.c:	if( arg[0] == '\0' && ch->fighting && ch->fighting->in_room &&
fight.c:			ch->fighting->in_room != ch->in_room )
fight.c:	if ( !( victim = ch->fighting ) )
fight.c:	if( victim->deleted ) return;
fight.c:	if ( !IS_SET( race_table[ ch->race ].race_abilities, RACE_VAMPIRE ) )
fight.c:		if ( !ch->fighting )
fight.c:	if(ch->move < 10 + nSklv * 5){
fight.c:	ch->move -= 10 + nSklv * 5;
fight.c:			nHitRate = nHitRoll * 1200 / (1000 - GET_DODGE(victim));
fight.c:			dam  = dam * 2000 / (2000 - GET_AC(victim));
fight.c:			dam  = dam * 750 / (750 - GET_AC(victim));
fight.c:	dam +=	ch->apdr * (12 + nSklv * 3 + nEdSklv * 2 + nSklv * nEdSklv / 2) / 10;
fight.c:	dam -=  victim->pdr;
fight.c:	nDamCH  = get_critical_damage(dam, ch, victim, get_curr_dex(ch) - get_curr_dex(victim), 0, 0, 0);
fight.c:	if ( victim->in_room == ch->in_room && 15 + nSklv + nSklv * nSklv / 4 > number_percent( ) ){
fight.c:		nDamCH	= get_critical_damage(dam, ch, victim, get_curr_dex(ch) - get_curr_dex(victim), 0, 0, 0);
fight.c:			&& number_percent( ) < ( 25 - victim->level + ch->level + nSklv * 2 + nSklv * nSklv / 2) )
fight.c:		if (   ch->pcdata->condition[COND_FULL  ] > 40
fight.c:			  && ch->pcdata->condition[COND_THIRST] > 40)
fight.c:				ch->hit = UMIN( ch->max_hit * 11 / 10, ch->hit + dam / 4);
fight.c:				ch->hit = UMIN( ch->max_hit * 11 / 10, ch->hit + dam / 20);
fight.c:  for ( obj = ch->carrying; obj; obj = obj->next_content )
fight.c:    if ( obj->pIndexData->vnum == OBJ_VNUM_STAKE
fight.c:        && obj->wear_loc == WEAR_WIELD )
fight.c:  chance = ( IS_NPC( ch ) ? ch->level : ch->pcdata->learned[gsn_stake] );
fight.c:  chance = chance - victim->level + ch->level;
fight.c:      || victim->race != race_lookup( "Vampire" ) )
fight.c:    if ( victim->race == race_lookup( "vampire" ) )
fight.c:      ////damage( ch, victim, victim->hit + 11, gsn_stake, WEAR_NONE );
fight.c:      damage( ch, victim, victim->hit + 11, gsn_stake, WEAR_NONE, MSG_NORMAL, DMG_NORMAL );
fight.c:    do_feed( victim, ch->name );
fight.c: * eating pills -Kahn */
fight.c:  for ( obj = ch->carrying; obj; obj = obj->next_content )
fight.c:    if ( (   obj->item_type == ITEM_SCROLL
fight.c:          || obj->item_type == ITEM_WAND
fight.c:          || obj->item_type == ITEM_STAFF
fight.c:          || obj->item_type == ITEM_PILL )
fight.c:  switch( cobj->item_type )
fight.c:    case ITEM_WAND:   if ( cobj->wear_loc == WEAR_HOLD )
fight.c:    case ITEM_STAFF:  if ( cobj->wear_loc == WEAR_HOLD )
fight.c:    case ITEM_PILL:   sprintf( buf, "%s", cobj->name );
fight.c:  if ( ch->fighting && ch->fighting == ch ) return;
fight.c:  if( obj->pIndexData->hp_use_class )
fight.c:    if (   (     IS_SET( obj->pIndexData->hp_use_class, ALLOW_BIT ) 
fight.c:             && !IS_SET( obj->pIndexData->hp_use_class, NUM_BIT( ch->class ) ) )
fight.c:        || (   IS_SET( obj->pIndexData->hp_use_class, DENY_BIT ) 
fight.c:            && IS_SET( obj->pIndexData->hp_use_class, NUM_BIT( ch->class ) ) ) )
fight.c:  if( obj->pIndexData->hp_use_race )
fight.c:    if (   (     IS_SET( obj->pIndexData->hp_use_race, ALLOW_BIT ) 
fight.c:             && !IS_SET( obj->pIndexData->hp_use_race, NUM_BIT( ch->race ) ) )
fight.c:        || (     IS_SET( obj->pIndexData->hp_use_race, DENY_BIT ) 
fight.c:             &&  IS_SET( obj->pIndexData->hp_use_race, NUM_BIT( ch->race ) ) ) )
fight.c:  if( obj->pIndexData->hp_use_sex )
fight.c:    if (   (     IS_SET( obj->pIndexData->hp_use_sex, ALLOW_BIT ) 
fight.c:             && !IS_SET( obj->pIndexData->hp_use_sex, NUM_BIT( ch->sex ) ) )
fight.c:        || (     IS_SET( obj->pIndexData->hp_use_sex, DENY_BIT ) 
fight.c:             &&  IS_SET( obj->pIndexData->hp_use_sex, NUM_BIT( ch->sex ) ) ) )
fight.c:  if( obj->pIndexData->hp_use_sex )
fight.c:    if (   (    IS_SET( obj->pIndexData->hp_use_align, ALLOW_BIT ) 
fight.c:            && !IS_SET( obj->pIndexData->hp_use_align, NUM_BIT( get_align( ch ) ) ) )
fight.c:        || (    IS_SET( obj->pIndexData->hp_use_align, DENY_BIT ) 
fight.c:            &&  IS_SET( obj->pIndexData->hp_use_align, NUM_BIT( get_align( ch ) ) ) ) )
fight.c:  if( !victim || victim->deleted) return;
fight.c:  	int victim_hp_remain = (victim->hit*10)/victim->max_hit,
fight.c:  	if(!IS_SET(ch->act, PLR_STATUS))       return;
fight.c:  	if(!victim || victim->deleted ) return;
fight.c:	if(!ch || !ch->in_room || ch->deleted ) return;
fight.c:  	for(vch = ch->in_room->people; vch; vch = vch->next_in_room)
fight.c:    	if( vch && vch->fighting == ch)
fight.c:  //The fuzzy range is +-10% when the victim is approaching the death.
fight.c:      victim_hp_remain--;
fight.c:      color_of_victim, victim->short_descr);
fight.c:  if ( !IS_NPC( victim ) && victim->level > 3 && !IS_SET( victim->act, PLR_HORSE ) && victim != ch && !IS_IMMORTAL(ch))
fight.c:    if ( ch->sex == SEX_FEMALE )
fight.c:                victim->name ); break;
fight.c:                ch->short_descr, victim->name, ch->in_room->name ); break;
fight.c:                victim->name, ch->short_descr ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, ch->in_room->name, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:                ch->short_descr, victim->name ); break;
fight.c:  for ( paf = victim->affected; paf; paf = paf->next )
fight.c:    if ( paf->deleted )
fight.c:  if ( ( vch = victim->hunting ) )
fight.c:    victim->hunting = NULL;
fight.c:    if ( vch->hunted == victim )
fight.c:      vch->hunted = victim->next_in_hunt;
fight.c:      victim->next_in_hunt = NULL;
fight.c:      for( rch = vch->hunted; rch; rch = rch->next_in_hunt )
fight.c:        if ( rch->next_in_hunt == victim )
fight.c:          rch->next_in_hunt = victim->next_in_hunt;
fight.c:          victim->next_in_hunt = NULL;
fight.c:  if ( ( victim->hunted ) )
fight.c:    for( vch = victim->hunted; vch; vch = rch )
fight.c:      rch = vch->next_in_hunt;
fight.c:      vch->hunting = NULL;
fight.c:      vch->next_in_hunt = NULL;
fight.c:    victim->hunted = NULL;
fight.c:  if ( ( vch = victim->assassinating ) )
fight.c:    victim->assassinating = NULL;
fight.c:    if ( vch->assassinated == victim )
fight.c:      vch->assassinated = victim->next_in_ass;
fight.c:      victim->next_in_ass = NULL;
fight.c:      for( rch = vch->assassinated; rch; rch = rch->next_in_ass )
fight.c:        if ( rch->next_in_ass == victim )
fight.c:          rch->next_in_ass = victim->next_in_ass;
fight.c:          victim->next_in_ass = NULL;
fight.c:  if ( ( victim->assassinated ) )
fight.c:    for( vch = victim->assassinated; vch; vch = rch )
fight.c:      rch = vch->next_in_ass;
fight.c:      vch->assassinating = NULL;
fight.c:      vch->next_in_ass = NULL;
fight.c:  if ( ( vch = victim->tracking ) )
fight.c:    victim->tracking = NULL;
fight.c:    if ( vch->tracked == victim )
fight.c:      vch->tracked = victim->next_in_track;
fight.c:      for( rch = vch->tracked; rch; rch = rch->next_in_track ){
fight.c:        if ( rch->next_in_track == victim )
fight.c:          rch->next_in_track = victim->next_in_track;
fight.c:    victim->next_in_track = NULL;
fight.c:  if ( ( victim->tracked ) )
fight.c:    for( vch = victim->tracked; vch; vch = rch )
fight.c:      rch = vch->next_in_track;
fight.c:      vch->tracking = NULL;
fight.c:      vch->next_in_track = NULL;
fight.c:    victim->tracked = NULL;
fight.c:  if ( ( vch = victim->rembch ) )
fight.c:  //if( ( vch = ch->rembed ))
fight.c:  //  vch->rembch = NULL;
fight.c:  if ( ( vch = victim->protecting ) )
fight.c:  if( ( vch = victim->protector )){
fight.c:  if ( victim->pcdata->clanpk )
fight.c:    victim->pcdata->clanpk = 0;
fight.c:    if ( victim->clan == clan_war->clan_a )
fight.c:      clan_war->clan_a_num --;
fight.c:        if ( victim == clan_war->clan_a_member[i] )
fight.c:          clan_war->clan_a_member[i] = NULL;
fight.c:    else if( victim->clan == clan_war->clan_b )
fight.c:      clan_war->clan_b_num --;
fight.c:        if ( victim == clan_war->clan_b_member[i] )
fight.c:          clan_war->clan_b_member[i] = NULL;
fight.c:      bugf("[clanpk]: victim %s clan %s in pk but is not a and b", victim->name, victim->clan->name);
fight.c:    if ( clan_war->clan_b_num == 0 )
fight.c:          clan_war->clan_a->name, clan_war->clan_b->name );
fight.c:      clan_war->clan_a->bank += 1000000;
fight.c:      clan_war->clan_a->warwin ++;
fight.c:      clan_war->clan_b->warlose ++;
fight.c:        if ( clan_war->clan_a_member[i] )
fight.c:          clan_war->clan_a_member[i]->pcdata->clanpk = 0;
fight.c:          clan_war->clan_a_member[i] = NULL;
fight.c:          clan_war->clan_b_member[i] = NULL;
fight.c:      clan_war->fighting = 0;
fight.c:      clan_war->clan_a = NULL;
fight.c:      clan_war->clan_b = NULL;
fight.c:      clan_war->clan_a_num = 0;
fight.c:    else if ( clan_war->clan_a_num == 0 )
fight.c:          clan_war->clan_b->name, clan_war->clan_a->name );
fight.c:      clan_war->clan_b->bank += 1000000;
fight.c:      clan_war->clan_b->warwin ++;
fight.c:      clan_war->clan_a->warlose ++;
fight.c:        if ( clan_war->clan_b_member[i] )
fight.c:          clan_war->clan_b_member[i]->pcdata->clanpk = 0;
fight.c:          clan_war->clan_b_member[i] = NULL;
fight.c:          clan_war->clan_a_member[i] = NULL;
fight.c:      clan_war->fighting = 0;
fight.c:      clan_war->clan_a = NULL;
fight.c:      clan_war->clan_b = NULL;
fight.c:      clan_war->clan_b_num = 0;
fight.c:  if ( IS_SET( victim->act, PLR_KILLER ) )
fight.c:    REMOVE_BIT( victim->act, PLR_KILLER );
fight.c:  victim->hit     = victim->max_hit;
fight.c:  victim->mana    = victim->max_mana;
fight.c:  victim->move    = victim->max_move;
fight.c:  was_in_room = victim->in_room;
fight.c:  if( get_room_index(was_in_room->area->death)){
fight.c:    char_to_room( victim, get_room_index(was_in_room->area->death ));
fight.c:  else if( get_room_index(was_in_room->area->recall)){
fight.c:    char_to_room( victim, get_room_index(was_in_room->area->recall));
fight.c:  //    if ( !IS_NPC(victim) && IS_SET( victim->act, PLR_HORSE ) && 
fight.c:  //IS_SET(victim->pcdata->horse->pcdata->ride, 2))
fight.c:  //    char_from_room(victim->pcdata->horse);
fight.c:  //  char_to_room(victim->pcdata->horse,get_room_index(was_in_room->area->recall));
fight.c:  victim->position   = POS_RESTING;
fight_check.c://*-----------------------------------------------------------------*
fight_check.c:// Not used -- head --
fight_check.c:// -- tail --
fight_check.c:	if( wield && IS_SET(wield->extra_flags, ITEM_MAGIC))
fight_check.c:		if( IS_SET(victim->special, EXPERT))
fight_check.c:			chance  = UMAX( 10, victim->level / 3 
fight_check.c:						+ UMAX( 0, victim->level 
fight_check.c:								- ( ( victim->class == 1 ) ? 30 : 60 ) ) );
fight_check.c:			chance  = UMAX( 8, victim->level / 4 
fight_check.c:						+ UMAX( 0, victim->level 
fight_check.c:								- ( ( victim->class == 1 ) ? 20 : 40 ) ) );
fight_check.c:			if ( ch->pcdata->prime_attr == APPLY_STR 
fight_check.c:					|| ch->pcdata->snd_attr == APPLY_STR )
fight_check.c:				chance -= 10;
fight_check.c:			if ( ch->pcdata->prime_attr == APPLY_DEX 
fight_check.c:					|| ch->pcdata->snd_attr == APPLY_DEX )
fight_check.c:				chance -= 20;
fight_check.c:	} else if ( victim->pcdata->learned[gsn_fool] 
fight_check.c:				+ victim->pcdata->learned[gsn_dodge] == 0 )
fight_check.c:		if (victim->pcdata->autocombat == AUTOC_DODGE ){
fight_check.c:		else if (victim->pcdata->autocombat == AUTOC_PARRY) {
fight_check.c:			mod -= get_skill_percent(victim, gsn_autoparry)/3
fight_check.c:		else if ( victim->pcdata->autocombat == AUTOC_CRITICAL ) {
fight_check.c:				<= chance - UMIN( 15, (leveldiff * 2) + (dexdiff * 4))))
fight_check.c:		chance += ppl_dex - 15;
fight_check.c:		chance  = UMIN( chance - leveldiff / 2, 40 + get_skill_level(victim, gsn_dodge) * 2);
fight_check.c:        //if( IS_SET(victim->special, EXPERT))
fight_check.c:          //  chance        = victim->level / 8 ;
fight_check.c:        if( ch->move < 16 ) return FALSE;
fight_check.c:        chance = (GET_DODGE( victim ) * -70 )/ 1000 ;
fight_check.c:        if (victim->pcdata->autocombat == AUTOC_DODGE ){
fight_check.c:        else if ( victim->pcdata->autocombat == AUTOC_CRITICAL ) {
fight_check.c:    ch->move -= 15;
fight_check.c:        if( victim->pcdata->autocombat == AUTOC_STOP ) {
fight_check.c:        else if( victim->pcdata->autocombat == AUTOC_PARRY ) {
fight_check.c:            if( victim->class == KNIGHT )
fight_check.c:        else if (victim->pcdata->autocombat == AUTOC_CRITICAL) {
fight_check.c:            mod -= get_skill_percent(victim, gsn_deadly_strike)/5+get_skill_level(victim, gsn_deadly_strike);
fight_check.c:        if( IS_SET(victim->special, EXPERT))
fight_check.c:            chance = UMIN( 16, ( victim->class == 1 ) ? victim->level - 20 : victim->level - 35 );
fight_check.c:            chance = UMIN( 10, ( victim->class == 1 ) ? victim->level - 35 : victim->level - 40 );
fight_check.c:            if ( ch->pcdata->prime_attr == APPLY_STR || ch->pcdata->snd_attr == APPLY_STR )
fight_check.c:            if ( ch->pcdata->prime_attr == APPLY_DEX || ch->pcdata->snd_attr == APPLY_DEX )
fight_check.c:        if ( victim->pcdata->learned[gsn_barehand] )
fight_check.c:    if ( number_percent( ) * 100 / mod >= chance - UMIN( 15, leveldiff ) ){ // parry failed
fight_check.c:        //if( !IS_NPC(ch) && ch->class == NINJA && fReposte && victim->class != NINJA) 
fight_check.c:            reposte  = IS_NPC( victim ) ? IS_SET( victim->class, 8 ) ? victim->level + 20 : 0
fight_check.c:                if( ch->class != NINJA && (victim->class == NINJA && !IS_NPC(victim)) 
fight_check.c:        reposte  = IS_NPC( victim ) ? IS_SET( victim->class, 8 ) ? victim->level + 20 : 0
fight_check.c:            if( ch->class != NINJA && (victim->class == NINJA && !IS_NPC(victim)) 
fight_check.c:        if(victim->pcdata->autocombat == AUTOC_PARRY){
fight_check.c:        }else if (victim->pcdata->autocombat == AUTOC_DODGE){
fight_check.c:        }else if (victim->pcdata->autocombat == AUTOC_CRITICAL){
fight_check.c:            mod   -= get_skill_percent(victim, gsn_deadly_strike)/3+get_skill_level(victim, gsn_deadly_strike);
fight_check.c:        ( ch->pcdata->prime_attr == APPLY_STR || ch->pcdata->snd_attr == APPLY_STR ) ? 1 :
fight_check.c:        ( ch->pcdata->prime_attr == APPLY_DEX || ch->pcdata->snd_attr == APPLY_DEX ) ? 2 : 0;
fight_check.c:        if( IS_SET(victim->special, EXPERT))
fight_check.c:            chance	= UMIN( 80, ( weight +  victim->level ) / 2 - class_bonus * 15 );
fight_check.c:            chance	= UMIN( 60, ( weight +  victim->level ) / 3 - class_bonus * 8 );
fight_check.c:    if(URANGE(2 + get_curr_str(victim) / 3, chance - UMAX( 0, leveldiff ), 60 ) < number_percent( ) * 100 / mod)
fight_check.c:    break_shield = ( IS_NPC( ch ) ) ? IS_SET( ch->class, 8 ) ? ch->level : 0
fight_check.c:    if ( !IS_NPC( victim) && get_skill_level( victim, gsn_block) > 3 && victim->pcdata->prime_attr == APPLY_STR )
fight_check.c:    	break_shield = break_shield - get_skill_level(victim,gsn_block ) - get_skill_level(victim,gsn_block)/3 ;
fight_check.c:        if ( number_bits(3) == 1 && !IS_SET(obj->extra_flags,ITEM_NOREMOVE)){
fight_check.c:                obj_to_room( obj, victim->in_room );
fight_check.c:    if ( obj && (obj->hp|| obj->material->hp) ){
fight_check.c:        OBJ_HP * ohp = obj->hp;
fight_check.c:        for( ; ohp; ohp = ohp->next ){
fight_check.c:            if( IS_SET( ohp->event, HP_BLOCK) )
fight_check.c:            if ( ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_ARTIFACT ) && 
fight_check.c:                 ( artifact(victim) * ohp->percent *  get_curr_wis( victim ) / 2500 + 
fight_check.c:              || ( IS_NPC( victim ) && ohp->percent * get_curr_wis( victim ) / 25 
fight_check.c:                trigger_obj_hp(obj, skill_lookup(ohp->hp_name), ohp->level, victim, ch);
fight_check.c:        if( obj->material->hp ) {
fight_check.c:            for( ohp=obj->material->hp ; ohp; ohp = ohp->next ){
fight_check.c:                if( IS_SET( ohp->event, HP_BLOCK) )
fight_check.c:                    if( ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_ARTIFACT ) && 
fight_check.c:                         (  artifact(victim) * ohp->percent * get_curr_wis( victim ) / 2500 +
fight_check.c:                      ||( IS_NPC( victim ) && ohp->percent * get_curr_wis( victim ) / 25
fight_check.c:                        trigger_obj_hp(obj, skill_lookup(ohp->hp_name), ohp->level, victim, ch);
fight_check.c:			obj_to_room( obj, victim->in_room );
fight_check.c:		obj_to_room( obj, victim->in_room );*/
fight_check.c:	    // if( !IS_NPC( ch ) &&!IS_SET( ch->act, PLR_CHINESE ) )
fight_check.c:    else if ( !IS_SET( ch->act, ACT_TACTICS ) )
fight_check.c:        chance = UMIN( 30, ch->level / 2 );
fight_check.c:        if( IS_SET(victim->special, EXPERT))
fight_check.c:            chance        = UMAX( 10, victim->level / 3 + UMAX( 0, victim->level - ( ( victim->class == 1 ) ? 30 : 60 ) ) );
fight_check.c:            chance        = UMAX( 8, victim->level / 4 + UMAX( 0, victim->level - ( ( victim->class == 1 ) ? 20 : 40 ) ) );
fight_check.c:        if (victim->pcdata->autocombat == AUTOC_DODGE ){
fight_check.c:        else if (victim->pcdata->autocombat == AUTOC_PARRY) {
fight_check.c:            mod -= get_skill_percent(victim, gsn_autoparry) / 3 + get_skill_level(victim, gsn_autoparry);
fight_check.c:        else if ( victim->pcdata->autocombat == AUTOC_CRITICAL ) {
fight_check.c:        chance += ppl_dex - 15;
fight_check.c:        chance  = UMIN( chance - leveldiff / 2, 40 + get_skill_level(victim, gsn_dodge) * 2);
fight_check.c:    if ( IS_NPC( ch ) && ( IS_AFFECTED( ch, AFF_CHARM ) || IS_AFFECTED( ch, AFF_SUMMONED) || ch->clan )
fight_check.c:		&& ch->master && !IS_NPC( ch->master ) )
fight_check.c:	ch = ch->master;
fight_check.c:	if ( IS_NPC( victim ) && victim->qmark && !str_cmp( victim->qmark->mark_name, "gated_mob" ) &&
fight_check.c:		victim->protecting )
fight_check.c:		victim = victim->protecting;//I supposed the qmark "gated mob" is the toppest qmark on the gated mob
fight_check.c:	    && !IS_AFFECTED(victim, AFF_SUMMONED) && !victim->master )
fight_check.c:    	&& victim->master && !IS_NPC(victim->master))
fight_check.c:	victim = victim->master;
fight_check.c:    if( ch->in_room != victim->in_room )
fight_check.c:    if( IS_SET(victim->in_room->room_flags, ROOM_PK))
fight_check.c:	|| victim->level > LEVEL_HERO + 5 )
fight_check.c:    if ( IS_SET( victim->act, PLR_KILLER )
fight_check.c:	|| IS_SET( victim->act, PLR_THIEF )
fight_check.c:	|| ( IS_SET( ch->act, PLR_KILLER ) && ch->fighting ) )
fight_check.c:    if ( victim->race == race_lookup( "Vampire" ) )
fight_check.c:	    && ch->level - victim->level < 6 )
fight_check.c:    if ( ( ch->level - victim->level > 5 && victim->fighting != ch )
fight_check.c:	sprintf( buf, "±Ï©R°Ú¡I  %s ¥¿¦b§ðÀ»§Ú¡I", ch->name );
fight_check.c:	SET_BIT( ch->act, PLR_KILLER );
fight_check.c:	for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
fight_check.c:			SET_BIT( ch->act, PLR_KILLER );
fight_check.c:	gain_exp( ch, -600 );
fight_check.c:	for ( obj = ch->carrying; obj; obj = obj_next )
fight_check.c:	    obj_next = obj->next_content;
fight_check.c:	    if ( obj->deleted )
fight_check.c:	    if ( IS_SET( obj->wear_flags , ITEM_WEAR_RIDE ) )
fight_check.c:	    if ( IS_SET( obj->extra_flags, ITEM_INVENTORY ) )
fight_check.c:	&& IS_SET( obj->extra_flags, ITEM_POISONED )
fight_check.c:	&& obj->value[3] != 14 )
fight_check.c:    if( victim->in_room && IS_SET(victim->in_room->room_flags, ROOM_SAFE)){
fight_check.c:    if( !IS_NPC(ch) && IS_AFFECTED(ch,AFF_CHARM) && ch->group && ch->group->leader == victim ) {
fight_check.c:    if( victim->in_room && IS_SET(victim->in_room->room_flags, ROOM_PK))
fight_check.c:	if( IS_SET( race_table[ victim->race ].race_abilities, RACE_VAMPIRE ) )
fight_check.c:    if ( ch == victim && !IS_SET( victim->act, PLR_HORSE ) )
fight_check.c:	    if ( ch->qmark && !str_cmp( ch->qmark->mark_name, "gated_mob" ) && ch->protecting && 
fight_check.c:		!IS_NPC( ch->protecting ) && !IS_SET( ch->protecting->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "¹ï¤è¨S°Ñ¥[ PK ¡I", ch->protecting );
fight_check.c:		if ( IS_AFFECTED( ch, AFF_SUMMONED ) && ch->rembch && 
fight_check.c:		!IS_SET( ch->rembch->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "¹ï¤è¨S°Ñ¥[ PK ¡I", ch->protecting );
fight_check.c:	    if ( ch->qmark && !str_cmp( ch->qmark->mark_name, "gated_mob" ) && ch->protecting && 
fight_check.c:		!IS_NPC( ch->protecting ) && !IS_SET( ch->protecting->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "¥¦ªº¥D¤H¨S°Ñ¥[ PK ¡I", ch->protecting );
fight_check.c:		if ( IS_AFFECTED( ch, AFF_SUMMONED ) && ch->rembch && 
fight_check.c:		!IS_SET( ch->rembch->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "¥¦ªº¥D¤H¨S°Ñ¥[ PK ¡I", ch->protecting );
fight_check.c:		if ( victim->qmark && !str_cmp( victim->qmark->mark_name, "gated_mob" ) && victim->protecting && 
fight_check.c:		!IS_NPC( victim->protecting ) && !IS_SET( victim->protecting->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "¥¦ªº¥D¤H¨S°Ñ¥[ PK ¡I", victim->protecting );
fight_check.c:		if ( IS_AFFECTED( victim, AFF_SUMMONED ) && victim->rembch && 
fight_check.c:		!IS_SET( victim->rembch->act, PLR_REGISTER ) )
fight_check.c:			send_to_char( "¥¦ªº¥D¤H¨S°Ñ¥[ PK ¡I", victim->protecting );
fight_check.c:		if ( victim->qmark && !str_cmp( victim->qmark->mark_name, "gated_mob" ) && victim->protecting && 
fight_check.c:		!IS_NPC( victim->protecting ) && !IS_SET( victim->protecting->act, PLR_REGISTER ) )
fight_check.c:		if ( IS_AFFECTED( victim, AFF_SUMMONED ) && victim->rembch && 
fight_check.c:		!IS_SET( victim->rembch->act, PLR_REGISTER ) )
fight_check.c:    if ( IS_SET( victim->act, PLR_KILLER )
fight_check.c:	|| IS_SET( victim->act, PLR_THIEF ) )
fight_check.c:    if ( ch->level < 16 && !ch->fighting )
fight_check.c:    if ( victim->level < 25 )
fight_check.c:    if( !IS_SET(ch->act, PLR_REGISTER)) {
fight_check.c:    if ( ch->level >= L_APP )
fight_check.c:    if ( victim->fighting )
fight_check.c:            if( victim->class >BARBARIAN ){
fight_check.c:                gain_exp(victim,  - victim->exp / ( 65 - victim->level / 4));
fight_check.c:            if( victim->class <= BARBARIAN ) {
fight_check.c:                gain_exp(victim,  - victim->exp / ( 85 - victim->level / 4));
fight_check.c:    sprintf(buf_q, "corpse_count_%d", ch->pIndexData->vnum);
fight_check.c:    if( victim->in_room ) {
fight_check.c:	//for ( obj = victim->in_room->contents; obj; obj = obj->next_content )
fight_check.c:	//	if ( is_name( victim->name, obj->short_descr ) )
fight_check.c:	    count = qm->v0;
fight_check.c:	    count -= 2;
fight_check.c:      victim->exp = victim->exp - 100 * count * count;
fight_check.c:	    victim->max_hit -= count * count;
fight_check.c:	    victim->max_hit = UMAX( victim->max_hit, 1);
fight_check.c:      if (ch->clan){
fight_check.c:          ch->clan->score -=  500*ch->level ;
fight_check.c:          ch->clan->bank -= UMAX( 0, 500*ch->level * 2 );
fight_check.c:          ch->pcdata->clanexp -= 500*ch->level;
fight_check.c:            if (victim->exp <= EXP_PER_LEVEL(victim->level-1,victim->class) * victim->level )
fight_check.c:            if( victim->class > BARBARIAN ){
fight_check.c:                gain_exp(victim,  - victim->exp / ( 60 - victim->level / 4));
fight_check.c:            if( victim->class <= BARBARIAN ) {
fight_check.c:                gain_exp(victim,  - victim->exp / ( 80 - victim->level / 4));
fight_check.c:            victim->exp = UMAX(victim->exp, EXP_PER_LEVEL(victim->level -1,victim->class) * victim->level);
fight_check.c:    if( !IS_NPC(ch) ) return ch->fighting;
fight_check.c:    if( IS_SET(ch->special, MOBAI_LV3)){
fight_check.c:	SET_BIT(ch->act, ACT_MOB_AI);
fight_check.c:    else if (IS_SET(ch->special, MOBAI_LV2)){
fight_check.c:	SET_BIT(ch->act, ACT_MOB_AI);
fight_check.c:    CHAR_DATA *victim = ch->fighting, *rch;
fight_check.c:    if ( victim->level > 35 && ch->level > 45 &&
fight_check.c:	    ( number_percent( ) < IS_SET( ch->act, ACT_MOB_AI ) ? 
fight_check.c:	      ch->level : ch->level - 45  ) )
fight_check.c:	for( rch = ch->in_room->people; rch; rch = rch->next_in_room ){
fight_check.c:	    if ( rch->fighting == ch && !rch->deleted )
fight_check.c:		if ( ch->hitroll < - GET_DODGE( rch ) / 8 )
fight_check.c:		if ( rch->class == MONK || rch->class == WARLORD 
fight_check.c:		   || rch->class == ALCHEMIST ||rch->class == MARTIALMAN )
fight_check.c:		if ( rch->class == SAVANT || rch->class == BISHOP )
fight_check.c:		if ( rch->class != SHAMAN && number_bits(3) == 1 )
fight_check.c:    CHAR_DATA *victim = ch->fighting, *rch;
fight_check.c:    if( ch && ch->class && (IS_SET(ch->class, 16) || IS_SET(ch->class, 2)))
fight_check.c:	    min = ch->fighting->hit * 5 - GET_AC(ch->fighting) * 3;
fight_check.c:	    if ( victim->level > 35 && ch->level > 45 &&
fight_check.c:		    ( number_percent( ) < IS_SET( ch->act, ACT_MOB_AI ) ? 
fight_check.c:		      ch->level : ch->level - 45 ))
fight_check.c:		for( rch = ch->in_room->people; rch; rch = rch->next_in_room ){
fight_check.c:		    if ( rch->fighting == ch && !rch->deleted )
fight_check.c:			if ( ch->hitroll < - GET_DODGE( rch ) / 8 )
fight_check.c:			if( rch->hit * 5 - GET_AC(rch) * 3 < min ){
fight_check.c:			    min = rch->hit*5- GET_AC(rch) * 3 ;
fight_check.c:	    min = victim->saving_throw[0] * -3 + victim->hit;
fight_check.c:	    if ( victim->level > 35 && ch->level > 45 &&
fight_check.c:		    ( number_percent( ) < IS_SET( ch->act, ACT_MOB_AI ) ? 
fight_check.c:		      ch->level : ch->level - 45 ))
fight_check.c:		for( rch = ch->in_room->people; rch; rch = rch->next_in_room ){
fight_check.c:		    if ( rch->fighting == ch && !rch->deleted )
fight_check.c:			if( rch->saving_throw[0] * -3 + rch->hit < min ){
fight_check.c:			    min = rch->saving_throw[0] * -3 + rch->hit;
fight_check.c:	CHAR_DATA *victim = ch->fighting, *rch;
fight_check.c:	if ( victim->level > 35 && ch->level > 45 &&
fight_check.c:			( number_percent( ) < IS_SET( ch->act, ACT_MOB_AI ) ? 
fight_check.c:			  ch->level : 
fight_check.c:			  ch->level - 45 + ( victim->class == SHAMAN ? 20 : 0 ) ) )
fight_check.c:		for( rch = ch->in_room->people; rch; rch = rch->next_in_room ){
fight_check.c:			if ( rch->fighting == ch && !rch->deleted )
fight_check.c:				if ( !rch->class )
fight_check.c:				if ( ch->hitroll < - GET_DODGE( rch ) / 8 )
fight_check.c:				if ( rch->class == SAVANT || rch->class == BISHOP )
fight_check.c:				else if( rch->class == WIZARD || rch->class == ALCHEMIST )
fight_check.c:				else if( rch->class == LORD )
fight_check.c:				else if ( rch->class == CLERIC || rch->class == MAGE )
fight_check.c:				if ( rch->class != SHAMAN && number_bits(2) == 1 )
fight_check.c:    if ( ch->race == race_lookup( "Vampire" ) )
fight_check.c:    if ( !IS_SET( ch->act, PLR_REGISTER ) )
fight_check.c:    if ( ch->fighting )
fight_check.c:    for ( obj = ch->carrying; obj; obj = obj->next_content )
fight_check.c:	if ( obj->pIndexData->vnum == OBJ_VNUM_LICENSE )
fight_check.c:    if( ch->in_room == victim->in_room && IS_SET(victim->in_room->room_flags, ROOM_PK))
fight_check.c:    if ( IS_SET( victim->act, PLR_REGISTER ) )
fight_check.c:    if ( ch->race == race_lookup( "Vampire" ) )
fight_check.c: * -Kahn
fight_check.c:    for ( victim = ch->in_room->people; victim; victim = victim_next )
fight_check.c:	victim_next = victim->next_in_room;
fight_check.c:	if ( victim->deleted )
fight_check.c:		    && victim->race != race_lookup( "Vampire" ) ) ) )
fight_check.c:	(*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
fight_check.c: * -Kahn
fight_check.c:    for ( victim = ch->in_room->people; victim; victim = victim_next )
fight_check.c:	victim_next = victim->next_in_room;
fight_check.c:	if ( victim->deleted )
fight_check.c:		    && victim->race != race_lookup( "Vampire" ) ) ) )
fight_check.c:	(*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
fight_check.c:    for ( victim = ch->in_room->people; victim; victim = victim_next )
fight_check.c:	victim_next = victim->next_in_room;
fight_check.c:	if ( victim->deleted )
fight_check.c:		    && victim->race != race_lookup( "Vampire" ) ) ) )
fight_check.c:	(*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
fight_check.c:	////damage( ch, victim, number_range( 1, ch->level ), gsn_poison_weapon, WEAR_NONE );
fight_check.c:	damage( ch, victim, number_range( 1, ch->level ), gsn_poison_weapon, WEAR_NONE, MSG_NORMAL, DMG_NORMAL );
fight_check.c:    if ( ch->race == race_lookup( "Dragon" ) )
fight_check.c:	if ( number_percent( ) < ch->level )
fight_check.c:    if ( ch->race == race_lookup( "Harpy" ) )
fight_check.c:	if ( number_percent( ) < ch->level )
fight_check.c:    if ( ch->race == race_lookup( "Arachnid" )
fight_check.c:	|| ch->race == race_lookup( "Snake" ) )
fight_check.c:	if ( number_percent( ) < ch->level )
fight_check.c:    //----®£Äßª¬ºA·|¦Û°Ê°k¶]
fight_check.c:	if (    (    IS_SET( victim->act, ACT_WIMPY )
fight_check.c:                  && victim->hit < victim->max_hit / 2 
fight_check.c:                  && victim->wait == 0 )
fight_check.c:                       || victim->clan )
fight_check.c:                  && victim->master && victim->in_room 
fight_check.c:                  && victim->master->in_room != victim->in_room ) )
fight_check.c:    	if(    victim->hit   > 0
fight_check.c:            && victim->hit  <= victim->wimpy 
fight_check.c:            && victim->wait < 3 )
fight_check.c:        ref_cost = UMAX(2, ref_cost - get_skill_level(ch, gsn_reflexion)*4);
fight_check.c:                       && IS_SET( victim->act, ACT_REFLEXION ) ) )
fight_check.c:             && victim->move > ref_cost )
fight_check.c:            if(IS_SET( race_table[ victim->race ].race_abilities, RACE_BEHOLDER )){
fight_check.c:            chance -= dexdiff * 3;
fight_check.c:                    chance = URANGE( 5, chance - dexdiff * 5 - ( dt == gsn_frenzy ? 20 : 0) , 110 )
fight_check.c:              chance = URANGE( 5, chance - dexdiff * 10 - ( dt 
fight_check.c:                    victim->move -= ref_cost;
fight_check.c:    if( ch->level > 29 )
fight_check.c:        dam = UMAX(1, dam - ( dam / 4) + 1);
fight_check.c:    if( ch->level > 49 )
fight_check.c:        dam = UMAX(1, dam - ( dam / 5) + 1);
fight_check.c:    //dam = UMAX(1, dam - ( dam / 4) + 1);
fight_check.c:    if( IS_NPC(ch) && IS_SET(ch->special, SPELL_FURY) )
fight_check.c:        if( number_percent() < ch->level + 10 )
fight_check.c:        if( IS_SET(ch->special, EXPERT) && number_percent() < ch->level / 3 )
fight_check.c:    if ( victim->position >= POS_SLEEPING )
fight_check.c:	if ( !victim->fighting )
fight_check.c:	if ( !ch->fighting )
fight_check.c:	     && victim->master
fight_check.c:	     && ch->in_room
fight_check.c:             && victim->master != ch
fight_check.c:	     && victim->master->in_room == ch->in_room
fight_check.c:    	    set_fighting( ch, victim->master );
fight_check.c:    	    return -1;
fight_check.c:    if ( victim->master == ch )
fight_check.c:        REMOVE_BIT( victim->affected_by, AFF_SUMMONED );
fight_check.c:        REMOVE_BIT( victim->affected_by, AFF_CHARM );
fight_check.c:    if( !victim || ( victim == NULL ) || victim->deleted)
fight_check.c:    if( ch->deleted )
fight_check.c:    if( ch->position == POS_PARALYZED )
fight_check.c:        if(ch->pcdata->autocombat == AUTOC_STOP) return FALSE;
fight_check.c:        if(ch->pcdata->autocombat == AUTOC_DODGE) return FALSE;
fight_check.c:        if(ch->pcdata->autocombat == AUTOC_PARRY) return FALSE;
fight_check.c:        if(ch->pcdata->autocombat == AUTOC_CONCENTRATION) return FALSE;
fight_check.c:        if(ch->pcdata->autocombat == AUTOC_INSTANT) return FALSE;
fight_check.c:    if( !IS_NPC(ch) && ch->position == POS_RESTING )
fight_check.c:    if( ch->wait > 0 ) return FALSE;
fight_damage.c://*---------------------------------------------------------------*
fight_damage.c://*---------------------------------------------------------------*
fight_damage.c://*---------------------------------------------------------------*
fight_damage.c:        nDmgRate  =  92 - nRideSklv * 2;
fight_damage.c:        nDmgRate  = 120 - nRideSklv * 3;
fight_damage.c:        nDmgRate = 120 - nRideSklv * 3;
fight_damage.c:        nDmgRate =  92 - nRideSklv * 2;
fight_damage.c:    if(IS_SET( race_table[ victim->race ].race_abilities, RACE_PROTECTION )){
fight_damage.c:            nDamageRate   = 85 - ((nIbaSklv + 1) / 2) * 5;
fight_damage.c:    int  leveldiff = ch->level - victim->level;
fight_damage.c:    int  intdiff = get_curr_int( ch ) - get_curr_int( victim );
fight_damage.c:    int  dexdiff = get_curr_dex( ch ) - get_curr_dex( victim );
fight_damage.c:    if ( victim->position == POS_DEAD )
fight_damage.c:        return -2;
fight_damage.c:    //    if( victim->in_room && IS_SET(victim->in_room->room_flags, ROOM_SAFE)){
fight_damage.c:                if(nEnemyAC <= -1000){
fight_damage.c:                    dam = dam * 2000 / (1600 - (nArmor));
fight_damage.c:            ch->attacked = victim;
fight_damage.c:    // hobbit ---/ran [Shot(6), Mete(6), WIS(21)] = ((60 + 60) / 3) * (16 * 16 / 400) = 25.6%
fight_damage.c:                         * (get_curr_wis(ch) - 4) * (get_curr_wis(ch) - 4) / 400;
fight_damage.c:        dam += ch->apdr;
fight_damage.c:            if(!IS_NPC(ch)) dam += ch->apdr * nSklvShot / 4;
fight_damage.c:                if(victim->pdr >= 0 && number_percent() >= nRateIgnorePDR){
fight_damage.c:                    dam -= victim->pdr * 2;
fight_damage.c:                dam -= victim->pdr * 3;
fight_damage.c:            dam -= victim->pdr;
fight_damage.c:    if( IS_NPC(victim) && dam < victim->pad )
fight_damage.c:        if( !IS_NPC(ch) && ch->class == KNIGHT && number_bits(2) >= 1 )
fight_damage.c:        if ( IS_NPC( ch ) && ch->desc )
fight_damage.c:            bugf("Damage: %d from %s by %s: > 2000 points with %d dt!",dam, ch->name, ch->desc->original->name, dt );
fight_damage.c:            bugf("Damage: %d from %s: > 2000 points with %d dt!",dam, ch->name, dt );
fight_damage.c:        if ( IS_AFFECTED( ch, AFF_INVISIBLE ) && !IS_SET(ch->special, ALY_INVIS))
fight_damage.c:            REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight_damage.c:        if ( IS_AFFECTED( ch, AFF_HIDE ) && !IS_SET(ch->special, ALY_HIDE) )
fight_damage.c:            REMOVE_BIT( ch->affected_by, AFF_HIDE );
fight_damage.c:            return -2;
fight_damage.c:                ( !IS_NPC( victim ) && victim->pcdata->clanpk 
fight_damage.c:                  && IS_SET(victim->in_room->room_flags, ROOM_PK) ) )
fight_damage.c:            return -2;
fight_damage.c:                  || IS_SET( race_table[ victim->race ].race_abilities,RACE_PROTECTION )  )
fight_damage.c:            dam -= dam / 4;
fight_damage.c:        if ( dam < -1 )
fight_damage.c:            REMOVE_BIT(victim->affected_by, AFF_CAST_ACC);
fight_damage.c:                            return -1;
fight_damage.c:                            return -1;
fight_damage.c:                      && ch->pcdata->prime_attr != APPLY_CON) )
fight_damage.c:                         && ch->level > 10
fight_damage.c:                            < UMIN( ( leveldiff + intdiff * 4 ), ( IS_SET( ch->class, 1 ) ? 15 : 3 ) ) )
fight_damage.c:                         && (    ch->pcdata->prime_attr == APPLY_STR
fight_damage.c:                              || ch->class == 13 )
fight_damage.c:                         && IS_SET( race_table[ ch->race ].race_abilities,RACE_WEAPON_WIELD )
fight_damage.c:                         && number_percent() < UMIN( 25, UMAX( 10, ch->level ) )
fight_damage.c:                        if (    ch->deleted
fight_damage.c:                             || victim->deleted
fight_damage.c:                             || !ch->in_room
fight_damage.c:                             || ch->in_room != victim->in_room
fight_damage.c:                             || !ch->fighting )
fight_damage.c:                            return -2;
fight_damage.c:                                return -1;
fight_damage.c:                                && victim->class == KNIGHT
fight_damage.c:                                && victim->pcdata->prime_attr == APPLY_STR)
fight_damage.c:                        //¶¡»Ø¤ÏÀ» ¦³¾÷·|³Q dodge tactics ÀÉ±¼.......¦ý¬O, ³o­Ó§PÂ_À³¸Ó¶]¤£¨ì§a -_-
fight_damage.c:                                return -1;
fight_damage.c:                                return -1;
fight_damage.c:                     && victim->class == KNIGHT
fight_damage.c:                     && victim->pcdata->prime_attr == APPLY_STR)
fight_damage.c:                    return -1;
fight_damage.c:              || IS_SET( race_table[ victim->race ].race_abilities,RACE_SANCT )  )    )
fight_damage.c:     * damage is ok to avoid like mortally wounded damage - Kahn
fight_damage.c:	  //if ( ( !IS_NPC( ch ) && !IS_SET( ch->act, PLR_CHINESE ) )
fight_damage.c:	  //  || ( IS_NPC( ch ) && !IS_NPC( victim ) && !IS_SET( victim->act, PLR_CHINESE ) ) )
fight_damage.c:    victim->hit -= UMAX(dam, 0);
fight_damage.c:        if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_damage.c:        if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_damage.c:         && victim->hit < 1 )
fight_damage.c:        victim->hit = 1;
fight_damage.c:         && ( dam > -1 )
fight_damage.c:         && victim->hit > 0 
fight_damage.c:         && victim->mana > 7 )
fight_damage.c:        victim->mana -= 7;
fight_damage.c:            victim->mana += get_skill_level(victim, gsn_spellmaster) - 3;
fight_damage.c:        (*skill_table[sntemp].spell_fun) ( gsn_flaming_armor, ( victim->level / 2 ),victim, ch );
fight_damage.c:        if (    victim->deleted
fight_damage.c:             || ch->deleted
fight_damage.c:             || !ch->in_room
fight_damage.c:             || ch->in_room != victim->in_room )
fight_damage.c:         && victim->position <= POS_STUNNED )
fight_damage.c:         &&   saves_spell( ch->level, victim ) + 20
fight_damage.c:         && victim->race != race_lookup ( "Vampire" )
fight_damage.c:         && victim->race != race_lookup ( "Undead" ) )
fight_damage.c:        af.modifier  = -2;
fight_damage.c:    //§ó·sÂù¤èªºª¬ºA--¯¸µÛ, ¾Ô°«, ¥ð®§, ³Â·ô, ºÎÄ±, STUN, µ¥¦º, ¦º±¼
fight_damage.c:    if ( !IS_AWAKE( victim ) && victim->fighting )
fight_damage.c:    if ( victim->position == POS_DEAD )
fight_damage.c:        {   //³oÃä¬O ch(victim) ³Q orig ªº¤Ï¦V¥´¦º -_-
fight_damage.c:            if( victim->in_room )
fight_damage.c:                victim->short_descr, victim->name, orig->short_descr, orig->name,
fight_damage.c:                victim->in_room->vnum );
fight_damage.c:            if ( victim->in_room && !IS_SET(victim->in_room->room_flags, ROOM_PK))
fight_damage.c:                    gold = victim->gold * number_range( 10, 20 ) / 100;
fight_damage.c:                    orig->gold += gold;
fight_damage.c:                    victim->gold -= gold;
fight_damage.c:             && !IS_SET( victim->act, PLR_HORSE ) )
fight_damage.c:            victim->deleted = FALSE;
fight_damage.c:            sprintf(cbuf, "coins 'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( orig->act, PLR_AUTOGOLD ) )
fight_damage.c:            if( IS_SET(orig->act, PLR_AUTOSPLIT) && split > 100)
fight_damage.c:            sprintf(cbuf, "all 'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( orig->act, PLR_AUTOLOOT ) )
fight_damage.c:                sprintf(cbuf, "in 'corpse %s'", victim->name);
fight_damage.c:            sprintf(cbuf, "'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( orig->act, PLR_AUTOSAC  ) )
fight_damage.c:            sprintf(cbuf, "coins 'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( ch->act, PLR_AUTOGOLD ) )
fight_damage.c:            if( IS_SET(ch->act, PLR_AUTOSPLIT) && split > 100)
fight_damage.c:            sprintf(cbuf, "all 'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( ch->act, PLR_AUTOLOOT ) )
fight_damage.c:                sprintf(cbuf, "in 'corpse %s'", victim->name);
fight_damage.c:            sprintf(cbuf, "'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( ch->act, PLR_AUTOSAC  ) )
fight_damage.c:                do_sacrifice( ch, victim->name );
fight_damage.c:        if ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_DENY ) )
fight_damage.c:         && !IS_SET( victim->act, PLR_HORSE )
fight_damage.c:         && !victim->desc
fight_damage.c:         && !IS_SET( victim->pcdata->ride, 2 ) )
fight_damage.c:        if ( number_range( 0, victim->wait ) == 0 )
fight_damage.c:    if ( victim->position == POS_DEAD ) return;
fight_damage.c:    if( ch->in_room != victim->in_room ) return;
fight_damage.c:            dam += ch->amdr;
fight_damage.c:        if( IS_NPC(victim) && dam < victim->mad )
fight_damage.c:    if ( IS_NPC( ch ) && ch->desc )
fight_damage.c:              bugf( "Damage: %d from %s by %s: > 2000 points with %d dt!",dam, ch->name, ch->desc->original->name, dt );
fight_damage.c:              bugf("Damage: %d from %s: > 2000 points with %d dt!",dam, ch->name, dt );
fight_damage.c:        if ( IS_AFFECTED( ch, AFF_INVISIBLE ) && !IS_SET(ch->special, ALY_INVIS))
fight_damage.c:            REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight_damage.c:        if ( IS_AFFECTED( ch, AFF_HIDE ) && !IS_SET(ch->special, ALY_HIDE) )
fight_damage.c:            REMOVE_BIT( ch->affected_by, AFF_HIDE );
fight_damage.c:            if(!IS_NPC(ch) && ch->class == WIZARD)
fight_damage.c:     * damage is ok to avoid like mortally wounded damage - Kahn
fight_damage.c:    victim->hit -= UMAX(dam,0);
fight_damage.c:         && victim->hit < 1 )
fight_damage.c:        victim->hit = 1;
fight_damage.c:         && victim->position <= POS_STUNNED )
fight_damage.c:    if ( !IS_AWAKE( victim ) && victim->fighting )
fight_damage.c:    if ( victim->position == POS_DEAD )
fight_damage.c:            if( victim->in_room )
fight_damage.c:        sprintf( log_buf, "%s(%s)³Q%s(%s)±þ©ó%d",victim->short_descr,
fight_damage.c:                 victim->name, orig->short_descr, orig->name,victim->in_room->vnum );
fight_damage.c:          //if ( victim->exp > EXP_PER_LEVEL( victim->level -2 ) * ( victim->level - 1 ) ){
fight_damage.c:          //      gain_exp( victim, ( EXP_PER_LEVEL( victim->level - 2 ) * ( victim->level - 1 ) 
fight_damage.c:          //             - victim->exp ) / 30 );
fight_damage.c:              if ( victim->in_room && !IS_SET(victim->in_room->room_flags, ROOM_PK))
fight_damage.c:                gold = victim->gold * number_range( 10, 20 ) / 100;
fight_damage.c:                orig->gold += gold;
fight_damage.c:                victim->gold -= gold;
fight_damage.c:    if ( !IS_NPC( victim ) && !IS_SET( victim->act, PLR_HORSE ) )
fight_damage.c:        victim->deleted = FALSE;
fight_damage.c:            sprintf(cbuf, "coins 'corpse %s'", victim->name);
fight_damage.c:              if ( IS_SET( orig->act, PLR_AUTOGOLD ) )
fight_damage.c:              if( IS_SET(orig->act, PLR_AUTOSPLIT) && split > 100)
fight_damage.c:            sprintf(cbuf, "all 'corpse %s'", victim->name);
fight_damage.c:        if ( IS_SET( orig->act, PLR_AUTOLOOT ) )
fight_damage.c:                sprintf(cbuf, "in 'corpse %s'", victim->name);
fight_damage.c:            sprintf(cbuf, "'corpse %s'", victim->name);
fight_damage.c:        if ( IS_SET( orig->act, PLR_AUTOSAC  ) )
fight_damage.c:            sprintf(cbuf, "coins 'corpse %s'", victim->name);
fight_damage.c:        if ( IS_SET( ch->act, PLR_AUTOGOLD ) )
fight_damage.c:              if( IS_SET(ch->act, PLR_AUTOSPLIT) && split > 100)
fight_damage.c:            sprintf(cbuf, "all 'corpse %s'", victim->name);
fight_damage.c:        if ( IS_SET( ch->act, PLR_AUTOLOOT ) )
fight_damage.c:                sprintf(cbuf, "in 'corpse %s'", victim->name);
fight_damage.c:            sprintf(cbuf, "'corpse %s'", victim->name);
fight_damage.c:              if ( IS_SET( ch->act, PLR_AUTOSAC  ) )
fight_damage.c:                do_sacrifice( ch, victim->name );
fight_damage.c:    if ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_DENY ) )
fight_damage.c:         && !IS_SET( victim->act, PLR_HORSE )
fight_damage.c:         && !victim->desc
fight_damage.c:         && !IS_SET( victim->pcdata->ride, 2 ) )
fight_damage.c:    if ( number_range( 0, victim->wait ) == 0 )
fight_damage.c:    if ( victim->position == POS_DEAD )
fight_damage.c:            return -1;
fight_damage.c:    if( ch->in_room != victim->in_room ) return -1;
fight_damage.c:    dam += ch->amdr;
fight_damage.c:        dam -= victim->mdr;
fight_damage.c:        if( IS_NPC(victim) && dam < victim->mad ) dam = 0;
fight_damage.c:        if ( IS_NPC( ch ) && ch->desc )
fight_damage.c:            bugf("Damage: %d from %s by %s: > 2000 points with %d dt!",dam, ch->name, ch->desc->original->name, dt );
fight_damage.c:            bugf("Damage: %d from %s: > 2000 points with %d dt!",dam, ch->name, dt );
fight_damage.c:        if ( IS_AFFECTED( ch, AFF_INVISIBLE ) && !IS_SET(ch->special, ALY_INVIS))
fight_damage.c:            REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight_damage.c:        if ( IS_AFFECTED( ch, AFF_HIDE ) && !IS_SET(ch->special, ALY_HIDE) )
fight_damage.c:            REMOVE_BIT( ch->affected_by, AFF_HIDE );
fight_damage.c:            return -1;
fight_damage.c:        if (dam < 0) dam = 0;//return -1;
fight_damage.c:             || IS_SET( race_table[ victim->race ].race_abilities,RACE_SANCT ) )
fight_damage.c:            if(!IS_NPC(ch) && ch->class == WIZARD)
fight_damage.c:        return -2;
fight_damage.c:     * damage is ok to avoid like mortally wounded damage - Kahn
fight_damage.c:            if( number_percent() < (nOrgDmg - 1000) / 50){
fight_damage.c:    victim->hit -= UMAX(dam,0);
fight_damage.c:         && victim->hit < 1 )
fight_damage.c:        victim->hit = 1;
fight_damage.c:         && victim->position <= POS_STUNNED )
fight_damage.c:    if ( !IS_AWAKE( victim ) && victim->fighting )
fight_damage.c:    if ( victim->position == POS_DEAD )
fight_damage.c:            if( victim->in_room )
fight_damage.c:                sprintf( log_buf, "%s(%s)³Q%s(%s)±þ©ó%d",victim->short_descr,
fight_damage.c:                         victim->name, orig->short_descr, orig->name,victim->in_room->vnum );
fight_damage.c:            if ( victim->in_room && !IS_SET(victim->in_room->room_flags, ROOM_PK))
fight_damage.c:                    gold = victim->gold * number_range( 10, 20 ) / 100;
fight_damage.c:                    orig->gold += gold;
fight_damage.c:                    victim->gold -= gold;
fight_damage.c:            return -1;
fight_damage.c:        if ( !IS_NPC( victim ) && !IS_SET( victim->act, PLR_HORSE ) )
fight_damage.c:            victim->deleted = FALSE;
fight_damage.c:            sprintf(cbuf, "coins 'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( orig->act, PLR_AUTOGOLD ) )
fight_damage.c:            if( IS_SET(orig->act, PLR_AUTOSPLIT) && split > 100)
fight_damage.c:            sprintf(cbuf, "all 'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( orig->act, PLR_AUTOLOOT ) )
fight_damage.c:                sprintf(cbuf, "in 'corpse %s'", victim->name);
fight_damage.c:            sprintf(cbuf, "'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( orig->act, PLR_AUTOSAC  ) )
fight_damage.c:            sprintf(cbuf, "coins 'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( ch->act, PLR_AUTOGOLD ) )
fight_damage.c:            if( IS_SET(ch->act, PLR_AUTOSPLIT) && split > 100)
fight_damage.c:            sprintf(cbuf, "all 'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( ch->act, PLR_AUTOLOOT ) )
fight_damage.c:                sprintf(cbuf, "in 'corpse %s'", victim->name);
fight_damage.c:            sprintf(cbuf, "'corpse %s'", victim->name);
fight_damage.c:            if ( IS_SET( ch->act, PLR_AUTOSAC  ) )
fight_damage.c:                do_sacrifice( ch, victim->name );
fight_damage.c:        if ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_DENY ) )
fight_damage.c:        return -1;
fight_damage.c:        return -1;
fight_damage.c:         && !IS_SET( victim->act, PLR_HORSE )
fight_damage.c:         && !victim->desc
fight_damage.c:         && !IS_SET( victim->pcdata->ride, 2 ) )
fight_damage.c:        if ( number_range( 0, victim->wait ) == 0 )
fight_damage.c:            return -1;
fight_damage.c:    return -1;
fight_hits.c://*---------------------------------------------------------------*
fight_hits.c://*---------------------------------------------------------------*
fight_hits.c://*---------------------------------------------------------------*
fight_hits.c://*---------------------------------------------------------------*
fight_hits.c:  if(IS_SET( race_table[ ch->race ].race_abilities, RACE_BEHOLDER )){
fight_hits.c:    if ( !wield || wield->value[3] != 2 )
fight_hits.c:   if(ch->class != KNIGHT) return nPerc;
fight_hits.c:  if( victim->position > POS_INCAP )
fight_hits.c:	if( !victim->fighting )
fight_hits.c:	//victim->position = POS_FIGHTING;
fight_hits.c:  if( !ch->fighting )
fight_hits.c:      ch->position = POS_FIGHTING;
fight_hits.c:  if( !IS_NPC( ch ) && ch->fighting )
fight_hits.c:        if ( ch->mana > 5 )
fight_hits.c:            ch->mana -= 5;
fight_hits.c:  if( ( protector = victim->protector ) && protector != victim ) 
fight_hits.c:      for( ; protector  && protector != protector->next_in_protect ; protector = protector ->next_in_protect ) 
fight_hits.c:               && ch->in_room
fight_hits.c:               && protector->in_room == ch->in_room  )
fight_hits.c:                   && ( protector->level + 25 > number_percent( ) ) )
fight_hits.c:                   ch->fighting = NULL; 
fight_hits.c:                   if( ch->class == RANGER )
fight_hits.c:                   	   ch->fighting = protector;
fight_hits.c:                   	   if( ch->protector)
fight_hits.c:                   	       protector->fighting = ch->protector;
fight_hits.c:                   	       victim->fighting = ch->protector;
fight_hits.c:                   ch->temp_char = protector;
fight_hits.c:                   // victim->attacked = ch;
fight_hits.c:      if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_hits.c:      if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_hits.c:  if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:      dam_message(ch, victim, -1, mydt, WEAR_WIELD);
fight_hits.c:  if( !ch->fighting 
fight_hits.c:      || !ch->in_room 
fight_hits.c:      || ch->in_room != victim->in_room 
fight_hits.c:      chance1 = ch->level << 2;
fight_hits.c:      chance2 = IS_SET( ch->class, 1 ) ? ch->level * 2 : ch->level << 1;
fight_hits.c:      chance3 = IS_SET( ch->class, 1 ) ? ch->level /2+ch->level/4: 0;
fight_hits.c:      chance4 = IS_SET( ch->class, 1 ) ? ch->level /3+ch->level/5: 0;
fight_hits.c:          ( IS_SET( race_table[ ch->race ].race_abilities, RACE_BEHOLDER ) ? 4 : 0 );
fight_hits.c:      chance1 = GetAttackChance(ch, gsn_second_attack, 2) + UMAX( 0, (ch_dex - 10) * 2 );
fight_hits.c:      chance2 = GetAttackChance(ch, gsn_third_attack,  2) + UMAX( 0, (ch_dex - 12) * 2 );
fight_hits.c:      chance3 = GetAttackChance(ch, gsn_fourth_attack, 3) + UMAX( 0, (ch_dex - 15) * 3 );
fight_hits.c:      chance4 = GetAttackChance(ch, gsn_fifth_attack,  4) + UMAX( 0, (ch_dex - 18) * 4 );
fight_hits.c:          if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_hits.c:          if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_hits.c:      if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:          dam_message(ch, victim, -1, mydt, WEAR_WIELD);
fight_hits.c:      if( !ch->fighting 
fight_hits.c:          || !ch->in_room 
fight_hits.c:          || ch->in_room != victim->in_room
fight_hits.c:          if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_hits.c:          if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_hits.c:      if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:          dam_message(ch, victim, -1, mydt, WEAR_WIELD);
fight_hits.c:      if( !ch->fighting 
fight_hits.c:          || !ch->in_room 
fight_hits.c:          || ch->in_room != victim->in_room 
fight_hits.c:         if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_hits.c:         if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_hits.c:     if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:         dam_message(ch, victim, -1, mydt, WEAR_WIELD);
fight_hits.c:     if( !ch->fighting || !ch->in_room ||ch->in_room != victim->in_room )
fight_hits.c:      if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:          dam_message(ch, victim, -1, mydt, WEAR_WIELD);
fight_hits.c:      if( !ch->fighting 
fight_hits.c:          || !ch->in_room 
fight_hits.c:          || ch->in_room != victim->in_room
fight_hits.c:      && wield->item_type == ITEM_WEAPON
fight_hits.c:      && ( ( IS_NPC( ch ) && IS_SET( ch->act, ACT_DUAL ) ) 
fight_hits.c:                       - 30 + (ch->class == KNIGHT ? 15 : 0 )
fight_hits.c:      dt = TYPE_HIT + wield->value[3];
fight_hits.c:          if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_hits.c:          if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_hits.c:      if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:          dam_message(ch, victim, -1, mydt2, WEAR_WIELD_2);
fight_hits.c:      if ( !ch->fighting 
fight_hits.c:           || ch->fighting != victim 
fight_hits.c:           || !ch->in_room 
fight_hits.c:           || ch->in_room != victim->in_room
fight_hits.c:              if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_hits.c:              if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_hits.c:          if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:              dam_message(ch, victim, -1, mydt2, WEAR_WIELD_2);
fight_hits.c:          if( !ch->fighting 
fight_hits.c:              || ch->fighting != victim 
fight_hits.c:              || !ch->in_room 
fight_hits.c:              || ch->in_room != victim->in_room
fight_hits.c:              if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_hits.c:              if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_hits.c:          if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:              dam_message(ch, victim, -1, mydt2, WEAR_WIELD_2);
fight_hits.c:          if( !ch->fighting 
fight_hits.c:              || ch->fighting != victim 
fight_hits.c:              || !ch->in_room 
fight_hits.c:              || ch->in_room != victim->in_room 
fight_hits.c:              if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_hits.c:              if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_hits.c:          if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:            dam_message(ch, victim, -1, mydt2, WEAR_WIELD_2);
fight_hits.c:          if( !ch->fighting 
fight_hits.c:              || ch->fighting != victim 
fight_hits.c:              || !ch->in_room 
fight_hits.c:              || ch->in_room != victim->in_room
fight_hits.c:             if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_hits.c:             if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_hits.c:          if( dam == -1 && !is_brief(ch, victim) ) 
fight_hits.c:              dam_message(ch, victim, -1, mydt2, WEAR_WIELD_2);
fight_hits.c:          if( !ch->fighting 
fight_hits.c:              || ch->fighting != victim 
fight_hits.c:              || !ch->in_room 
fight_hits.c:              || ch->in_room != victim->in_room
fight_hits.c:    if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_tactics] > 0)
fight_hits.c:        //chance = ( ( UMAX( 0, ( get_curr_int( ch ) - 13 ) ) << 2 ) )
fight_hits.c:    if( !IS_NPC( ch ) && IS_SET( race_table[ ch->race ].race_abilities, RACE_LIZARDMAN ) )
fight_hits.c:        if( !victim->deleted ){
fight_hits.c:            if( ch->pcdata->condition[COND_DRUNK] > 10 
fight_hits.c:                && number_percent() < UMAX(40, ch->pcdata->condition[COND_DRUNK] * 2) + nSklv * (nSklv + 4) / 2){
fight_hits.c:                int nPoisonRate = 0; if(nSklv > 3) nPoisonRate =   5 * (nSklv - 3);
fight_hits.c:                int nDamage     = dice( 4 + nSklv, ch->level + nSklv) + ch->amdr * nSklv / 5;
fight_hits.c:                nDamage    -= victim->mdr;
fight_hits.c:                if(number_percent() < nPoisonRate && !IS_SET(victim->special, NO_POISON)){
fight_hits.c:                    af.duration  = UMAX( 0, 3 + nSklv - get_curr_con(victim) / 5);
fight_hits.c:			              if( affected_value(victim, gsn_poison, APPLY_CON) > -8){
fight_hits.c:                        af.modifier = -2 * weakness_damage( victim, gsn_poison ) * 0.01;
fight_hits.c:                   && !IS_SET( victim->special, NO_BLIND )
fight_hits.c:                    af.modifier  = (-10) * weakness_damage( victim, gsn_blindness ) * 0.01;
fight_hits.c:        if( !victim->deleted )
fight_hits.c:                if(mone_hit ( ch, victim, &gsn_tactics, -2, MSG_NORMAL, DT_NOCHANGE ) >= 0
fight_hits.c:                   && !victim->deleted && number_percent() < nTripRate) {
fight_hits.c:                for( vch = ch->in_room->people; vch; vch = vch_next){
fight_hits.c:                    vch_next = vch->next_in_room;
fight_hits.c:                    if( vch->deleted ) continue;
fight_hits.c:                    if( vch->fighting != ch ) continue;
fight_hits.c:                    if( !IS_NPC(vch) && IS_SET( vch->act, PLR_WIZINVIS)) continue;
fight_hits.c:                        if(mone_hit ( ch, vch, &gsn_tactics, -2, MSG_NORMAL, DT_NOCHANGE ) >= 0
fight_hits.c:                           && !vch->deleted && number_percent() < nTripRate) {
fight_hits.c:            && (fCritical || ch->pcdata->learned[gsn_critical] + nSklv * 4 > number_percent())
fight_hits.c:            && ( chance +=  (ch->class == ASSASSIN && ch->pcdata->prime_attr == APPLY_DEX ) ? 18
fight_hits.c:                        :( ch->class == ASSASSIN ) ? 10
fight_hits.c:                        :( ch->class == MONK ) ? 12
fight_hits.c:                        :( ch->class == NINJA && ch->pcdata->prime_attr == APPLY_DEX ) ? 14
fight_hits.c:                        :( ch->class == RANGER && ch->pcdata->prime_attr == APPLY_DEX ) ? 14
fight_hits.c:                        :( ch->class == RANGER ) ? 8
fight_hits.c:                        :( ch->class == NINJA )? 8
fight_hits.c:                        :( ch->pcdata->prime_attr == APPLY_DEX )  ? 4
fight_hits.c:             && (IS_SET( ch->act, ACT_CRITICAL ) || IS_SET( ch->class, 4 ) )
fight_hits.c:	           && ( chance = UMIN( 30, ch->level >> 1 ) ) ) )
fight_hits.c:        // ÂÂª© Sklv ¼vÅT MAX: 6 + 3 + 2 = 11  -> 29
fight_hits.c:    int        dam=-2;
fight_hits.c:    //    int leveldiff = ch->level - victim->level;
fight_hits.c:    int        dexdiff = get_curr_dex( ch ) - get_curr_dex( victim );
fight_hits.c:            return -2;
fight_hits.c:     * Guard against weird room-leavings.
fight_hits.c:    if ( victim->position == POS_DEAD|| !ch->in_room || ch->in_room != victim->in_room ){
fight_hits.c:        sprintf( buf, "one_hit: ch %s not with victim %s, or victim POS_DEAD",ch->name, victim->name );
fight_hits.c:        return -2;
fight_hits.c:    if ( !IS_NPC(ch) && IS_SET( ch->pcdata->autocombat, AUTOC_CRITICAL) && ch->move > 10){
fight_hits.c:            return -2;
fight_hits.c:        ch->move = UMAX( 0 , ch->move - 10 );
fight_hits.c:        if ( ch->move > 3 )
fight_hits.c:            ch->move -= 3;
fight_hits.c:            if ( wield->value[3] == 14 ){ // ªZ¾¹§ðÀ»«¬ºA¬° ®g¥X½b¥Ú shot
fight_hits.c:                        for( vch = ch->in_room->people; vch; vch = vch->next_in_room ){
fight_hits.c:                            if ( !vch->deleted && vch->fighting == ch && !IS_NPC( ch ) )
fight_hits.c:                    && arrow->item_type == ITEM_ARROW
fight_hits.c:                    && arrow->value[0] > 0 ){
fight_hits.c:                    arrow->value[0] -= (    IS_NPC( ch ) && !ch->clan 
fight_hits.c:									  //  ch ¨S³Q¥´, ¥B½b°¦¼Æ¬° 0, °tÅ]ªk½b¥B mana > 1 , ®g¤@µo, ³oÔ£©Ç³]©w -_-
fight_hits.c:                    if( !IS_NPC(ch) && ch-> mana > 1 && arrow
fight_hits.c:                        && arrow->pIndexData->vnum == OBJ_VNUM_MAGIC_ARROW){
fight_hits.c:                        ch->mana -= 1;
fight_hits.c:    if (dt == 1014 && (!arrow || !wield || wield->wear_loc != WEAR_TWO_HAND) ){
fight_hits.c:        if ( wield && wield->item_type == ITEM_WEAPON )
fight_hits.c:            dt += wield->value[3];
fight_hits.c:        switch( wield->wear_loc ){
fight_hits.c:            str_diff = get_curr_str ( ch ) - min_str;
fight_hits.c:            if( str_diff < -5 ) return -2;
fight_hits.c:            str_diff = get_curr_str ( ch ) - min_str;
fight_hits.c:            if( str_diff < -5 ) return -2;
fight_hits.c:            str_diff = get_curr_str ( ch ) - min_str;
fight_hits.c:            if( str_diff < -5 ) return -2;
fight_hits.c:    race_hit_bonus = ( race_table[victim->race].size - race_table[ch->race].size );
fight_hits.c:     		* Calculate to-hit-armor-class-0 versus armor.
fight_hits.c:    //2. ¤£¦PÂ¾·~, ÀHµÛµ¥¯Å´£¤É, ³y¦¨©R¤¤²v´£¤Éµ{«×¤£¦P (thac0_42 - thac0_00, ¶V¤p¶V¦n)
fight_hits.c:        if ( IS_SET( ch->class ,1 ) ){
fight_hits.c:            thac0_42 = -10;
fight_hits.c:        thac0_00 = class_table[ch->class].thac0_00;
fight_hits.c:        thac0_42 = class_table[ch->class].thac0_42 - ( get_curr_dex( ch ) - 16 ) * 2;
fight_hits.c:    /* Weapon-specific hitroll and damroll */
fight_hits.c:                whr -= interpolate1( 60, 0, 100, 10, (whr- 60));
fight_hits.c:             && (ch->class == ASSASSIN || ch->class == NINJA || ch->class == RANGER) ){
fight_hits.c:            if ( ch->class == ASSASSIN && IS_AFFECTED ( ch, AFF_DARK_RAID ) ){
fight_hits.c:				// ·sª©½b³N©R¤¤¥[¦¨ -- ª½±µ¼vÅT whr ¨Ã¤@¨Ö¦C¤JªZ¾¹­pºâ
fight_hits.c:    //        - (ªZ¾¹©R¤¤+ªZ¾¹§÷½è¼vÅT) * (ªZ¾¹ºØ±Ú©R¤¤¥[¦¨)
fight_hits.c:    //        - ªZ¾¹ºØ±Ú©R¤¤ÂI¼Æ
fight_hits.c:    //        - ºØ±ÚÅé¿n¼vÅT
fight_hits.c:    //        - ªZ¾¹ªº¯«¸tÄÝ©Ê¼vÅT
fight_hits.c:    //        - ®g½b¼vÅT * (ªZ¾¹ºØ±Ú©R¤¤¥[¦¨)  -- Modified by Keelar
fight_hits.c:        thac0 = interpolate( ch->level, thac0_00, thac0_42 )
fight_hits.c:              - (whr + wield->material->value[0]) * get_vrace_hrp(victim, wield) / 100
fight_hits.c:	            - get_vrace_hrq(victim, wield )
fight_hits.c:	            - race_hit_bonus
fight_hits.c:	            - ( IS_SET(wield->extra_flags, ITEM_HOLY) ?  (wield->level / 9) : 0);
fight_hits.c:              - ( (arrow != NULL) ? 
fight_hits.c:                    : IS_SET( ch->class, 16 ) ? 20 : -60 )
fight_hits.c:        int phr = (   ch->hitroll 
fight_hits.c:            phr -= interpolate1(50, 1, 100, 15, (phr-50));
fight_hits.c:        //        - ªÅ¤â©R¤¤²v
fight_hits.c:        //        - ºØ±ÚÅé¿n¼vÅT
fight_hits.c:        //        - ªÅ¤â frenzy ©R¤¤ÅÜ®t
fight_hits.c:        //        - ªÅ¤â®g½b (³o¬O«ü ran ªÅ¤â hr ÁÙ¦³¥[¦¨´N¬O¤F ? orz)
fight_hits.c:        thac0 = interpolate( ch->level, thac0_00, thac0_42 )
fight_hits.c:              - phr
fight_hits.c:              - race_hit_bonus
fight_hits.c:              - ( ( dt == gsn_frenzy ) ? UMIN( (ch->level - 56), -8 ) : 0 )
fight_hits.c:              - ( ( arrow != NULL ) ? 
fight_hits.c:                                  : IS_SET( ch->class, 16 ) ? 20 : -60 )
fight_hits.c:        thac0 -= (ch->hitroll * nIbaSklv) / 24;
fight_hits.c:            thac0 -= 50 * get_vrace_hrp(victim, wield) / 100;
fight_hits.c:        if (   IS_SET( ch->act, PLR_FIST_FIGHT ) && !isLizTail
fight_hits.c:                thac0 -= 30 + get_skill_level(ch, gsn_blind_fight)*2;
fight_hits.c:            if ( is_affected(ch, gsn_powerup) && ch->move > 20 ) {
fight_hits.c:                ch->move -= 20;
fight_hits.c:    if (    //( IS_NPC (ch) && ch->class && ch->class == MARTIALMAN ) ||
fight_hits.c:        (  !IS_NPC (ch) && ch->pcdata->learned[gsn_blood_thirsty] > 0
fight_hits.c:        if( ch->hit * 18 <= ch->max_hit * 12 ){
fight_hits.c:			if ( ch->hit * 18 <= ch->max_hit * 11 )
fight_hits.c:				if ( ch->hit * 18 <= ch->max_hit * 10 )
fight_hits.c:					if ( ch->hit * 18 <= ch->max_hit * 9 )
fight_hits.c:						if( ch->hit * 18 <= ch->max_hit * 8 )
fight_hits.c:							if ( ch->hit * 18 <= ch->max_hit * 7 )
fight_hits.c:								if(ch->hit * 18 <= ch->max_hit * 6 )
fight_hits.c:									if( ch->hit * 18 <= ch->max_hit * 5 )
fight_hits.c:										if ( ch->hit * 18 <= ch->max_hit * 4 )
fight_hits.c:											if( ch->hit * 18 <= ch->max_hit * 3 )
fight_hits.c:												if(ch->hit * 18 <= ch->max_hit * 2)
fight_hits.c:													if(ch->hit * 18 <= ch->max_hit * 1)
fight_hits.c:    }// END -- ¶Ý¦å °t¦X ¥þ¤O²r§ð ªº¼vÅT
fight_hits.c:    if ( IS_NPC( victim ) && IS_SET( victim->class, 4 ) )
fight_hits.c:        victim_dodge -= 30;
fight_hits.c:		/* thac0_0 for an advance class war hero is around -6.
fight_hits.c:    // -30 <= diceroll         <=  0
fight_hits.c:    //ex: dodge -700 ªº mob
fight_hits.c:    //    hr > 100, §¹¥þ©R¤¤, ¦ýÁÙ¬O¦³ 1/32 ¾÷²v¥´¤£¨ì (diceroll = -30, 11110 = 30)
fight_hits.c:    while ( ( diceroll = - number_bits( 5 ) ) <= -30 )
fight_hits.c:    if( !IS_NPC( ch ) || !IS_SET( ch->act, ACT_SPEEDHIT ) ){
fight_hits.c:            && ( ( diceroll != 0 && diceroll < thac0 - victim_dodge ) 
fight_hits.c:							  || diceroll == -30 ) ){
fight_hits.c:            if ( msg_mode == MSG_NORMAL ) dam_message( ch, victim, -1, dt, wpn );
fight_hits.c:            dam = -1; // -1 denotes a missing attack
fight_hits.c:                      // -2 denotes a failure attack
fight_hits.c:                if (   (   IS_SET( victim->act, ACT_WIMPY ) && number_bits( 1 ) == 0
fight_hits.c:	                      && victim->hit < victim->max_hit / 2 && victim->wait == 0 )
fight_hits.c:                    || (  (   IS_AFFECTED( victim, AFF_CHARM ) || victim->clan
fight_hits.c:                        && victim->master && victim->in_room
fight_hits.c:		                    && victim->master->in_room != victim->in_room ) ){
fight_hits.c:                && victim->hit  > 0
fight_hits.c:                && victim->hit  <= victim->wimpy
fight_hits.c:                && victim->wait < 3 ){
fight_hits.c:        if ( wield && wield->item_type == ITEM_WEAPON ){
fight_hits.c:            dt += wield->value[3];
fight_hits.c:            dam = number_range( ch->level / 2, ch->level * 2 );
fight_hits.c:            dam   = number_range( ch->level / 2, ch->level * 2 );
fight_hits.c:            dam = number_range( ch->level / 2, ch->level * 2 );
fight_hits.c:            if ( wield->value[3] != 14 && number_bits(5) < 8){
fight_hits.c:      	    dam = number_range( wield->value[1], wield->value[2] );
fight_hits.c:                    dam -= (dam/3);
fight_hits.c:                    dam = wield->value[2];
fight_hits.c:                if( ch->class == MARTIALMAN ){
fight_hits.c:                    dam = wield->value[2];
fight_hits.c:                if( ch->class == MARTIALMAN && dt == gsn_frenzy ){
fight_hits.c:            dam = number_range( 1, 2 ) * race_table[ ch->race ].size;
fight_hits.c:            sprintf( buf, "One_hit dam range > 1000 from %d to %d",wield->value[1], wield->value[2] );
fight_hits.c:            if( ( armor = get_eq_char(victim, place)) && armor->item_type == ITEM_ARMOR){
fight_hits.c:            int nBowAvg   = number_range( bow->value[1], bow->value[2] );
fight_hits.c:            int nArwAvg   = number_range( arrow->value[1], arrow->value[2] );
fight_hits.c:            dam += (bow->material->value[1] ) + (wield->material->value[1] );
fight_hits.c:            int nWpnAvg = number_range( wield->value[1], wield->value[2] );
fight_hits.c:            if( !IS_NPC(ch) && ch->pcdata->learned[gsn_powerblow] > 0){
fight_hits.c:                int nPbBonus = wield->weight * (nPbSklv * nPbSklv) / 100;
fight_hits.c:                    nWpnAvg  = wield->value[2];
fight_hits.c:            if( !IS_NPC(ch) && ch->pcdata->learned[gsn_weapon_master] > 0 ){
fight_hits.c:                int nWmBonus = (nWmSklv * 15 + 10) * 10 / (10 + wield->weight);
fight_hits.c:            dam += (wield->material->value[1] );
fight_hits.c:        dam += (wield->material->value[1] );
fight_hits.c:    if ( wield && IS_SET( wield->extra_flags, ITEM_POISONED ) && dt != 1014 ){
fight_hits.c:    if( !IS_NPC(ch) && ch->class == MONK && dt == gsn_kick ){
fight_hits.c:    if( !IS_NPC(ch) && ch->pcdata->learned[gsn_weapon_master] > 0 && !isLizTail){
fight_hits.c:                                    - 10 ))) >> 7 ;
fight_hits.c:                                   - 12) ) ) >> 7 ;
fight_hits.c:            if(    ch->class != WARLORD
fight_hits.c:                || number_percent() - 15 < ( get_skill_percent( ch, gsn_weapon_master ) / 2 ) )
fight_hits.c:                                 + 13 * (  get_curr_int( ch ) - 12
fight_hits.c:        if( ch->class == KNIGHT && ch->pcdata->prime_attr == APPLY_STR )
fight_hits.c:        if( ch->class == KNIGHT && ch->pcdata->prime_attr != APPLY_STR )
fight_hits.c:        if( ch->class == WARLORD )
fight_hits.c:        if( ch->class == MONK )
fight_hits.c:        if( ch->class == SWORDSMAN )
fight_hits.c:        if( ch->pcdata->prime_attr == APPLY_STR)
fight_hits.c:    //mob ¬° cle ¥B¤£¬O®g½b®Éªº¶Ë®`¥[¦¨....³o¬O¦b°µÔ£ -_-
fight_hits.c:         && IS_SET( ch->class, 1 ) )
fight_hits.c:        dam += ch->apdr * (40 + nIbaSklv * (4 + nIbaSklv)) / 50;
fight_hits.c:        dam += ch->apdr * nTacSklv / 3;
fight_hits.c:    if(!IS_NPC(ch) && IS_SET( ch->act, PLR_FIST_FIGHT ) && get_skill_percent(ch, gsn_fist_fight)){
fight_hits.c:        dam += ch->apdr * nFistSklv / 3;
fight_hits.c:        int nArwAvg = number_range(arrow->value[1] , arrow->value[2]);
fight_hits.c:                if( ch->mana < 5){
fight_hits.c:                }else if(arrow->pIndexData->vnum != OBJ_VNUM_MAGIC_ARROW ){
fight_hits.c:                    ch->mana -= 2; 
fight_hits.c:                    ch->mana -= 1;
fight_hits.c:            if( number_percent() < ((nCurrWis - 10) * abs(nCurrWis - 10)) / 20)
fight_hits.c:								dam += arrow->value[3] * (1 + get_skill_level(ch, gsn_shot_arrow) * 1 / 3);
fight_hits.c:								dam += arrow->value[3] * (1 + get_skill_level(ch, gsn_shot_arrow) * 1 / 6);
fight_hits.c:                dam += arrow->value[3];
fight_hits.c:    if ( !IS_NPC(ch) && dt == gsn_frenzy && ch->class == MARTIALMAN)
fight_hits.c:        dam = (dam * ch->level) / 30;
fight_hits.c:        dam = (dam*ch->level) / 36;
fight_hits.c:        if( !IS_NPC(ch) && ch->class == ASSASSIN)
fight_hits.c:            dam = dam + (dam * (   UMIN( ( ch->level / 3 ), 14 ) / 2
fight_hits.c:            dam = dam /2 + (dam * (   UMIN( ( ch->level / 4 ), 11 ) / 2
fight_hits.c:        if ( !IS_NPC (ch) && ch->class == ASSASSIN && IS_AFFECTED ( ch, AFF_DARK_RAID ) )
fight_hits.c:        //    dam += dam  + ( dam * (ch->level+get_skill_level(ch,gsn_circle)+3*get_skill_level(ch,gsn_circle)/6)) / 10;
fight_hits.c:    /*if ( ch->race == race_lookup( "Vampire" ) && !wield )
fight_hits.c:        if( ch->class == SHAMAN || ch->class == MARTIALMAN){
fight_hits.c:    dam += check_item_magic_flag(wield, victim->race, dam);
fight_hits.c:        dam += ch->apdr * nEmpSklv / 3;
fight_hits.c:            if(nEnemyAC >= -400){
fight_hits.c:                dam = dam * 400 / (0 - nEnemyAC);
fight_hits.c:            if(nEnemyAC <= -1000){
fight_hits.c:            if(nEnemyAC >= -500){
fight_hits.c:                dam = dam * 1500 / (1000 - nEnemyAC);
fight_hits.c:            if(nEnemyAC <= -750){
fight_hits.c:                dam = dam * 2000 / (1250 - nEnemyAC);
fight_hits.c:                                victim->mana * nDmgToMpRate);
fight_hits.c:        dam          -= nBlkDmg * (nMsSklv + 6) / 12;
fight_hits.c:        nBlkDmg      += (ch->apdr - victim->pdr);
fight_hits.c:        victim->mana -= 0 + nBlkDmg / nDmgToMpRate;
fight_hits.c:        if(victim->mana <= nDmgToMpRate){
fight_hits.c:            victim->mana = 0;
fight_hits.c:    if ( !ch->deleted && !victim->deleted && ch->in_room == victim->in_room )
fight_hits.c:        if( wield&&  IS_SET(wield->extra_flags, ITEM_DARK))
fight_hits.c:                    trigger_obj_hp( wield, skill_lookup("lifesteal"), wield->level, ch, victim);
fight_hits.c:                    trigger_obj_hp( wield, skill_lookup("soulsteal"), wield->level, ch, victim);
fight_hits.c:        chance += (nLmBonus - 100) / 100;
fight_hits.c:            OBJ_HP * ohp = arrow->hp;
fight_hits.c:            for( ; ohp; ohp = ohp->next )
fight_hits.c:                if ( IS_SET( ohp->event, HP_ARROW) )
fight_hits.c:                              && IS_SET( ch->act, PLR_ARTIFACT )
fight_hits.c:                              && (       artifact(ch) * ohp->percent * nCurrWis / 2500
fight_hits.c:                              &&         ohp->percent * nCurrWis / 25
fight_hits.c:                        trigger_obj_hp(arrow, skill_lookup(ohp->hp_name), ohp->level, ch, victim);
fight_hits.c:                          && (    wield->hp
fight_hits.c:                               || wield->material->hp) )
fight_hits.c:            OBJ_HP * ohp = wield->hp;
fight_hits.c:            for( ; ohp; ohp = ohp->next )
fight_hits.c:                if( IS_SET( ohp->event, HP_FIGHT ) )
fight_hits.c:                  && IS_SET( ch->act, PLR_ARTIFACT )
fight_hits.c:                  && (       artifact(ch) * ohp->percent * nCurrWis / 2500
fight_hits.c:                              &&       ohp->percent * nCurrWis / 25
fight_hits.c:                        trigger_obj_hp(wield, skill_lookup(ohp->hp_name), ohp->level, ch, victim);
fight_hits.c:        if( IS_SET( ohp->event, HP_WEAPON ) )
fight_hits.c:                      && IS_SET( ch->act, PLR_ARTIFACT )
fight_hits.c:                      && (       artifact(ch) * ohp->percent * nCurrWis / 2500
fight_hits.c:                              &&       ohp->percent * nCurrWis / 25
fight_hits.c:                        trigger_obj_hp(wield, skill_lookup(ohp->hp_name), ohp->level, ch, victim);
fight_hits.c:        if( wield->material->hp )
fight_hits.c:        for( ohp=wield->material->hp ; ohp; ohp = ohp->next )
fight_hits.c:                if( IS_SET( ohp->event, HP_FIGHT ) )
fight_hits.c:                            && IS_SET( ch->act, PLR_ARTIFACT )
fight_hits.c:                            && (       artifact(ch) * ohp->percent * nCurrWis / 2500
fight_hits.c:                                  &&       ohp->percent * nCurrWis / 25
fight_hits.c:                      trigger_obj_hp(wield, skill_lookup(ohp->hp_name), ohp->level, ch, victim);
fight_hits.c:            if( IS_SET( ohp->event, HP_WEAPON ) )
fight_hits.c:                      && IS_SET( ch->act, PLR_ARTIFACT )
fight_hits.c:                      && (       artifact(ch) * ohp->percent * nCurrWis / 2500
fight_hits.c:                                  &&       ohp->percent * nCurrWis / 25
fight_hits.c:                trigger_obj_hp(wield, skill_lookup(ohp->hp_name), ohp->level, ch, victim);
fight_hits.c:	if( arrow->value[0] == 0 )
fight_hits.c:        return -2;
fight_hits.c:    protector = victim->protector;
fight_hits.c:        for( ; protector  && protector != protector->next_in_protect ; protector = protector ->next_in_protect ) {
fight_hits.c:            if(   protector != ch  && protector != victim  && ch->in_room 
fight_hits.c:               && protector->in_room == ch->in_room ) {
fight_hits.c:                if(  ( IS_NPC(protector) && protector->level + 25 > number_percent())
fight_hits.c:                    ch->fighting = NULL;
fight_msg.c:	sprintf(buf6,"(%d-%d)", ((cedmt[i-1].min_dmg)+1),((cedmt[i].min_dmg)));
fight_msg.c:      	sprintf( buf3, "$nªº %d/%d ¦¸%s[1;37m¨S¦³¥´¤¤[m%s$N"NOR".", miss_times, times, skill_name, stat_color1(victim->hit, victim->max_hit) );
fight_msg.c:    	sprintf( buf3, "$nªº %d/%d ¦¸%s[1;37mµLªk¶Ë®`[m%s$N"NOR".", no_dam_times, times, skill_name, stat_color1(victim->hit, victim->max_hit) );
fight_msg.c:    	if( ch->level > 34 )
fight_msg.c:    	if(victim->level > 34)
fight_msg.c:      	    sprintf( buf3, "$nªº %d/%d ¦¸%s%s%s$N"NOR"%s", dam_times, times, skill_name, stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:            IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:            IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:	if( ch->level > 34 )
fight_msg.c:	if(victim->level > 34)
fight_msg.c:    if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_msg.c:    if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_msg.c:    if ( dam ==   -1 )
fight_msg.c:	  if ( victim->hit > 0 )
fight_msg.c:	  dam /= victim->hit;
fight_msg.c:	    sprintf(buf6,"(%d-%d)", ((edmt[i-1].min_dmg)+1),((edmt[i].min_dmg)));
fight_msg.c:	if ( ch->race > MAX_RACE )
fight_msg.c:	    bug( "Dam_message:  %d invalid race", ch->race );
fight_msg.c:	    ch->race = 0;
fight_msg.c:	attack = race_table[ ch->race ].dmg_message;
fight_msg.c:	if( ch->level > 34 )
fight_msg.c:	if( victim->level > 34 )
fight_msg.c:	IS_NPC( victim ) ? HIW : stat_color1(victim->hit, victim->max_hit), punct );
fight_msg.c:            attack  = attack_table[dt - TYPE_HIT];
fight_msg.c:	    sprintf( buf, "Dam_message: bad dt %d caused by %s.", dt,ch->name );
fight_msg.c:	    if( ch->level > 34 )
fight_msg.c:	    if( victim->level > 34 )
fight_msg.c:            IS_NPC( victim ) ? HIW : stat_color1(victim->hit, victim->max_hit), punct );
fight_msg.c:	    if( ch->level > 34 )
fight_msg.c:      	    if( victim->level > 34 )
fight_msg.c:            IS_NPC( victim ) ? HIW : stat_color1(victim->hit, victim->max_hit), punct );
fight_msg.c:    if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_msg.c:    if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_msg.c:    if ( dam ==   -1 ) { vp = "[1;37m¨S¦³¥´¤¤[m";        }
fight_msg.c:	    sprintf(buf6,"(%d-%d)", ((cedmt[i-1].min_dmg)+1),( (cedmt[i].min_dmg)));
fight_msg.c:	    if ( ch->race > MAX_RACE )
fight_msg.c:		bug( "Dam_message:  %d invalid race", ch->race );
fight_msg.c:		ch->race = 0;
fight_msg.c:	    attack = race_table[ ch->race ].dmg_message;
fight_msg.c:	    sprintf( buf3, "$nªº %d/%d ¦¸%s%s%s$N"NOR"%s",   hit,total,attack, stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		sprintf( buf3, "$nªº %d/%d ¦¸%s%s%s$N"NOR"%s",  hit, total, attack, stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		attack  = cattack_table[dt - TYPE_HIT];
fight_msg.c:          	    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:          	    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:    		sprintf( buf, "Dam_message: bad dt %d caused by %s.", dt,ch->name );
fight_msg.c:	    if ( ch->race > MAX_RACE )
fight_msg.c:		bug( "Dam_message:  %d invalid race", ch->race );
fight_msg.c:		ch->race = 0;
fight_msg.c:      	    attack = race_table[ ch->race ].dmg_message;
fight_msg.c:            IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:      		IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		attack  = cattack_table[dt - TYPE_HIT];
fight_msg.c:          	    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:          	    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		sprintf( buf, "Dam_message: bad dt %d caused by %s.", dt,ch->name );
fight_msg.c:	    if ( ch->race > MAX_RACE )
fight_msg.c:		bug( "Dam_message:  %d invalid race", ch->race );
fight_msg.c:		ch->race = 0;
fight_msg.c:	    attack = race_table[ ch->race ].dmg_message;
fight_msg.c:            IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:      		IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		attack  = cattack_table[dt - TYPE_HIT];
fight_msg.c:          	    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:                    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:    if( ch->level > 34 )
fight_msg.c:    if( victim->level > 34 ) 
fight_msg.c:  	strcat( wps, weapon->short_descr );
fight_msg.c:    if (IS_IMMORTAL(ch)&& IS_SET(ch->act, PLR_VERBOSEALL) )
fight_msg.c:    if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_msg.c:    if ( dam == -1 )
fight_msg.c:	  if ( victim->hit > 0 )
fight_msg.c:	  dam /= victim->hit;
fight_msg.c:      	    sprintf(buf6,"(%d-%d)", ((edmt[i-1].min_dmg)+1), ((edmt[i].min_dmg)));
fight_msg.c:	if ( ch->race > MAX_RACE )
fight_msg.c:	    bug( "Dam_message:  %d invalid race", ch->race );
fight_msg.c:            ch->race = 0;
fight_msg.c:        attack = race_table[ ch->race ].dmg_message;
fight_msg.c:	if ( ch->level > 34 )
fight_msg.c:	if ( victim->level > 34 )
fight_msg.c:	IS_NPC( victim ) ? HIW : stat_color1(victim->hit, victim->max_hit), punct );
fight_msg.c:	    attack  = attack_table[dt - TYPE_HIT];
fight_msg.c:	    sprintf( buf, "Dam_message: bad dt %d caused by %s.", dt,ch->name );
fight_msg.c:      	    if( ch->level > 34 )
fight_msg.c:      	    if( victim->level > 34 )
fight_msg.c:            IS_NPC( victim ) ? HIW : stat_color1(victim->hit, victim->max_hit), punct );
fight_msg.c:	    if( ch->level > 34 )
fight_msg.c:	    if( victim->level > 34 )
fight_msg.c:            IS_NPC( victim ) ? HIW : stat_color1(victim->hit, victim->max_hit), punct );
fight_msg.c:    if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_msg.c:    if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
fight_msg.c:    if ( dam ==   -1 )
fight_msg.c:	    sprintf(buf6,"(%d-%d)", ((cedmt[i-1].min_dmg)+1),((cedmt[i].min_dmg)));
fight_msg.c:	    if ( ch->race > MAX_RACE )
fight_msg.c:    		bug( "Dam_message:  %d invalid race", ch->race );
fight_msg.c:    		ch->race = 0;
fight_msg.c:      	    attack = race_table[ ch->race ].dmg_message;
fight_msg.c:      	    sprintf( buf3, "$nªº%s%s%s$N"NOR"%s",  attack, stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		sprintf( buf3, "$nªº%s%s%s$N"NOR"%s",  attack, stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		attack  = cattack_table[dt - TYPE_HIT];
fight_msg.c:		    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:          	    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		sprintf( buf, "Dam_message: bad dt %d caused by %s.", dt,ch->name );
fight_msg.c:	    if ( ch->race > MAX_RACE )
fight_msg.c:		bug( "Dam_message:  %d invalid race", ch->race );
fight_msg.c:   		ch->race = 0;
fight_msg.c:	    attack = race_table[ ch->race ].dmg_message;
fight_msg.c:            IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		         IS_NPC( victim )? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		attack  = cattack_table[dt - TYPE_HIT];
fight_msg.c:        	             IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:          		     IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		sprintf( buf, "Dam_message: bad dt %d caused by %s.", dt,ch->name );
fight_msg.c:	    if ( ch->race > MAX_RACE )
fight_msg.c:		bug( "Dam_message:  %d invalid race", ch->race );
fight_msg.c:    		ch->race = 0;
fight_msg.c:	    attack = race_table[ ch->race ].dmg_message;
fight_msg.c:        	     IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:      			 IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		attack  = cattack_table[dt - TYPE_HIT];
fight_msg.c:		    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:		    IS_NPC( victim ) ? WHT : stat_color1(victim->hit, victim->max_hit), vp, punct );
fight_msg.c:    if( ch->level > 34 )
fight_msg.c:    if(victim->level > 34)
fight_msg.c:  	strcat( wps, weapon->short_descr );
fight_msg.c:    if( IS_IMMORTAL(ch) && IS_SET(ch->act, PLR_VERBOSEALL))
fight_msg.c:    if( IS_IMMORTAL(victim) && IS_SET(victim->act, PLR_VERBOSEALL))
handler.c://*---------------------------------------------------------------*
handler.c://*---------------------------------------------------------------*
handler.c://*---------------------------------------------------------------*
handler.c://*              :         ¨Ï±o¦b extract_char() «á¡Ach->in_room  *
handler.c://*---------------------------------------------------------------*
handler.c://*---------------------------------------------------------------*
handler.c://*---------------------------------------------------------------*
handler.c://*---------------------------------------------------------------*
handler.c://*-----------------------------------------------------------------*
handler.c://*              :         ch->desc->connected ­n¬° CON_PLAYING ®É  *
handler.c://*-----------------------------------------------------------------*
handler.c://*-----------------------------------------------------------------*
handler.c://*-----------------------------------------------------------------*
handler.c://*-----------------------------------------------------------------*
handler.c://*-----------------------------------------------------------------*
handler.c://*-----------------------------------------------------------------*
handler.c://*-----------------------------------------------------------------*
handler.c://*-----------------------------------------------------------------*
handler.c: * Global functions and variables.  -- Keric 
handler.c:    if(paf->location == APPLY_HIT)
handler.c:        paf->modifier *= PPL_HP_MULTIPLYER;
handler.c:    if(paf->location == APPLY_HIT)
handler.c:        paf->modifier /= PPL_HP_MULTIPLYER;
handler.c:	if(ch->master && !IS_NPC(ch->master)){
handler.c:		if(ch->master->pcdata->prime_attr == APPLY_INT)
handler.c:	return -1;
handler.c:	if(GetSorGateMobLevel(nMobIndex) > -1) return TRUE;
handler.c:		}else if(IsSorGateMob(ch->pIndexData->vnum)){
handler.c:			if(ch->master && !IS_NPC(ch->master)){
handler.c:          return ( IS_NPC(ch) ? ch->saving_throw[type] : 15 - get_curr_wis(ch) + ch->saving_throw[type]) + race_table[ch->race].nature_svs[type] - 10; 
handler.c:          return ( IS_NPC(ch) ? ch->saving_throw[type] : 15 - get_curr_wis(ch) + ch->saving_throw[type]) + race_table[ch->race].nature_svs[type] + 10;
handler.c:        return ( IS_NPC(ch) ? ch->saving_throw[type] : 15 - get_curr_wis(ch) + ch->saving_throw[type]) + race_table[ch->race].nature_svs[type] + 5; 
handler.c:          return ( IS_NPC(ch) ? ch->saving_throw[type] : 15 - get_curr_wis(ch) + ch->saving_throw[type]) + race_table[ch->race].nature_svs[type] + 10; 
handler.c:          return ( IS_NPC(ch) ? ch->saving_throw[type] : 15 - get_curr_wis(ch) + ch->saving_throw[type]) + race_table[ch->race].nature_svs[type] - 10;
handler.c:        return ( IS_NPC(ch) ? ch->saving_throw[type] : 15 - get_curr_wis(ch) + ch->saving_throw[type]) + race_table[ch->race].nature_svs[type] + 5; 
handler.c:        return ( IS_NPC(ch) ? ch->saving_throw[type] : 30 - get_curr_int(ch) - get_curr_wis(ch) + ch->saving_throw[type]) + race_table[ch->race].nature_svs[type];
handler.c:#define GET_SVS( ch )     ( IS_NPC( ch ) ? ch->saving_throw : 30 - get_curr_int( ch ) - \
handler.c:          get_curr_wis( ch ) + ch->saving_throw  )
handler.c:    return ( IS_NPC(ch) ? ch->saving_throw[0] : 30 - get_curr_int(ch) - get_curr_wis(ch) + ch->saving_throw[0])+ race_table[ch->race].nature_svs[0];
handler.c:    if( wpn->item_type == ITEM_ARROW ) type = 14;
handler.c:    else type = wpn->value[3];
handler.c:    if( wpn->vrace ) {
handler.c:  for( ovr = wpn->vrace ; ovr ; ovr = ovr ->next ){
handler.c:     if( victim->race == ovr -> race ){
handler.c:         q += ovr->hr_mod_q;
handler.c:    if( wpn->material->vrace ) {
handler.c:  for( ovr = wpn->material->vrace ; ovr ; ovr = ovr ->next ){
handler.c:     if( victim->race == ovr -> race ){
handler.c:         q += ovr->hr_mod_q;
handler.c:    if( type > -1 && type < MAX_TYPES ) {
handler.c:    for( ovr = (basic_types[type])->vrace ; ovr ; ovr = ovr->next){
handler.c:  if( victim->race == ovr->race ) {
handler.c:      q += ovr->hr_mod_q;
handler.c:    if( wpn->item_type == ITEM_ARROW ) type = 14;
handler.c:    else type = wpn->value[3];
handler.c:    if( wpn->vrace ) {
handler.c:  for( ovr = wpn->vrace ; ovr ; ovr = ovr ->next ){
handler.c:     if( victim->race == ovr -> race ){
handler.c:         q += ovr->dr_mod_q;
handler.c:    if( wpn->material->vrace ) {
handler.c:  for( ovr = wpn->material->vrace ; ovr ; ovr = ovr ->next ){
handler.c:     if( victim->race == ovr -> race ){
handler.c:         q += ovr->dr_mod_q;
handler.c:    if( type > -1 && type < MAX_TYPES ) {
handler.c:    for( ovr = (basic_types[type])->vrace ; ovr ; ovr = ovr->next){
handler.c:  if( victim->race == ovr->race ) {
handler.c:      q += ovr->dr_mod_q;
handler.c:    if( wpn->item_type == ITEM_ARROW ) type = 14;
handler.c:    else type = wpn->value[3];
handler.c:    if( wpn->vrace ) {
handler.c:  for( ovr = wpn->vrace ; ovr ; ovr = ovr ->next ){
handler.c:     if( victim->race == ovr -> race ){
handler.c:         q = ovr->hr_mod_p;
handler.c:    if( wpn->material->vrace ) {
handler.c:  for( ovr = wpn->material->vrace ; ovr ; ovr = ovr ->next ){
handler.c:     if( victim->race == ovr -> race ){
handler.c:         q = ( q * ovr->hr_mod_p ) / 100;
handler.c:    if( type > -1 && type < MAX_TYPES ) {
handler.c:    for( ovr = (basic_types[type])->vrace ; ovr ; ovr = ovr->next){
handler.c:  if( victim->race == ovr->race ) {
handler.c:      q  = ( q * ovr->hr_mod_p ) / 100;
handler.c:    if( wpn->item_type == ITEM_ARROW ) type = 14;
handler.c:    else type = wpn->value[3];
handler.c:    if( wpn->vrace ) {
handler.c:        for( ovr = wpn->vrace ; ovr ; ovr = ovr ->next ){
handler.c:            if( victim->race == ovr -> race ){
handler.c:                q = ovr->dr_mod_p;
handler.c:    if( wpn->material->vrace ) {
handler.c:        for( ovr = wpn->material->vrace ; ovr ; ovr = ovr ->next ){
handler.c:            if( victim->race == ovr -> race ){
handler.c:                q = ( q * ovr->dr_mod_p ) / 100;
handler.c:    if( type > -1 && type < MAX_TYPES ) {
handler.c:        for( ovr = (basic_types[type])->vrace ; ovr ; ovr = ovr->next){
handler.c:            if( victim->race == ovr->race ) {
handler.c:                q  = ( q * (ovr->dr_mod_p + 300)) / 400;
handler.c:    if ( ch->desc && ch->desc->original )
handler.c:  ch = ch->desc->original;
handler.c:    if ( ch->trust != 0 )
handler.c:  return ch->trust;
handler.c:    if ( IS_NPC( ch ) && ch->level >= LEVEL_HERO )
handler.c:  return ( L_APP - 1 );
handler.c:  return ch->level;
handler.c:    nDodge = ch->carry_weight;
handler.c:        nDodge += ch->dodge + ((IS_AWAKE(ch)) ? dex_app[get_curr_dex(ch)].defensive : 100)
handler.c:                            + ( is_flying(ch) ? - 40 : 0 );
handler.c:        nDodge += (ch->class == NINJA ?
handler.c:                    (ch->pcdata->prime_attr == APPLY_DEX ? -60 :
handler.c:                    (ch->pcdata->prime_attr == APPLY_STR ? -40 :
handler.c:                    (ch->pcdata->prime_attr == APPLY_CON ? -20 : 0))) : 0)
handler.c:               + ch->dodge + ((IS_AWAKE(ch)) ? dex_app[get_curr_dex(ch)].defensive : 100)
handler.c:               + (ch->level * (-5) + (is_flying(ch) ? - 40 : 0 ));
handler.c:    return 16 + ( ch->played + (int) ( current_time - ch->logon ) ) / 40000;
handler.c://    return 16 + ( ch->played + (int) ( current_time - ch->logon ) ) / 428400;
handler.c:       17 months/year - Kahn */
handler.c:    mod   = race_table[ch->race].str_mod;
handler.c:      value -= 1;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_STR ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_STR ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].int_mod;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_INT ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_INT ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].wis_mod;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_WIS ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_WIS ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].dex_mod;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_DEX ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_DEX ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].con_mod;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_CON ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_CON ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].str_mod;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            max = 12 + GetSorGateMobLevel(ch->pIndexData->vnum) * 3;
handler.c:            if(IsSorGateMobLightning(ch->pIndexData->vnum)) max += 6;
handler.c:            if(IsSorGateMobFlame(ch->pIndexData->vnum)) max += 3;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_STR ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_STR ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].int_mod;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            max = 12 + GetSorGateMobLevel(ch->pIndexData->vnum) * 3;
handler.c:            if(IsSorGateMobFlame(ch->pIndexData->vnum)) max += 6;
handler.c:            if(IsSorGateMobWind(ch->pIndexData->vnum)) max += 3;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_INT ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_INT ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].wis_mod;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            max = 12 + GetSorGateMobLevel(ch->pIndexData->vnum) * 3;
handler.c:            if(IsSorGateMobWater(ch->pIndexData->vnum)) max += 6;
handler.c:            if(IsSorGateMobEarth(ch->pIndexData->vnum)) max += 3;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_WIS ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_WIS ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].dex_mod;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            max = 12 + GetSorGateMobLevel(ch->pIndexData->vnum) * 3;
handler.c:            if(IsSorGateMobWind(ch->pIndexData->vnum)) max += 6;
handler.c:            if(IsSorGateMobWater(ch->pIndexData->vnum)) max += 3;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_DEX ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_DEX ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].con_mod;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            max = 12 + GetSorGateMobLevel(ch->pIndexData->vnum) * 3;
handler.c:            if(IsSorGateMobEarth(ch->pIndexData->vnum)) max += 6;
handler.c:            if(IsSorGateMobLightning(ch->pIndexData->vnum)) max += 3;
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_CON ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_CON ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    mod   = race_table[ch->race].str_mod;
handler.c:        value -= 1;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            int nBonus =  GetSorGateMobLevel(ch->pIndexData->vnum);
handler.c:            if(IsSorGateMobLightning(ch->pIndexData->vnum)) {max += 6; nBonus += 2;}
handler.c:            if(IsSorGateMobFlame(ch->pIndexData->vnum)) {max += 3; nBonus ++;}
handler.c:            return URANGE( 3, 12 + nBonus * 2 + ch->mod_str, max);
handler.c:        return URANGE( 1, ch->perm_str + ch->mod_str, max );
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_STR ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_STR ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    return URANGE( 1, ch->perm_str + ch->mod_str, max );
handler.c:    mod   = race_table[ch->race].int_mod;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            int nBonus =  GetSorGateMobLevel(ch->pIndexData->vnum);
handler.c:            if(IsSorGateMobFlame(ch->pIndexData->vnum)) {max += 6; nBonus += 2;}
handler.c:            if(IsSorGateMobWind(ch->pIndexData->vnum)) {max += 3; nBonus ++;}
handler.c:            return URANGE( 3, 12 + nBonus * 2 + ch->mod_int, max);
handler.c:        return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_INT ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_INT ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c:    mod   = race_table[ch->race].wis_mod;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            int nBonus =  GetSorGateMobLevel(ch->pIndexData->vnum);
handler.c:            if(IsSorGateMobWater(ch->pIndexData->vnum))     {max += 6; nBonus += 2;}
handler.c:            if(IsSorGateMobEarth(ch->pIndexData->vnum)) {max += 3; nBonus ++;}
handler.c:            return URANGE( 3, 12 + nBonus * 2 + ch->mod_wis, max);
handler.c:        return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_WIS ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_WIS ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c:    mod   = race_table[ch->race].dex_mod;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            int nBonus =  GetSorGateMobLevel(ch->pIndexData->vnum);
handler.c:            if(IsSorGateMobWind(ch->pIndexData->vnum))     {max += 6; nBonus += 2;}
handler.c:            if(IsSorGateMobWater(ch->pIndexData->vnum)) {max += 3; nBonus ++;}
handler.c:            return URANGE( 3, 12 + nBonus * 2 + ch->mod_dex, max);
handler.c:        return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_DEX ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_DEX ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c:    mod   = race_table[ch->race].con_mod;
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            int nBonus =  GetSorGateMobLevel(ch->pIndexData->vnum);
handler.c:            if(IsSorGateMobEarth(ch->pIndexData->vnum))     {max += 6; nBonus += 2;}
handler.c:            if(IsSorGateMobLightning(ch->pIndexData->vnum)) {max += 3; nBonus ++;}
handler.c:            return URANGE( 3, 12 + nBonus * 2 + ch->mod_con, max);
handler.c:        return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c:    value += ( ch->pcdata->prime_attr == APPLY_CON ) ? 8 :
handler.c:          ( ch->pcdata->snd_attr == APPLY_CON ) ? 5 :
handler.c:          ( ch->class > 4 ) ? 2 : 0;
handler.c:    value += ( ch->level > 39 ) ? 1 : 0;
handler.c:    if(ch->race == 0 && ch->class > 4 && !is_affected(ch, gsn_werewolf)) 
handler.c:    return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c:    //  wpn, ch->name );
handler.c:    //  bugf("get_hitroll: Invalid weapon location %d on %s.", wpn, ch->name);
handler.c:    return ch->hitroll;
handler.c:  hitroll = ch->hitroll ;// str_app[get_curr_str( ch )].tohit;
handler.c:            if( str_app[min_str].wield >= wield->weight )
handler.c:          str_diff = str - min_str;
handler.c:            if( str_app[min_str].wield2 >= wield->weight )
handler.c:          str_diff = str - min_str;
handler.c:            if( str_app[min_str].twohand >= wield->weight )
handler.c:          str_diff = str - min_str;
handler.c:      switch(wield->value[3]) {
handler.c:          //hitroll -= 2;
handler.c:          //hitroll -= 3;
handler.c:          //hitroll -= 5;
handler.c:          //hitroll -= 4;
handler.c:          //hitroll -= 1;
handler.c:          //hitroll -= 2;
handler.c:          ( get_curr_str(ch) - 12 ) +
handler.c:  for( paf = other_wield->pIndexData->affected; paf; paf = paf->next )
handler.c:    if ( paf->location == APPLY_HITROLL )
handler.c:      hitroll -= paf->modifier; // obj's original affected hr
handler.c:  for( paf = other_wield->material->affected; paf; paf = paf->next )
handler.c:    if ( paf->location == APPLY_HITROLL )
handler.c:      hitroll -= paf->modifier; // obj's material affected hr, like
handler.c:  for( paf = other_wield->affected; paf; paf = paf->next )
handler.c:    if ( paf->location == APPLY_HITROLL )
handler.c:      hitroll -= paf->modifier; // obj's run-time affected hr, like
handler.c:          if( str_app[min_str].wield >= wield->weight )
handler.c:        str_diff = str - min_str;
handler.c:          if( str_app[min_str].wield2 >= wield->weight )
handler.c:        str_diff = str - min_str;
handler.c:          if( str_app[min_str].twohand >= wield->weight )
handler.c:        str_diff = str - min_str;
handler.c:    switch(wield->value[3]) {
handler.c:        //hitroll -= 2;
handler.c:        //hitroll -= 3;
handler.c:        //hitroll -= 5;
handler.c:        //hitroll -= 4;
handler.c:        //hitroll -= 1;
handler.c:        //hitroll -= 2;
handler.c:        ( get_curr_str(ch) - 12 ) +
handler.c:  damroll = ch->damroll 
handler.c:    //  wpn, ch->name );
handler.c:    //bugf("get_damroll: Invalid weapon location %d on %s.", wpn, ch->name);
handler.c:  for( paf = other_wield->pIndexData->affected; paf; paf = paf->next )
handler.c:    if ( paf->location == APPLY_DAMROLL )
handler.c:      damroll -= paf->modifier;
handler.c:  for( paf = other_wield->material->affected; paf; paf = paf->next )
handler.c:    if ( paf->location == APPLY_DAMROLL )
handler.c:      damroll -= paf->modifier;
handler.c:  for( paf = other_wield->affected; paf; paf = paf->next )
handler.c:    if ( paf->location == APPLY_DAMROLL )
handler.c:      damroll -= paf->modifier;
handler.c:    if ( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC( ch ) && IS_SET( ch->act, ACT_PET ) )
handler.c:  return ch->level / 4;
handler.c:    return MAX_WEAR + 2 * get_curr_dex( ch ) + ch->level / 2;
handler.c:    if ( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c://    if ( IS_NPC( ch ) && IS_SET( ch->act, ACT_PET ) )
handler.c:      return ch->level * 4 + 30;
handler.c:    if ( !ch || !ch->in_room )
handler.c:  --ch->in_room->area->nplayer;
handler.c:  && obj->item_type == ITEM_LIGHT
handler.c:  && obj->value[2] != 0
handler.c:  && ch->in_room->light > 0 )
handler.c:  --ch->in_room->light;
handler.c:    if ( ch == ch->in_room->people )
handler.c:  ch->in_room->people = ch->next_in_room;
handler.c:  for ( prev = ch->in_room->people; prev; prev = prev->next_in_room )
handler.c:      if ( prev->next_in_room == ch )
handler.c:    prev->next_in_room = ch->next_in_room;
handler.c:      bug( ch->name,0 );
handler.c:    if ( ch->fighting )
handler.c:    ch->in_room      = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    if ( !ch->in_room )
handler.c:  --ch->in_room->area->nplayer;
handler.c:  && obj->item_type == ITEM_LIGHT
handler.c:  && obj->value[2] != 0
handler.c:  && ch->in_room->light > 0 )
handler.c:  --ch->in_room->light;
handler.c:    if ( ch == ch->in_room->people )
handler.c:  ch->in_room->people = ch->next_in_room;
handler.c:  for ( prev = ch->in_room->people; prev; prev = prev->next_in_room )
handler.c:      if ( prev->next_in_room == ch )
handler.c:    prev->next_in_room = ch->next_in_room;
handler.c:      bug( ch->name,0 );
handler.c:    if ( ch->fighting )
handler.c:    ch->in_room      = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    ch->in_room   = pRoomIndex;
handler.c:    ch->next_in_room  = pRoomIndex->people;
handler.c:    pRoomIndex->people  = ch;
handler.c:  ++ch->in_room->area->nplayer;
handler.c:  && obj->item_type == ITEM_LIGHT
handler.c:  && obj->value[2] != 0 )
handler.c:  ++ch->in_room->light;
handler.c:    if (!IS_NPC( ch ) && IS_SET( ch->act, PLR_HORSE ) && ch->desc )
handler.c:    phorse = ch->pcdata->horse;
handler.c:    if ( phorse->hunting || phorse->assassinating || phorse->hunted
handler.c:      || phorse->assassinated )
handler.c:    if( !ch || !obj || obj->deleted ) return;
handler.c:    obj->next_content  = ch->carrying;
handler.c:    ch->carrying   = obj;
handler.c:    obj->carried_by  = ch;
handler.c:    obj->in_room   = NULL;
handler.c:    obj->in_obj    = NULL;
handler.c:    if( obj->item_type == ITEM_HORSE )
handler.c:        ch->carry_number += 1;
handler.c:        ch->carry_weight += obj->weight;
handler.c:        ch->carry_number  += get_obj_number( obj );
handler.c:            ch->carry_weight  += get_obj_weight( obj );
handler.c:    if ( !( ch = obj->carried_by ) )
handler.c:    if ( obj->item_type == ITEM_HORSE)
handler.c:        ch->carry_number -= 1;
handler.c:        ch->carry_weight -= obj->weight;
handler.c:        ch->carry_number  -= get_obj_number( obj );
handler.c:        ch->carry_weight  -= get_obj_weight( obj );
handler.c:    if ( obj->wear_loc != WEAR_NONE )
handler.c:    if ( ch->carrying == obj )
handler.c:        ch->carrying = obj->next_content;
handler.c:        for ( prev = ch->carrying; prev; prev = prev->next_content )
handler.c:            if ( prev->next_content == obj )
handler.c:                prev->next_content = obj->next_content;
handler.c:    obj->carried_by  = NULL;
handler.c:    obj->next_content  = NULL;
handler.c:    if ( obj->item_type != ITEM_ARMOR )
handler.c:    case WEAR_BODY:     return 3 * obj->value[0];
handler.c:    case WEAR_HEAD:     return 2 * obj->value[0];
handler.c:    case WEAR_LEGS:     return 2 * obj->value[0];
handler.c:    case WEAR_FEET:     return     obj->value[0];
handler.c:    case WEAR_HANDS:    return     obj->value[0];
handler.c:    case WEAR_HANDS_2:  return     obj->value[0];
handler.c:    case WEAR_ARMS:     return     obj->value[0];
handler.c:    case WEAR_ARMS_2:   return     obj->value[0];
handler.c:    case WEAR_SHIELD:   return     obj->value[0];
handler.c:    case WEAR_FINGER_L: return     obj->value[0];
handler.c:    case WEAR_FINGER_R: return     obj->value[0];
handler.c:    case WEAR_FINGER_3: return     obj->value[0];
handler.c:    case WEAR_FINGER_4: return     obj->value[0];
handler.c:    case WEAR_NECK_1:   return     obj->value[0];
handler.c:    case WEAR_NECK_2:   return     obj->value[0];
handler.c:    case WEAR_ABOUT:    return 2 * obj->value[0];
handler.c:    case WEAR_WAIST:    return     obj->value[0];
handler.c:    case WEAR_WRIST_L:  return     obj->value[0];
handler.c:    case WEAR_WRIST_R:  return     obj->value[0];
handler.c:    case WEAR_HOLD:     return     obj->value[0];
handler.c:    case WEAR_ARROW:    return     obj->value[0];
handler.c:    for ( obj = ch->carrying; obj; obj = obj->next_content )
handler.c:  if ( obj->deleted )
handler.c:  if ( obj->wear_loc == iWear )
handler.c:        sprintf( buf, "Equip_char: %s already equipped at %d.", ch->name, iWear );
handler.c:    if( !obj->carried_by )
handler.c:    if (   ( IS_OBJ_STAT( obj, ITEM_NO_MALE ) && ch->sex == SEX_MALE)
handler.c:  || ( IS_OBJ_STAT( obj, ITEM_NO_FEMALE ) && ch->sex == SEX_FEMALE )
handler.c:  || ( IS_OBJ_STAT( obj, ITEM_NO_NEUTRAL) && ch->sex == SEX_NEUTRAL) )
handler.c:            if ( IS_SET(obj->extra_flags , ITEM_PERSONAL) )
handler.c:                obj_to_room( obj, ch->in_room );
handler.c:            if ( IS_SET(obj->extra_flags , ITEM_PERSONAL) )
handler.c:                obj_to_room( obj, ch->in_room );
handler.c:    if ( obj->material->class && !IS_NPC( ch ) )
handler.c:       if ( ( IS_SET( obj->material->class, ALLOW_BIT ) && !( IS_SET( obj->material->class, NUM_BIT( ch->class ) ) || IS_SET( obj->class, NUM_BIT( get_allow_deny_bit( ch ) ) ) ) )
handler.c:      || ( IS_SET( obj->material->class, DENY_BIT ) && ( IS_SET( obj->material->class, NUM_BIT( ch->class ) ) || IS_SET( obj->class, NUM_BIT( get_allow_deny_bit( ch ) ) ) ) ) )
handler.c:    if ( obj->material->class && !IS_NPC( ch ) )
handler.c:       if ( ( IS_SET( obj->material->class, ALLOW_BIT ) && !IS_SET( obj->material->class, NUM_BIT( ch->class ) ) )
handler.c:      || ( IS_SET( obj->material->class, DENY_BIT ) && IS_SET( obj->material->class, NUM_BIT( ch->class ) ) ) )
handler.c:  if ( obj->material->race && !IS_NPC( ch ) ){
handler.c:    int nRaceBit = get_ppl_race_bit(ch->race);
handler.c:    if (    ( IS_SET( obj->material->race, ALLOW_BIT ) && !IS_SET( obj->material->race, NUM_BIT( nRaceBit ) ) )
handler.c:         || ( IS_SET( obj->material->race, DENY_BIT ) && IS_SET( obj->material->race, NUM_BIT( nRaceBit ) ) ) )
handler.c:    if ( obj->class && !IS_NPC( ch ) )
handler.c:       if ( ( IS_SET( obj->class, ALLOW_BIT ) && !( IS_SET( obj->class, NUM_BIT( ch->class ) ) || IS_SET( obj->class, NUM_BIT( get_allow_deny_bit( ch ) ) ) ) )
handler.c:      || ( IS_SET( obj->class, DENY_BIT ) && ( IS_SET( obj->class, NUM_BIT( ch->class ) ) || IS_SET( obj->class, NUM_BIT( get_allow_deny_bit( ch ) ) ) ) ) )
handler.c:    if ( obj->class && !IS_NPC( ch ) )
handler.c:       if ( ( IS_SET( obj->class, ALLOW_BIT ) && !IS_SET( obj->class, NUM_BIT( ch->class ) ) )
handler.c:      || ( IS_SET( obj->class, DENY_BIT ) && IS_SET( obj->class, NUM_BIT( ch->class ) ) ) )
handler.c:  if ( obj->race && !IS_NPC( ch ) ){
handler.c:    int nRaceBit = get_ppl_race_bit(ch->race);
handler.c:    if (   ( IS_SET( obj->race, ALLOW_BIT ) && !IS_SET( obj->race, NUM_BIT( nRaceBit ) ) )
handler.c:        || ( IS_SET( obj->race, DENY_BIT ) && IS_SET( obj->race, NUM_BIT( nRaceBit ) ) ) )
handler.c:  if( IS_SET(obj->pIndexData->progtypes , OBJ_ACT)){
handler.c:	if( !obj->carried_by ) return;
handler.c:    //if( !IS_NPC(ch) && ch->pcdata->learned[gsn_armor_mastery] > 0 )
handler.c:    ch->armor -= ac;
handler.c:    obj->wear_loc  = iWear;
handler.c:    //ch->armor  -= obj->material->value[2];
handler.c:    for ( paf = obj->material->affected; paf; paf = paf->next ){
handler.c:        if (!is_affected(ch,paf->type)){
handler.c:    for ( paf = obj->pIndexData->affected; paf; paf = paf->next ){
handler.c:        if (!is_affected(ch,paf->type)){
handler.c:    for ( paf = obj->affected; paf; paf = paf->next ){
handler.c:        if (!is_affected(ch,paf->type)){
handler.c:    if ( obj->item_type == ITEM_LIGHT
handler.c:  && obj->value[2] != 0
handler.c:  && ch->in_room )
handler.c:  ++ch->in_room->light;
handler.c:    if ( !IS_NPC( ch ) && ( ch->class == MONK )){ 
handler.c:    SET_BIT( ch->act, PLR_FIST_FIGHT );
handler.c:                    if( get_skill_level(ch, gsn_fist_fight) < 5  || ob->weight > get_curr_str(ch) * 2)
handler.c:                        REMOVE_BIT( ch->act, PLR_FIST_FIGHT );
handler.c:    REMOVE_BIT( ch->act, PLR_FIST_FIGHT );
handler.c:    REMOVE_BIT( ch->act, PLR_FIST_FIGHT );
handler.c:            SET_BIT(ch->act, PLR_RIDE);
handler.c:            if( ch->desc && ch->desc->original )
handler.c:                affect_strip( ch->desc->original, gsn_ride);
handler.c:            REMOVE_BIT(ch->act, PLR_RIDE);
handler.c:    if ( obj->pIndexData->on_message )
handler.c://  act( obj->pIndexData->on_message, ch, obj, NULL, TO_ROOM );
handler.c:  act( obj->pIndexData->on_message, ch, obj, NULL, TO_CHAR );
handler.c:  if ( obj && (obj->hp||obj->material->hp) ){
handler.c:      OBJ_HP * ohp = obj->hp;
handler.c:      for( ; ohp; ohp = ohp->next ){
handler.c:    if( IS_SET( ohp->event, HP_WEAR ) )
handler.c:        if ( ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_ARTIFACT ) && 
handler.c:        //ch->pcdata->learned[gsn_artifact] * ohp->percent * 
handler.c:                                    get_skill_percent( ch, gsn_artifact) * ohp->percent *
handler.c:          || ( IS_NPC( ch ) && ohp->percent * get_curr_wis( ch ) / 25
handler.c:      trigger_obj_hp(obj, skill_lookup(ohp->hp_name), ohp->level, ch, ch);
handler.c:      if( obj->material->hp ) {
handler.c:      for( ohp = obj->material->hp ; ohp; ohp = ohp->next ){
handler.c:    if( IS_SET( ohp->event, HP_WEAR ) )
handler.c:        if ( ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_ARTIFACT ) && 
handler.c:        //ch->pcdata->learned[gsn_artifact] * ohp->percent * 
handler.c:                                    get_skill_percent( ch, gsn_artifact) * ohp->percent *
handler.c:          || ( IS_NPC( ch ) && ohp->percent * get_curr_wis( ch ) / 25
handler.c:      trigger_obj_hp(obj, skill_lookup(ohp->hp_name), ohp->level, ch, ch);
handler.c:  if ( IS_NPC( ch ) && ch->position == POS_DEAD )
handler.c:  switch ( ch->pcdata->prime_attr )
handler.c:  if( obj->wear_loc == WEAR_NONE )
handler.c:      sprintf( buf, "Unequip_char: %s already unequipped with %d.",ch->name, obj->pIndexData->vnum );
handler.c:  ac =apply_ac( obj, obj->wear_loc );
handler.c:    //if( !IS_NPC(ch) && ch->pcdata->learned[gsn_armor_mastery] > 0 )
handler.c:  ch->armor += ac;
handler.c:  obj->wear_loc  = -1;
handler.c:  for( paf = obj->pIndexData->affected; paf; paf = paf->next )
handler.c:       chk_cast = skill_lookup(affect_bit_name(paf->bitvector));
handler.c:  for( paf = obj->material->affected; paf; paf = paf->next ){
handler.c:  for( paf = obj->affected; paf; paf = paf->next ){
handler.c:  if( obj->item_type == ITEM_LIGHT
handler.c:      && obj->value[2] != 0
handler.c:      && ch->in_room
handler.c:      && ch->in_room->light > 0 )
handler.c:      --ch->in_room->light;
handler.c:  if( !IS_NPC( ch ) && ( ch->class == MONK ))
handler.c:          SET_BIT( ch->act, PLR_FIST_FIGHT );
handler.c:              if( get_skill_level(ch, gsn_fist_fight) < 5  || ob->weight > get_curr_str(ch) * 2)
handler.c:                  REMOVE_BIT( ch->act, PLR_FIST_FIGHT );
handler.c:          REMOVE_BIT( ch->act, PLR_FIST_FIGHT );
handler.c:      REMOVE_BIT( ch->act, PLR_FIST_FIGHT );
handler.c:          SET_BIT(ch->act, PLR_RIDE);
handler.c:          if( ch->desc && ch->desc->original )
handler.c:              affect_strip( ch->desc->original, gsn_ride);
handler.c:          REMOVE_BIT(ch->act, PLR_RIDE);
handler.c:  if( obj->pIndexData->off_message )
handler.c:      act( obj->pIndexData->off_message, ch, obj, NULL, TO_CHAR );
handler.c://  act( obj->pIndexData->off_message, ch, obj, NULL, TO_ROOM );
handler.c:  if( IS_SET(obj->pIndexData->progtypes , OBJ_ACT))
handler.c:    for ( obj = list; obj; obj = obj->next_content )
handler.c:  if ( obj->deleted )
handler.c:  if ( obj->pIndexData == pObjIndex )
handler.c:    if ( !( in_room = obj->in_room ) )
handler.c:    if ( obj == in_room->contents )/* obj is the first obj in this room?*/
handler.c:  in_room->contents = obj->next_content;
handler.c:    else /*looking the in_room->contents for this obj*/
handler.c:  for ( prev = in_room->contents; prev; prev = prev->next_content )
handler.c:      if ( prev->next_content == obj )
handler.c:    prev->next_content = obj->next_content;
handler.c:    obj->in_room      = NULL;
handler.c:    obj->next_content = NULL;
handler.c:    obj->next_content   = pRoomIndex->contents;
handler.c:    pRoomIndex->contents  = obj;
handler.c:    obj->in_room    = pRoomIndex;
handler.c:    obj->carried_by   = NULL;
handler.c:    obj->in_obj     = NULL;
handler.c:    if ( obj_to->deleted )
handler.c:    for(top_obj = obj_to ; top_obj ; top_obj = top_obj->in_obj ){
handler.c:        if( !top_obj->in_obj ) break;
handler.c:    if( obj_to->item_type == ITEM_HORSE )
handler.c:    else if( top_obj->carried_by ) 
handler.c:          top_obj->carried_by->carry_number -= get_obj_number( top_obj );
handler.c:          top_obj->carried_by->carry_weight -= get_obj_weight( top_obj );
handler.c:    obj->next_content   = obj_to->contains;
handler.c:    obj_to->contains    = obj;
handler.c:    obj->in_obj     = obj_to;
handler.c:    obj->in_room    = NULL;
handler.c:    obj->carried_by   = NULL;
handler.c:    if ( top_obj->carried_by && obj_to->item_type != ITEM_HORSE )
handler.c:        top_obj->carried_by->carry_number += get_obj_number( top_obj );
handler.c:        top_obj->carried_by->carry_weight += get_obj_weight( top_obj );
handler.c:    if ( !( obj_from = obj->in_obj ) )
handler.c:    if( /*obj_from->item_type == ITEM_CONTAINER &&*/ obj_from->carried_by && obj_from->item_type != ITEM_HORSE ) 
handler.c:        obj_from->carried_by->carry_number -= get_obj_number( obj_from );
handler.c:        obj_from->carried_by->carry_weight -= get_obj_weight( obj_from );
handler.c:    if ( obj == obj_from->contains )
handler.c:  obj_from->contains = obj->next_content;
handler.c:  for ( prev = obj_from->contains; prev; prev = prev->next_content )
handler.c:      if ( prev->next_content == obj )
handler.c:    prev->next_content = obj->next_content;
handler.c:    obj->next_content = NULL;
handler.c:    obj->in_obj       = NULL;
handler.c:    for ( ; obj_from; obj_from = obj_from->in_obj )
handler.c:  if ( obj_from->deleted )
handler.c:  if ( obj_from->carried_by && obj_from->item_type != ITEM_HORSE )
handler.c:      obj_from->carried_by->carry_number += get_obj_number( obj_from );
handler.c:      obj_from->carried_by->carry_weight += get_obj_weight( obj_from );
handler.c:    if ( obj->deleted )
handler.c:    if ( obj->in_room    )
handler.c:    else if ( obj->carried_by )
handler.c:    else if ( obj->in_obj     )
handler.c:    for ( obj_content = obj->contains; obj_content; obj_content = obj_next )
handler.c:  obj_next = obj_content->next_content;
handler.c:  if( obj_content->deleted )
handler.c:    obj->deleted = TRUE;
handler.c:    for ( ed = obj->extra_descr; ed; ed = ed_next )
handler.c:        ed_next = ed->next;
handler.c:        free_string( ed->description );
handler.c:        free_string( ed->keyword     );
handler.c:        ed->next     = extra_descr_free;
handler.c:    for ( paf = obj->affected; paf; paf = paf_next )
handler.c:        paf_next = paf->next;
handler.c:        if ( obj->affected == paf )
handler.c:    obj->affected = paf->next;
handler.c:          for ( prev = obj->affected; prev; prev = prev->next )
handler.c:        if ( prev->next == paf )
handler.c:            prev->next = paf->next;
handler.c:        paf->next   = affect_free;
handler.c:    obj->next_content = NULL;
handler.c:      free_string( obj->name      );
handler.c:      free_string( obj->description );
handler.c:      free_string( obj->short_descr );
handler.c:/*    free_string( obj->cname     );*/
handler.c:      --obj->pIndexData->count;
handler.c:  obj->next = obj_free;
handler.c:  if( !ch->in_room )
handler.c:  REMOVE_BIT(ch->affected_by, AFF_BATTLE);
handler.c:  if( ch->fighting )
handler.c:  if( IS_SET(ch->act, PLR_DEAD) ) 
handler.c:  if( ( vch = ch->hunting ) )
handler.c:      ch->hunting = NULL;
handler.c:      if( vch->hunted == ch )
handler.c:          vch->hunted = ch->next_in_hunt;
handler.c:          for( rch = vch->hunted; rch; rch = rch->next_in_hunt )
handler.c:               if( rch->next_in_hunt == ch )
handler.c:                   rch->next_in_hunt = ch->next_in_hunt;
handler.c:      ch->next_in_hunt = NULL;
handler.c:  if( ( ch->hunted ) )
handler.c:      for( vch = ch->hunted; vch; vch = rch )
handler.c:           rch = vch->next_in_hunt;
handler.c:           vch->hunting = NULL;
handler.c:           vch->next_in_hunt = NULL;
handler.c:      ch->hunted = NULL;
handler.c:  if( ( vch = ch->assassinating ) )
handler.c:      ch->assassinating = NULL;
handler.c:      if( vch->assassinated == ch )
handler.c:          vch->assassinated = ch->next_in_ass;
handler.c:          for( rch = vch->assassinated; rch; rch = rch->next_in_ass )
handler.c:               if( rch->next_in_ass == ch )
handler.c:                   rch->next_in_ass = ch->next_in_ass;
handler.c:      ch->next_in_ass = NULL;
handler.c:  if( ( ch->assassinated ) )
handler.c:      for( vch = ch->assassinated; vch; vch = rch )
handler.c:           rch = vch->next_in_ass;
handler.c:           vch->assassinating = NULL;
handler.c:           vch->next_in_ass = NULL;
handler.c:  if( (ch->tracking))
handler.c:      vch = ch->tracking;
handler.c:      ch->tracking = NULL;
handler.c:      if( vch->tracked == ch ) 
handler.c:          vch->tracked = ch->next_in_track;
handler.c:          for( rch = vch->tracked ; rch; rch = rch->next_in_track )
handler.c:               if( rch->next_in_track == ch ) 
handler.c:                   rch->next_in_track = ch->next_in_track;
handler.c:      ch->next_in_track = NULL;
handler.c:  if( ( ch->tracked ) )
handler.c:      for( vch = ch->tracked; vch; vch = rch )
handler.c:           rch = vch->next_in_track;
handler.c:           vch->tracking = NULL;
handler.c:           vch->next_in_track = NULL;
handler.c:      ch->tracked = NULL;
handler.c:  if( ( vch = ch->rembch ) )
handler.c:  if( ( room = ch->rrembed ) )
handler.c:  if( ( vch = ch->protector ) )
handler.c:  if( ( vch = ch->protecting ) )
handler.c:  if( !IS_NPC( ch ) && ch->pcdata->clanpk == 1 )
handler.c:      if( clan_war->fighting < 2 )
handler.c:          if( clan_war->clan_a == ch->clan )
handler.c:                   if( clan_war->clan_a_member[i] == ch )
handler.c:                       clan_war->clan_a_member[i] = NULL;
handler.c:              clan_war->clan_a_num --;
handler.c:              if( clan_war->clan_a_num == 0 )
handler.c:                  clan_war->fighting = 0;
handler.c:                  clan_war->clan_a = NULL;
handler.c:                  clan_war->clan_b = NULL;
handler.c:                if( clan_war->clan_a_member[i] == ch )
handler.c:                    clan_war->clan_a_member[i] = NULL;
handler.c:              clan_war->clan_b_num --;
handler.c:              if( clan_war->clan_b_num == 0 )
handler.c:                  clan_war->fighting = 0;
handler.c:                  clan_war->clan_a = NULL;
handler.c:                  clan_war->clan_b = NULL;
handler.c:            ch->clan->name, ch->name );
handler.c:          ch->pcdata->clanpk = 0;
handler.c:          if( ch->clan == clan_war->clan_a )
handler.c:              clan_war->clan_a_num --;
handler.c:                   if( ch == clan_war->clan_a_member[i] )
handler.c:                       clan_war->clan_a_member[i] = NULL;
handler.c:              clan_war->clan_b_num --;
handler.c:                   if( ch == clan_war->clan_b_member[i] )
handler.c:                       clan_war->clan_b_member[i] = NULL;
handler.c:          if( clan_war->clan_b_num == 0 )
handler.c:                clan_war->clan_a->name, clan_war->clan_b->name );
handler.c:              clan_war->clan_a->bank += 1000000;
handler.c:              clan_war->clan_a->warwin ++;
handler.c:              clan_war->clan_b->warlose ++;
handler.c:                   if( clan_war->clan_a_member[i] )
handler.c:                       clan_war->clan_a_member[i]->pcdata->clanpk = 0;
handler.c:                       clan_war->clan_a_member[i] = NULL;
handler.c:                       clan_war->clan_b_member[i] = NULL;
handler.c:              clan_war->fighting = 0;
handler.c:              clan_war->clan_a = NULL;
handler.c:              clan_war->clan_b = NULL;
handler.c:              clan_war->clan_a_num = 0;
handler.c:          else if ( clan_war->clan_a_num == 0 )
handler.c:                clan_war->clan_b->name, clan_war->clan_a->name );
handler.c:              clan_war->clan_b->bank += 1000000;
handler.c:              clan_war->clan_b->warwin ++;
handler.c:              clan_war->clan_a->warlose ++;
handler.c:                   if( clan_war->clan_b_member[i] )
handler.c:                       clan_war->clan_b_member[i]->pcdata->clanpk = 0;
handler.c:                       clan_war->clan_b_member[i] = NULL;
handler.c:                       clan_war->clan_a_member[i] = NULL;
handler.c:              clan_war->fighting = 0;
handler.c:              clan_war->clan_a = NULL;
handler.c:              clan_war->clan_b = NULL;
handler.c:              clan_war->clan_b_num = 0;
handler.c:      && ch->gater
handler.c:      && IS_NPC( ch->gater )) 
handler.c:      if( check_qmark ( ch->gater, "max_gate_mobs" ) )
handler.c:          do_mpmod_qmark ( ch->gater, "self max_gate_mobs v0 - 1" );
handler.c:      ch->gater = NULL;
handler.c:  if( ch->qmark )
handler.c:      for( qmark = ch->qmark; qmark; qmark = qmark->next )
handler.c:           if( qmark->fDeath || IS_NPC( ch ) )
handler.c:           if( ch == auction->owner )
handler.c:               talk_channel( auction->owner , "¦]¬°¥»¤H¦b©ç½æ¤¤³~¦º¤`¡A©ç½æ¦]¦¹¤¤¤î¡C", CHANNEL_AUCTION, "¡i©ç½æ¡j",HIY ); 
handler.c:               obj_to_char( auction->obj, auction->owner );
handler.c:                   auction_list = auction_list->next;
handler.c:                   for( auc_next = auction_list ; auc_next; auc_next = auc_next->next )
handler.c:                        if( auc_next->next == auction )
handler.c:                            auc_next->next = auction->next;
handler.c:                            auc_next = auction->next;
handler.c:           if( ch == auction->buyer )
handler.c:               talk_channel( auction->owner , "¦]¬°¥X»ùªÌ¦b©ç½æ¤¤³~¦º¤`¡A©ç½æ¦]¦¹¤¤¤î¡C", CHANNEL_AUCTION, "¡i©ç½æ¡j",HIY ); 
handler.c:               obj_to_char( auction->obj, auction->owner );
handler.c:                   auction_list = auction_list->next;
handler.c:                   for( auc_next = auction_list ; auc_next; auc_next = auc_next->next )
handler.c:                        if( auc_next->next == auction )
handler.c:                            auc_next->next = auction->next;
handler.c:                            auc_next = auction->next;
handler.c:           auc_next = auction->next;
handler.c:          name = ch->short_descr;
handler.c:          name = ch->name;
handler.c:      if( ( vch = ch->rembed ) )
handler.c:      if( ch->group ) {
handler.c:         - from Erwin Andreasen <erwin@pip.dknet.dk> */
handler.c:      for( obj = ch->carrying; obj; obj = obj_next )
handler.c:          obj_next = obj->next_content;
handler.c:          if( obj->deleted )
handler.c:      if( ch->eqbank )
handler.c:          for( obj = ch->eqbank; obj; obj = obj_next )
handler.c:               obj_next = obj->next_content;
handler.c:               obj->next = object_list;
handler.c:               obj->next_content = NULL;
handler.c:               obj->deleted = TRUE;
handler.c:  recall = ch->in_room->area->recall;
handler.c:  death = ch->in_room->area->death;
handler.c:           &&  ch->desc
handler.c:           &&  ch->desc->connected == CON_PLAYING )
handler.c:           &&  !ch->desc ) )
handler.c:      ch->position = POS_RESTING;
handler.c:      if( !IS_NPC (ch) && ch->pcdata )   //Added by Razgriz  20050630
handler.c:          ch->pcdata->condition[COND_DRUNK] = 0;  //Added by Razgriz  20050630
handler.c:      //        if( IS_SET(ch->act, PLR_DEAD) ) {
handler.c:      --ch->pIndexData->count;
handler.c:  else if( IS_SET( ch->act, PLR_HORSE ) )
handler.c:      if( ch->pcdata->horse )
handler.c:          ch->pcdata->horse->pcdata->ride = 0;
handler.c:          ch->pcdata->horse->pcdata->horse = NULL;
handler.c:      ch->pcdata->horse = NULL;
handler.c:  if( ch->desc && ch->desc->original )
handler.c:  for( wch = char_list; wch; wch = wch->next )
handler.c:       if( wch->reply == ch )
handler.c:           wch->reply = NULL;
handler.c:  ch->position = POS_DEAD;
handler.c:  ch->deleted = TRUE;
handler.c:  if( ch->desc )
handler.c:      ch->desc->character = NULL;
handler.c:    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
handler.c:  if ( !can_see( ch, rch ) || !is_name( arg, rch->name ) || rch->deleted)
handler.c:    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
handler.c:  if ( !can_see( ch, rch ) || !is_pfxname( arg, rch->name ) || rch->deleted)
handler.c:    for ( wch = char_list; wch ; wch = wch->next )
handler.c:  if ( !can_see( ch, wch ) || !is_name( arg, wch->name )|| wch->deleted )
handler.c:    for ( wch = char_list; wch ; wch = wch->next )
handler.c:  if ( !can_see( ch, wch ) || !is_pfxname( arg, wch->name ) || wch->deleted)
handler.c:    for ( wch = char_list; wch ; wch = wch->next )
handler.c:        if ( !is_name ( arg, wch->name ) || wch->deleted )
handler.c:    for ( wch = char_list; wch ; wch = wch->next )
handler.c:        if ( !is_pfxname ( arg, wch->name ) || wch->deleted)
handler.c: * Used by area-reset 'P' command.
handler.c:    for ( obj = object_list; obj; obj = obj->next )
handler.c:  if ( obj->deleted )
handler.c:  if ( obj->pIndexData == pObjIndex )
handler.c:    OBJ_INDEX_DATA * pOID = obj->pIndexData;
handler.c:    switch( obj->item_type )
handler.c:      if( obj->value[3] > 0 ) return obj->value[3];
handler.c:      else if( pOID->value[2] == DURA_AUTO ) return pOID->material->value[3];
handler.c:      else if( pOID->value[2] > DURA_MAX ){
handler.c:        int du = pOID->value[2];
handler.c:        //du -= ( du % 10000 );
handler.c:      else return pOID->value[2];
handler.c:      if( obj->value[3] == 14 /* bow */)
handler.c:      if( pOID->value[0] == DURA_AUTO ) return pOID->material->value[3];
handler.c:      else if( pOID->value[0] > DURA_MAX ){
handler.c:        int du = pOID->value[0];
handler.c:        //du -= ( du % 10000 );
handler.c:      else return pOID->value[0];
handler.c:    switch( obj->item_type ) {
handler.c:      if( obj->value[3] != 14 /* bow */)
handler.c:    return obj->value[2];
handler.c:      return obj->value[0];
handler.c:    if( get_max_dura(obj) == -1 ) return TRUE;
handler.c:    if(get_curr_dura(obj) == -1 ) return TRUE;
handler.c:    if( IS_SET(obj->extra_flags, ITEM_HUM) && number_bits(2) != 1 ) return; //12.5%
handler.c:    switch( obj->item_type ) {
handler.c:      obj->value[2] -= 10;
handler.c:      obj->value[0] -= 10;
handler.c:    if( IS_SET(obj->extra_flags, ITEM_HUM) && number_bits(2) != 1 ) return; //12.5%
handler.c:    switch( obj->item_type ) {
handler.c:      obj->value[2] -= 1;
handler.c:      obj->value[0] -= 1;
handler.c:    switch( obj->item_type ) {
handler.c:      obj->value[2] += value;
handler.c:      obj->value[2] = UMIN( get_max_dura(obj), obj->value[2]);
handler.c:      obj->value[0] += value;
handler.c:      obj->value[0] = UMIN( get_max_dura(obj), obj->value[0]);
handler.c:    for ( obj = list; obj; obj = obj->next_content )
handler.c:  if ( can_see_obj( ch, obj ) && is_name( arg, obj->name ) )
handler.c:    for ( obj = list; obj; obj = obj->next_content )
handler.c:  if ( can_see_obj( ch, obj ) && is_pfxname( arg, obj->name ) )
handler.c:      for ( obj = ch->carrying; obj; obj = obj->next_content )
handler.c:    if ( obj->wear_loc == WEAR_NONE
handler.c:        && is_pfxname( arg, obj->name ) )
handler.c:      for ( obj = ch->carrying; obj; obj = obj->next_content )
handler.c:    if ( obj->pIndexData->vnum == number 
handler.c:      && obj->wear_loc == WEAR_NONE
handler.c:      for( obj = ch->carrying; obj; obj = obj->next_content )
handler.c:          if( obj->wear_loc != WEAR_NONE
handler.c:              && is_pfxname( arg, obj->name ) )
handler.c:      for( obj = ch->carrying; obj; obj = obj->next_content )
handler.c:           if( obj->wear_loc != WEAR_NONE
handler.c:               && obj->pIndexData->vnum == number )
handler.c:    for ( obj = ch->carrying; obj; obj = obj->next_content )
handler.c://      if ( GLOBAL_OBJ_UPDATE && obj->update_checked ) continue; //Mark by Razgriz 20050702
handler.c:      if (  obj->wear_loc != WEAR_NONE
handler.c:        && is_pfxname( arg, obj->name )
handler.c:          && ( obj->pIndexData->vnum == updating_obj->pIndexData->vnum )
handler.c:    for ( obj = ch->carrying; obj; obj = obj->next_content )
handler.c://      if ( GLOBAL_OBJ_UPDATE && obj->update_checked ) continue; //Mark by Razgriz 20050702
handler.c:      if( obj->wear_loc != WEAR_NONE
handler.c:        && obj->pIndexData->vnum == number
handler.c:          && ( obj->pIndexData->vnum == updating_obj->pIndexData->vnum )
handler.c:    if ( !ch || !ch->in_room ) return NULL;		//Added by Razgriz	20050713
handler.c:    obj = get_obj_list( ch, argument, ch->in_room->contents );
handler.c:    for( obj = object_list ; obj ; obj = obj->next ){
handler.c:  if( obj->pIndexData->vnum == vnum && !obj->deleted ) ++i;
handler.c:    for( obj = object_list ; obj ; obj = obj->next ){
handler.c:  if( obj->pIndexData->vnum == vnum && !obj->deleted ) return obj;
handler.c:    for ( obj = object_list; obj; obj = obj->next )
handler.c:  if ( can_see_obj( ch, obj ) && is_name( arg, obj->name ) )
handler.c:    for ( obj = object_list; obj; obj = obj->next )
handler.c:  if ( can_see_obj( ch, obj ) && is_pfxname( arg, obj->name ) )
handler.c:    obj->value[0]   = amount;
handler.c://    if ( obj->item_type == ITEM_CONTAINER ){
handler.c:   if( obj->contains ) {
handler.c:  for ( pobj = obj->contains; pobj; pobj = pobj->next_content )
handler.c:      if ( pobj->deleted )
handler.c:    if( obj->item_type == ITEM_CONTAINER && obj->value[0] == -1 )
handler.c:        else if( obj->item_type == ITEM_CONTAINER && obj->value[3] < 0 )
handler.c:            number = UMAX( 0, number + obj->value[3]);
handler.c:    weight = obj->weight;
handler.c:    for ( pObj = obj->contains; pObj; pObj = pObj->next_content )
handler.c:  if ( pObj->deleted )
handler.c:    if( obj->item_type == ITEM_CONTAINER && obj->value[0] == -1 ) 
handler.c:        weight = UMAX( obj->weight, 0 );
handler.c:    else if( obj->item_type == ITEM_CONTAINER && obj->value[3] > 0 ) 
handler.c:        weight = UMAX( obj->weight,( ( weight - obj->weight ) * obj->value[3] )/ 100);
handler.c:    if ( pRoomIndex->light > 0 )
handler.c:    for ( obj = pRoomIndex->contents; obj; obj = obj->next_content )
handler.c:  if ( obj->deleted )
handler.c:  if ( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
handler.c:    if ( IS_SET( pRoomIndex->room_flags, ROOM_DARK ) )
handler.c:    if ( pRoomIndex->sector_type == SECT_INSIDE
handler.c:  || pRoomIndex->sector_type == SECT_CITY )
handler.c:    for ( rch = pRoomIndex->people; rch; rch = rch->next_in_room )
handler.c:  if ( rch->deleted )
handler.c:    if ( IS_SET( pRoomIndex->room_flags, ROOM_PRIVATE  ) && count >= 2 )
handler.c:    if ( IS_SET( pRoomIndex->room_flags, ROOM_SOLITARY ) && count >= 1 )
handler.c:    if( IS_NPC(ch) ) return -1;
handler.c:        if(IS_SET(ch->act, PLR_WIZINVIS) )
handler.c:        else return -1;
handler.c:    return qm->v0;
handler.c:	if ( !ch || !victim || victim->deleted )
handler.c:	    && !IS_NPC( victim ) && IS_SET( victim->act, PLR_WIZINVIS ) )
handler.c:	    && IS_SET( victim->act, PLR_WIZINVIS )
handler.c:	if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) && IS_IMMORTAL( ch ) )
handler.c:		if(!IS_SET( race_table[ ch->race ].race_abilities, RACE_BEHOLDER )){
handler.c:	//    if ( room_is_dark( ch->in_room )
handler.c:	//  && !IS_SET( race_table[ ch->race ].race_abilities, RACE_INFRAVISION )
handler.c:	if ( victim->position == POS_DEAD )
handler.c:	if ( ( IS_AFFECTED( victim, AFF_INVISIBLE ) || IS_SET( race_table[ch->race].race_abilities, RACE_INVIS))
handler.c:	     && !IS_SET( race_table[ ch->race ].race_abilities, RACE_DETECT_INVIS )
handler.c:	    && !IS_SET( race_table[ ch->race ].race_abilities, RACE_DETECT_HIDDEN )
handler.c:	    && !victim->fighting )
handler.c:    if ( obj->deleted )
handler.c:    if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:    if ( IS_AFFECTED( ch, AFF_BLIND ) && ( obj->item_type != ITEM_POTION && obj->item_type != ITEM_PILL))
handler.c:    if ( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
handler.c:    if ( room_is_dark( ch->in_room )
handler.c:  && !IS_SET( race_table[ ch->race ].race_abilities, RACE_INFRAVISION )
handler.c:    if ( IS_SET( obj->extra_flags, ITEM_INVIS )
handler.c:  && !IS_SET( race_table[ ch->race ].race_abilities, RACE_DETECT_INVIS )
handler.c:    if( IS_SET(obj->extra_flags, ITEM_PERSONAL) && !IS_IMMORTAL( ch )) 
handler.c:    if ( !IS_SET( obj->extra_flags, ITEM_NODROP ) )
handler.c:    else if ( IS_SET( obj->extra_flags, ITEM_REMOVE_NODROP ) )
handler.c:      REMOVE_BIT( obj->extra_flags, ITEM_REMOVE_NODROP );
handler.c:    switch ( obj->item_type )
handler.c:    for ( in_obj = obj; in_obj->in_obj; in_obj = in_obj->in_obj )
handler.c:    if ( in_obj->carried_by )
handler.c:        obj->item_type, obj->name, obj->carried_by->name );
handler.c:        obj->item_type, obj->name );
handler.c:    if ( extra_flags & ITEM_ANTI_GOOD  ) strcat( buf, " anti-good"  );
handler.c:    if ( extra_flags & ITEM_ANTI_EVIL  ) strcat( buf, " anti-evil"  );
handler.c:    if ( extra_flags & ITEM_ANTI_NEUTRAL ) strcat( buf, " anti-neutral" );
handler.c:  bug( "mob vnum = %d", ch->pIndexData->vnum );
handler.c:    if ( !ch->pcdata )
handler.c:  return ch->desc->original;
handler.c:    if ( ( !IS_NPC( ch ) && str_infix( skllnm, ch->pcdata->immskll ) )
handler.c:  d_next = d->next;
handler.c:  if ( d->connected == CON_PLAYING )
handler.c:      if ( d->character->position == POS_FIGHTING )
handler.c:        interpret( d->character, "save" );
handler.c:        interpret( d->character, "quit" );
handler.c:    if ( vector & ITEM_TWO_HAND     ) strcat( buf, " two-handed"    );
handler.c:    if ( vector & ACT_CLAN ) strcat( buf, " clan-mob"     );
handler.c:    if ( vector & ACT_STAY_AREA     ) strcat( buf, " stay-area"    );
handler.c:    if ( vector & ACT_MOB_AI      ) strcat( buf, " mob-ai"    );
handler.c:    for( mat = material_list ; mat ; mat = mat -> next ) {
handler.c:  if( !str_cmp( race, mat->name ) ) break; 
handler.c:    for( q = qmark_string_list; q; q  = q ->next ) {
handler.c:  if( !str_cmp(str, q->name)){
handler.c:      return q->name;
handler.c:    q->name = str_dup(b);
handler.c:    q -> next = qmark_string_list;
handler.c:    return q->name ;
handler.c:    return -1;
handler.c:    return -1;
handler.c:    if( skill_table[sn].require_attr & attr_map[ch->pcdata->snd_attr] )
handler.c:    if( skill_table[sn].require_attr & attr_map[ch->pcdata->prime_attr] )
handler.c:    if( IS_SET(pRoom->room_flags, ROOM_CLAN_LV3 )) return 3;
handler.c:    else if( IS_SET(pRoom->room_flags, ROOM_CLAN_LV2 )) return 2;
handler.c:    else if( IS_SET(pRoom->room_flags, ROOM_CLAN_LV1 )) return 1;
handler.c:  if( !name || name[0] == '\0' ) return -1;
handler.c:  if( !isalpha( ( letter = name[0] ))) return -1;
handler.c:  letter = LOWER(letter) - 'a';
handler.c:  for( pSym = symbol_hash[letter] ; pSym ; pSym = pSym->next ){
handler.c:    if( !str_cmp( pSym->str, name )) {
handler.c:      return pSym->num;
handler.c:      number |= ( 1 << ( letter - 'a' + 26 ) );
handler.c:      number |= ( 1 << (letter - 'A') );
handler.c:  return (number > 0) ? number : -1;
handler.c:  SET_BIT( ch->affected_by, paf->bitvector );
handler.c:  REMOVE_BIT( ch->affected_by, paf->bitvector );
handler.c:    paf_new->deleted  = FALSE;
handler.c:    paf_new->next = ch->affected;
handler.c:    paf_new->next_in_list = r_affect_list;
handler.c:  paf_new->prev_in_list = NULL;
handler.c:  r_affect_list->prev_in_list  = paf_new;
handler.c:    paf_new->owner = ch;
handler.c:    ch->affected  = paf_new;
handler.c:    if ( !ch->affected )
handler.c:    //paf->deleted = TRUE;
handler.c:    if( paf->prev_in_list )
handler.c:  paf->prev_in_list->next_in_list = paf->next_in_list;
handler.c:    if( paf->next_in_list )
handler.c:  paf->next_in_list->prev_in_list = paf->prev_in_list;
handler.c:    if( paf == paf->owner->affected ) {
handler.c:  paf->owner->affected = paf->next;
handler.c:  for( vaf = paf->owner->affected ; vaf; vaf = vaf->next ){
handler.c:      if( vaf->next == paf ) {
handler.c:    vaf->next = paf->next;
handler.c:    for ( paf = ch->affected; paf; paf = paf->next )
handler.c:  if ( paf->deleted )
handler.c:  if ( paf->type == sn )
handler.c:    for ( paf = ch->affected; paf; paf = paf->next )
handler.c:  if ( paf->deleted )
handler.c:  if ( paf->type == sn )
handler.c:    for( qm = ch->qmark ; qm ; qm = qm ->next ) {
handler.c:  if( !str_cmp( qm->mark_name, q)) break;
handler.c:    for( qm = ch->qmark ; qm ; qm = qm ->next ) {
handler.c:  if( !str_cmp( qm->mark_name, q)) break;
handler.c:      || IS_SET( race_table[victim->race].race_abilities, RACE_FLY))
handler.c:    if( (horse = get_eq_char(victim,WEAR_RIDE)) && horse->value[2] & 8 )
handler.c:  rcall_out_list = rm->next;
handler.c:      cod_next = cod->next;
handler.c:    cod->next = rm->next;
handler.c:    rm->next = rcall_out_free;
handler.c:    free_string(rm->cmd);
handler.c:    rm->owner = NULL;
handler.c:    rm->timer = 0;
handler.c:    rm->cmd = NULL;
handler.c:  call_out_list = rm->next;
handler.c:      cod_next = cod->next;
handler.c:    cod->next = rm->next;
handler.c:    rm->next = call_out_free;
handler.c:    free_string(rm->cmd);
handler.c:    rm->owner = NULL;
handler.c:    rm->timer = 0;
handler.c:    rm->cmd = NULL;
handler.c:    call->next = call_out_list;
handler.c:        delay -= (delay * nSklv * (nSklv + 14)) * 0.005;
handler.c:      ch->wait = 0;
handler.c:    if( wait == -999)
handler.c:        wait = UMAX(1, (wait - sklv/2) / (sklv / 3+1));
handler.c:			if(nMediSlow < -50) nMediSlow = -50;
handler.c:			if(nSpriSlow < -50) nSpriSlow = -50;
handler.c:    ch->wait = UMIN( 300, ch->wait + wait );
handler.c:    if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:        return GetSorGateMobLevel(ch->pIndexData->vnum) * 2 + HasMageSorMaster(ch);
handler.c:    if(ch->level > 35) moblv = (ch->level - 35) / 5;
handler.c:    if(IS_SET(ch->special, EXPERT)) moblv = (moblv + 7) / 2;
handler.c:        //if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:        //    return GetSorGateMobLevel(ch->pIndexData->vnum) * 2;
handler.c:				//	  if(ch->level > 35) moblv = (ch->level - 35) / 5;
handler.c:				//		if(IS_SET(ch->special, EXPERT)) moblv = (moblv + 7) / 2;
handler.c:            if( ch->level > 40 ) ++moblv;
handler.c:            if( ch->level > 50 ) ++moblv;
handler.c:            if( ch->level > 60 ) 
handler.c:                if ( !ch->deleted ) {   //Added by Razgriz  20050622
handler.c:                    for( vch = ch->in_room->people; vch; vch = vch->next_in_room )
handler.c:                if( ch->level > 65 ) 
handler.c:            if( IS_SET(ch->special, EXPERT) ) moblv+=2;
handler.c:    else if( ch->class < WIZARD && ch->level > 29){
handler.c:    return ( UMIN(6,ch->pcdata->learned[sn] / 1000) );
handler.c:    int nRace    = ch->race;
handler.c:            ch->dodge += nOrgSklv * 2 + (nOrgSklv * nOrgSklv) / 2;
handler.c:            ch->dodge -= nNewSklv * 2 + (nNewSklv * nNewSklv) / 2;
handler.c:        ch->pdr -= GetArmorMasteryPdrBonus(ch);
handler.c:		ch->pcdata->learned[sn] = nNewSklv * 1000 + get_skill_percent(ch, sn);
handler.c:        ch->pdr += GetArmorMasteryPdrBonus(ch);
handler.c:    ch->pcdata->learned[sn] = mod + (ch->class >= WIZARD ? get_skill_level(ch, sn) * 1000 : 0 );
handler.c:    return ( ( ( skill_table[sn].skill_level[ch->class] ) / 1000 )  );
handler.c:    return (( ( skill_table[sn].skill_level[apply_class[ch->pcdata->prime_attr]] ) /10 % 100 )-1);
handler.c:    return (( ( skill_table[sn].skill_level[ch->class] ) /10 % 100 ) -1 );
handler.c:        if(ch->pIndexData != NULL && IsSorGateMob(ch->pIndexData->vnum)){
handler.c:            return GetSorGateMobLevel(ch->pIndexData->vnum) * 20 + 30;
handler.c:    return ( ch->pcdata->learned[sn] % 1000 );
handler.c:    armor = ch->armor - race_table[ch->race].nature_ac; 
handler.c:        if( ch->class == MONK )
handler.c:            if( ch->carry_weight * 3 <= can_carry_w(ch) )
handler.c:                armor = armor - ch->level * 2;
handler.c:    armor += race_table[ch->race].nature_ac; 
handler.c:        if( (horse = get_eq_char( ch, WEAR_RIDE )) && ( horse->value[2] & 2 ) )
handler.c:      if( (horse = get_eq_char(ch,WEAR_RIDE) ) && ( horse->value[1] & 256 ) )
handler.c:        if( ch->pcdata->prime_attr == APPLY_STR ){
handler.c:          if(get_skill_level(ch, gsn_armor_mastery) >= 6) armor -= 100;
handler.c:          armor  = armor * (100 - bonus) / 100; 
handler.c:      if( ch->pcdata->prime_attr == APPLY_STR )
handler.c:        armor -= 150 * bonus / 11;
handler.c:        armor -= 100 * bonus / 11;
handler.c:        i += qm->v0;
handler.c:    if( ch->class < WIZARD ) return 0;
handler.c:    m = (UMIN(36,ch->level))*35000;
handler.c:    m +=( ch->level > 36 ?  ((ch->level - 36) ) * 20000 : 0);
handler.c:    ch->pcdata->skexp_earned -= xp; 
handler.c:    ch->pcdata->skexp_used -= xp;
handler.c://    if( ch->in_room->vnum != 11000 ) 
handler.c://      gain_skill_exp(ch, ( xp - xp/10 ) );
handler.c:    //if( ch->class < WIZARD ) return;
handler.c://    ch->pcdata->skexp_earned = UMIN( ch->pcdata->skexp_earned + xp , get_max_skill_exp(ch));
handler.c:    ch->pcdata->skexp_earned = ch->pcdata->skexp_earned + xp;
handler.c:    if( ch->pcdata->skexp_earned > get_max_skill_exp(ch))
handler.c:        return get_max_skill_exp(ch) - ch->pcdata->skexp_used;
handler.c:        return ch->pcdata->skexp_earned - ch->pcdata->skexp_used;
handler.c://    value = UMIN(value, (ch->pcdata->skexp_earned - ch->pcdata->skexp_used));
handler.c:    ch->pcdata->skexp_used += value;
handler.c:    return ch->pcdata->skexp_earned;
handler.c:    c = one_argument(cor->name, arg); // "corpse"
handler.c:    if( IS_NPC(ch) || ch->class < WIZARD ) return -1;
handler.c:    if( get_skill_level(ch, sn) >5 ) return -1;
handler.c:    if( skill_table[sn].apply_attr[ch->pcdata->prime_attr-1] < 0 ) return -1;
handler.c:    if( skill_table[sn].apply_attr[ch->pcdata->snd_attr-1] < 0 ) return -1;
handler.c:        return ((skill_table[sn].apply_attr[ch->pcdata->prime_attr-1] * 3 +
handler.c:                skill_table[sn].apply_attr[ch->pcdata->snd_attr-1] * 2) *
handler.c:        for(pAffData = ch->affected; pAffData; pAffData = pAffData->next){
handler.c:            if(pAffData->type == skill_lookup( "polymorph other" )){
handler.c:                return -1;
handler.c:        if(!IS_SET(race_table[ch->race].race_abilities, RACE_PC_AVAIL)) return -1;
handler.c:        int nRace  = ch->race;
handler.c:            nRace -= affected_value(ch, gsn_werewolf, APPLY_RACE);
handler.c:            while(nRace >= MAX_RACE){ nRace -= MAX_RACE; }
handler.c:            nRace -= affected_value(ch, gsn_stone_form, APPLY_RACE);
handler.c:            while(nRace >= MAX_RACE){ nRace -= MAX_RACE; }
handler.c:            if(IS_SET( race_table[nRace].race_abilities, 1 << (nRaceAbiID-1)))
handler.c:        return -1;
handler.c:    return (IS_SET(ch->act, PLR_HORSE)) ? TRUE :FALSE;
handler.c:    GROUP_DATA * pGroup = ch->group;
handler.c:        bugf("[add]%s has no group!", ch->name);
handler.c:        bugf("[add] %s is trying to group with itself",ch->name);
handler.c:    if( member->group ) {
handler.c:        bugf("[add] %s already has group",member->name);
handler.c:    member->group = pGroup;
handler.c:    member->next_in_group = pGroup->members;
handler.c:    pGroup->members = member;
handler.c:    GROUP_DATA *pGroup = member->group;
handler.c:        bugf("[remove]%s has no group!", member->name);
handler.c:    if( member == pGroup->leader ) {
handler.c:    if( pGroup->members == member ){
handler.c:        pGroup->members = member->next_in_group;
handler.c:        for( next = pGroup->members ; next ;next=next->next_in_group ){
handler.c:            if(next->next_in_group == member ) {
handler.c:                next->next_in_group = member->next_in_group;
handler.c:    member->next_in_group = NULL;
handler.c:    member->group = NULL;
handler.c:    if ( ( member->protector ) )
handler.c:    if ( ( member->protecting ) )
handler.c:        stop_protecting(member,member->protecting );
handler.c:    if( !ch->group ) {
handler.c:        bugf("[clear]%s has no group!", ch->name);
handler.c:    pG= ch->group;
handler.c:    for( pCh = pG->members ; pCh; pCh = pCh_next){
handler.c:        pCh_next = pCh->next_in_group;
handler.c:        pCh->next_in_group = NULL;
handler.c:        pCh->group = NULL;
handler.c:        if ( ( pCh->protector ) )
handler.c:        if ( ( pCh->protecting ) )
handler.c:            stop_protecting(pCh, pCh->protecting);
handler.c:    pG->members = NULL;
handler.c:		if( !(in_room = ch->in_room) )
handler.c:		if ( !( pexit = in_room->exit[i] ) || !( to_room = pexit->to_room ) )
handler.c:		if ( IS_SET( pexit->exit_info, EX_CLOSED ) )
handler.c:				&& !IS_SET( race_table[ ch->race ].race_abilities, RACE_PASSDOOR ) )
handler.c:			if ( IS_SET( pexit->exit_info, EX_PASSPROOF ) )
interp.c: * God Levels - Check them out in merc.h
interp.c:    if( ch->deleted ) return;
interp.c:    if( !ch->in_room ) return;
interp.c:    if( ch->deleted ) return;
interp.c://    REMOVE_BIT( ch->affected_by, AFF_HIDE );
interp.c:	REMOVE_BIT( ch->act, PLR_AFK );
interp.c:    !IS_NPC( ch ) && IS_SET( ch->act, PLR_FREEZE ) )
interp.c:    /*if( ch->in_room &&( ch->in_room->progtypes & ROOM_MASK)){
interp.c:	if(   rprog_mask_trigger(ch->in_room, ch, logline))
interp.c:		//if( IS_NPC( ch ) && ch->ordered == TRUE )
interp.c:		if( ch->ordered == TRUE && IS_NPC( ch ) && IS_AFFECTED( ch, AFF_SUMMONED ) && 
interp.c:			ch->ordered = FALSE;
interp.c:			ch->ordered = FALSE;
interp.c:    if ( ch->trust > 42 || IS_IMMORTAL( ch ) || ( ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_LOG ) ) )
interp.c:	sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:    if ( ch->desc && ch->desc->snoop_by )
interp.c:	write_to_buffer( ch->desc->snoop_by, "% ",    2 );
interp.c:	write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:	write_to_buffer( ch->desc->snoop_by, "\n\r",  2 );
interp.c:			 if( ch->in_room &&( obj->pIndexData->progtypes & OBJ_COMMAND))
interp.c:		/*for ( obj = ch->carrying; obj; obj = obj_next )
interp.c:			obj_next = obj->next_content;
interp.c:			obj_next = obj->next_content;
interp.c:			if( ch->in_room &&( obj->pIndexData->progtypes & OBJ_COMMAND)){
interp.c:		for ( obj = ch->in_room->contents; obj; obj = obj_next )
interp.c:			obj_next = obj->next_content;
interp.c:			if( ch->in_room &&( obj->pIndexData->progtypes & OBJ_COMMAND)){
interp.c:		if( ch->in_room &&( ch->in_room->progtypes & ROOM_COMMAND)){
interp.c:			if(   rprog_cmd_trigger(ch->in_room, ch, logline) )
interp.c://	ch->position = POS_STANDING;
interp.c:	if( IS_AFFECTED(ch, AFF_PARALYZED ) ) ch->position = POS_PARALYZED;
interp.c:	if( command[0] == '-' && !str_cmp(command, "-?") ) {
interp.c:    if ( ch->position < cmd_table[cmd].position )
interp.c:    if( ch->in_room &&( ch->in_room->progtypes & ROOM_MASK)){
interp.c:	if(   rprog_mask_trigger(ch->in_room, ch, mask_buf) )
interp.c:	if ( ch->stun_desc )
interp.c:	bug( " Obj command not exist. Obj: %d", obj->pIndexData->vnum );
interp.c:	bug( " Room command not exist. Room: %d", room->vnum );
interp.c:     * Discard null and zero-length messages.
interp.c:    to = ch->in_room->people;
interp.c:		if ( !vch->in_room )//amenda 6/2/01 for debug purpose
interp.c:			bug( vch->name, 0 );
interp.c:	to = vch->in_room->people;
interp.c:    for ( d = descriptor_list; d; d = d->next ) 
interp.c:	to = (d->original) ? d->original : d->character;
interp.c:	if ( ( to->deleted )
interp.c:	    || ( !to->desc && IS_NPC( to ) )
interp.c:	    || IS_SET( to->deaf, CHANNEL_CHAT ) )
interp.c:		case 'e': i = he_she  [URANGE( 0, ch  ->sex, 2 )];	  break;
interp.c:		case 'E': i = he_she  [URANGE( 0, vch ->sex, 2 )];	  break;
interp.c:		case 'm': i = him_her [URANGE( 0, ch  ->sex, 2 )];	  break;
interp.c:		case 'M': i = him_her [URANGE( 0, vch ->sex, 2 )];	  break;
interp.c:		case 's': i = his_her [URANGE( 0, ch  ->sex, 2 )];	  break;
interp.c:		case 'S': i = his_her [URANGE( 0, vch ->sex, 2 )];	  break;
interp.c:			    ? ( strcpy(name_buf, obj1->short_descr) )
interp.c:			    ? ( strcpy(name_buf, obj2->short_descr) )
interp.c:	if ( to->desc )
interp.c:	//    write_to_buffer( to->desc, buf, point - buf );
interp.c:    if ( *arg == '+' || *arg == '-' )
interp.c:    if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_NO_EMOTE ) )
interp.c:    switch ( ch->position )
interp.c:	 * But two players asked for it already!  -- Furey
interp.c:    if( victim->in_room->area->recall != ch->in_room->area->recall &&
interp.c:	    original = ch->in_room;
interp.c:    if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_NO_EMOTE ) )
interp.c:    switch ( ch->position )
interp.c:	      original = ch->in_room;
interp.c:     * Discard null and zero-length messages.
interp.c:    to = ch->in_room->people;
interp.c:		   if ( !vch->in_room )//amenda 6/2/01 for debug purpose
interp.c:		   	 bug( vch->name, 0 );
interp.c:	     to = vch->in_room->people;
interp.c:    for ( d = descriptor_list; d; d = d->next ) 
interp.c:	    to = (d->original) ? d->original : d->character;
interp.c:	    	    case 'e': i = he_she  [URANGE( 0, ch  ->sex, 2 )];	  break;
interp.c:	    	    case 'E': i = he_she  [URANGE( 0, vch ->sex, 2 )];	  break;
interp.c:	    	    case 'm': i = him_her [URANGE( 0, ch  ->sex, 2 )];	  break;
interp.c:	    	    case 'M': i = him_her [URANGE( 0, vch ->sex, 2 )];	  break;
interp.c:	    	    case 's': i = his_her [URANGE( 0, ch  ->sex, 2 )];	  break;
interp.c:	    	    case 'S': i = his_her [URANGE( 0, vch ->sex, 2 )];	  break;
interp.c:	    	    	    ? ( strcpy(name_buf, obj1->short_descr) )
interp.c:	    	    	    ? ( strcpy(name_buf, obj2->short_descr) )
interp.c:      if ( to->desc )
mem.c: *  and has been used here for OLC - OLC would not be what it is without   *
mem.c:        pGroup->next = group_list;
mem.c:        group_free = group_free->next;
mem.c:    pGroup->leader = NULL;
mem.c:    pGroup->members = NULL;
mem.c:        group_list = gd->next;
mem.c:        for( pNext = group_list; pNext ; pNext = pNext->next ){
mem.c:            if(pNext->next == gd ){
mem.c:                pNext->next = gd->next;
mem.c:    free_string(gd->name);
mem.c:    gd->leader = NULL;
mem.c:    gd->members = NULL;
mem.c:    gd->next = group_free;
mem.c:	reset_free	= reset_free->next;
mem.c:    pReset->next	= NULL;
mem.c:    pReset->command	= 'X';
mem.c:    pReset->arg1	= 0;
mem.c:    pReset->arg2	= 0;
mem.c:    pReset->arg3	= 0;
mem.c:	    auc_free = auc_free->next;
mem.c:	pAuc->next = NULL;
mem.c:	pAuc->owner = NULL;
mem.c:	pAuc->buyer = NULL;
mem.c:	pAuc->obj = NULL;
mem.c:	pAuc->time = 0;
mem.c:	pAuc->recall = 0;
mem.c:	pAuc->price = 0;
mem.c:    pAuc->next = auc_free;
mem.c:    pReset->next	    = reset_free;
mem.c:	area_free	= area_free->next;
mem.c:    pArea->next		= NULL;
mem.c:    pArea->name		= str_dup( "New area" );
mem.c:    pArea->recall	= ROOM_VNUM_TEMPLE;
mem.c:    pArea->area_flags	= AREA_ADDED;
mem.c:    pArea->security	= 1;
mem.c:    pArea->builders	= str_dup( "None" );
mem.c:    pArea->lvnum	= 0;
mem.c:    pArea->uvnum	= 0;
mem.c:    pArea->age		= 0;
mem.c:    pArea->nplayer	= 0;
mem.c:    pArea->identity	= str_dup("None");
mem.c:    pArea->vnum		= top_area-1;		/* OLC 1.1b */
mem.c:    sprintf( buf, "area%d.are", pArea->vnum );
mem.c:    pArea->filename	= str_dup( buf );
mem.c:    free_string( pArea->name );
mem.c:    free_string( pArea->filename );
mem.c:    free_string( pArea->builders );
mem.c:    pArea->next		=   area_free->next;
mem.c:	exit_free	=   exit_free->next;
mem.c:    pExit->to_room	=   NULL;
mem.c:    pExit->next		=   NULL;
mem.c:    pExit->vnum		=   0;
mem.c:    pExit->exit_info	=   0;
mem.c:    pExit->key		=   0;
mem.c:    pExit->keyword	=   &str_empty[0];;
mem.c:    pExit->description	=   &str_empty[0];;
mem.c:    pExit->rs_flags	=   0;
mem.c:    free_string( pExit->keyword );
mem.c:    free_string( pExit->description );
mem.c:    pExit->next		=   exit_free;
mem.c:	extra_descr_free    =	extra_descr_free->next;
mem.c:    pExtra->keyword	    =	NULL;
mem.c:    pExtra->description	    =	NULL;
mem.c:    pExtra->next	    =	NULL;
mem.c:    free_string( pExtra->keyword );
mem.c:    free_string( pExtra->description );
mem.c:    pExtra->next	=   extra_descr_free;
mem.c:	room_index_free =   room_index_free->next;
mem.c:    pRoom->next		    =	NULL;
mem.c:    pRoom->people	    =	NULL;
mem.c:    pRoom->contents	    =	NULL;
mem.c:    pRoom->extra_descr	    =	NULL;
mem.c:    pRoom->area		    =	NULL;
mem.c:	pRoom->exit[door]   =	NULL;
mem.c:    pRoom->name		    =	&str_empty[0];
mem.c:    pRoom->description	    =	&str_empty[0];
mem.c:    pRoom->vnum		    =	0;
mem.c:    pRoom->room_flags	    =	0;
mem.c:    pRoom->light	    =	0;
mem.c:    pRoom->sector_type	    =	0;
mem.c:    pRoom->rrembch	    =	NULL;
mem.c:    pRoom->roomprogs	    =	NULL;
mem.c:    pRoom->progtypes	    =	0;
mem.c:    pRoom->reset_first	    =	NULL;
mem.c:    pRoom->reset_last	    =	NULL;
mem.c:    pRoom->affected	    =	NULL;
mem.c:    pRoom->affected_by	    =	0;
mem.c:    free_string( pRoom->name );
mem.c:    free_string( pRoom->description );
mem.c:	if ( pRoom->exit[door] )
mem.c:	    free_exit( pRoom->exit[door] );
mem.c:    for ( pExtra = pRoom->extra_descr; pExtra; pExtra = pExtra->next )
mem.c:    for ( pReset = pRoom->reset_first; pReset; pReset = pReset->next )
mem.c:    pRoom->next	    =	room_index_free;
mem.c:	obj_hp_free = pHP->next;
mem.c:    pHP->next = NULL;
mem.c:    pHP->vnum = -1;
mem.c:    pHP->hp_name = &str_empty[0];
mem.c:    pHP->percent = 0;
mem.c:    pHP->event = 0;
mem.c:    pHP->level = 0;
mem.c:	r_affect_free	=   r_affect_free->next;
mem.c:    pAf->next	    =	NULL;
mem.c:    pAf->next_in_list = NULL;
mem.c:    pAf->prev_in_list = NULL;
mem.c:    pAf->owner = NULL;
mem.c:    pAf->type	    =	0;
mem.c:    pAf->duration   =	0;
mem.c:    pAf->bitvector  =	0;
mem.c:    pAf->modifier = 0;
mem.c:    pAf->deleted = FALSE;
mem.c:    pAf->next		= r_affect_free;
mem.c:	affect_free	=   affect_free->next;
mem.c:    pAf->next	    =	NULL;
mem.c:    pAf->location   =	-1;
mem.c:    pAf->modifier   =	-1;
mem.c:    pAf->type	    =	0;
mem.c:    pAf->duration   =	0;
mem.c:    pAf->bitvector  =	0;
mem.c:    pAf->deleted = FALSE;
mem.c:    pAf->next		= affect_free;
mem.c:	shop_free	=   shop_free->next;
mem.c:    pShop->next		=   NULL;
mem.c:    pShop->keeper	=   0;
mem.c:	pShop->buy_type[buy]	=   0;
mem.c:    pShop->profit_buy	=   100;
mem.c:    pShop->profit_sell	=   100;
mem.c:    pShop->open_hour	=   0;
mem.c:    pShop->close_hour	=   23;
mem.c:    pShop->next = shop_free;
mem.c:    pVrace->next = NULL;
mem.c:    pVrace->race = -1;
mem.c:    pVrace->hr_mod_q = 0;
mem.c:    pVrace->hr_mod_p = 100;
mem.c:    pVrace->dr_mod_q = 0;
mem.c:    pVrace->dr_mod_q = 100;
mem.c:	obj_index_free	=   obj_index_free->next;
mem.c:    pObj->next		=   NULL;
mem.c:    pObj->extra_descr	=   NULL;
mem.c:    pObj->affected	=   NULL;
mem.c:    pObj->area		=   NULL;
mem.c:    pObj->name		=   str_dup( "no name" );
mem.c:    pObj->short_descr	=   str_dup( "(no short description)" );
mem.c:    pObj->description	=   str_dup( "(no description)" );
mem.c:    pObj->vnum		=   0;
mem.c:    pObj->item_type	=   ITEM_TRASH;
mem.c:    pObj->extra_flags	=   0;
mem.c:    pObj->wear_flags	=   0;
mem.c:    pObj->max_level	=   MAX_LEVEL;
mem.c:    pObj->count		=   0;
mem.c:    pObj->weight	=   0;
mem.c:    pObj->cost		=   0;
mem.c:    pObj->level		=   1;
mem.c:    pObj->vrace		= NULL;
mem.c:    pObj->material		= NULL;
mem.c:    pObj->hp		= NULL;
mem.c:	pObj->value[value]  =	0;
mem.c:    free_string( pObj->name );
mem.c:    free_string( pObj->short_descr );
mem.c:    free_string( pObj->description );
mem.c:    for ( pAf = pObj->affected; pAf; pAf = pAf->next )
mem.c:    for ( pExtra = pObj->extra_descr; pExtra; pExtra = pExtra->next )
mem.c:    pObj->next		    = obj_index_free;
mem.c:    q->name = NULL;
mem.c:    q->next = NULL;
mem.c:	qmark_free = pQmark->next_in_list;
mem.c:    pQmark->owner = NULL;
mem.c:    pQmark->prev_in_list = NULL;
mem.c:    pQmark->next_in_list = NULL;
mem.c:    pQmark->prev = NULL;
mem.c:    pQmark->next= NULL;
mem.c:    pQmark->mark_name = NULL;
mem.c:    pQmark->timer = 0;
mem.c:    pQmark->v0 = 0;
mem.c:    pQmark->v1 = 0;
mem.c:    pQmark->v2 = 0;
mem.c:    pQmark->fDeath = TRUE;
mem.c:    pQmark->fSave = FALSE;
mem.c:	mob_index_free	=   mob_index_free->next;
mem.c:	pMob->mod_svs[i] = 0;
mem.c:    pMob->mod_str = 0;
mem.c:    pMob->mod_dex = 0;
mem.c:    pMob->mod_int = 0;
mem.c:    pMob->mod_wis = 0;
mem.c:    pMob->mod_con = 0;
mem.c:    pMob->next		=   NULL;
mem.c:    pMob->spec_fun	=   NULL;
mem.c:    pMob->pShop		=   NULL;
mem.c:    pMob->area		=   NULL;
mem.c:    pMob->player_name	=   str_dup( "no name" );
mem.c:    pMob->short_descr	=   str_dup( "(no short description)" );
mem.c:    pMob->long_descr	=   str_dup( "(no long description)\n\r" );
mem.c:    pMob->description	=   &str_empty[0];
mem.c:    pMob->vnum		=   0;
mem.c:    pMob->count		=   0;
mem.c:    pMob->killed	=   0;
mem.c:    pMob->sex		=   0;
mem.c:    pMob->mod_exp       = 0;
mem.c:    pMob->level		=   0;
mem.c:    pMob->act		=   ACT_IS_NPC;
mem.c:    pMob->affected_by	=   0;
mem.c:    pMob->alignment	=   0;
mem.c:    pMob->mod_hitplus	=   0;
mem.c:    pMob->mod_mana	=   0;
mem.c:    pMob->mod_hitroll	=   0;
mem.c:    pMob->mod_damroll	=   0;
mem.c:    pMob->mod_ac	=   0;
mem.c:    pMob->dodge 	=   0;
mem.c:    pMob->mod_pp	=   0;
mem.c:    pMob->gold		=   0;
mem.c:    pMob->race		=   0;
mem.c:    pMob->class		=   0;
mem.c:    pMob->special	=   0;
mem.c:    pMob->psk		=   NULL;
mem.c:    pMob->jcl		=   NULL;
mem.c:    pMob->mobprogs	=   NULL;
mem.c:    pMob->progtypes	=   0;
mem.c:    pMob->mob_action	=   NULL;
mem.c:    pMob->area		=   NULL;
mem.c:	rcall_out_free = cod->next;
mem.c:	cod->next = NULL;
mem.c:	cod->timer = 0;
mem.c:	cod->next = NULL;
mem.c:	cod->owner = NULL;
mem.c:	cod->cmd = NULL;
mem.c:	cod->timer = 0;
mem.c:	call_out_free = cod->next;
mem.c:	cod->next = NULL;
mem.c:	cod->timer = 0;
mem.c:	cod->next = NULL;
mem.c:	cod->owner = NULL;
mem.c:	cod->cmd = NULL;
mem.c:	cod->timer = 0;
mem.c:    free_string( pMob->player_name );
mem.c:    free_string( pMob->short_descr );
mem.c:    free_string( pMob->long_descr );
mem.c:    free_string( pMob->description );
mem.c:    free_shop( pMob->pShop );
mem.c:    pMob->next		    = mob_index_free;
memory.c:    16, 32, 64, 128, 256, 1024, 2048, 4096, 8192, 16384, 32768, 65536-64
memory.c:    4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072 - 64
memory.c: * Semi-locals.
memory.c:    sMem += (int)MB->memory - (int)&(MB->size);
memory.c:    MB->size = sMem;
memory.c:    MB->valid = TRUE;
memory.c:    return (void*)MB->memory;
memory.c:    MB = (struct mem_block *)(pMem - ((int)MB->memory - (int)&(MB->size)));
memory.c:    sMem = MB->size;
memory.c:    if ( !MB->valid )
memory.c:	//bug( "Free_mem: freed already:%d" ,MB->size);
memory.c:	bugf( "%s", MB->memory );
memory.c:    MB->valid = FALSE;
memory.c:    nAllocPerm -= 1;
memory.c:    sAllocPerm -= sMem;
program.c: *  The MOBprograms have been contributed by N'Atas-ha.	 Any support for   *
program.c: *  such installation can be found in INSTALL.	Enjoy........	 N'Atas-Ha *
program.c:    switch( victim->position )
program.c:	    if( IS_NPC(victim) && IS_SET(victim->act, ACT_MPROG_DEATH )) break;
program.c:	    if ( dam > victim->max_hit / 4 )
program.c:	    if ( victim->hit < victim->max_hit / 4 )
program.c:    if( !ch->in_room ) return;
program.c:    if( !ch->in_room->roomprogs ) {
program.c:    for ( rprg = ch->in_room->roomprogs; rprg ;
program.c:	 rprg = rprg->next )
program.c:	      rprog_type_to_name( rprg->type ),
program.c:	      rprg->arglist,
program.c:	      rprg->comlist );
program.c:    if ( !( target->pIndexData->progtypes ) )
program.c:    for ( oprg = target->pIndexData->objprogs; oprg != NULL;
program.c:	 oprg = oprg->next )
program.c:	      oprog_type_to_name( oprg->type ),
program.c:	      oprg->arglist,
program.c:	      oprg->comlist );
program.c:    if ( !( target->pIndexData->mob_action) )
program.c:	target->name, target->pIndexData->vnum );
program.c:	    target->short_descr,
program.c:	    target->long_descr[0] != '\0' ?
program.c:	    target->long_descr : "(none).\n\r" );
program.c:	target->hit,	     target->max_hit,
program.c:	target->mana,	     target->max_mana,
program.c:	target->move,	     target->max_move );
program.c:	target->level,	     target->class,	   target->alignment,
program.c:	GET_AC( target ),    target->gold,	   target->exp );
program.c:	 mprg = mprg->next_in_list )
program.c:	if( mprg->owner && mprg->owner->pIndexData == target->pIndexData ){
program.c:		    mprg->mode,
program.c:		    mprg->start_time,
program.c:		    mprg->com_list );
program.c:    if ( !( target->pIndexData->progtypes ) )
program.c:	target->name, target->pIndexData->vnum );
program.c:	    target->short_descr,
program.c:	    target->long_descr[0] != '\0' ?
program.c:	    target->long_descr : "(none).\n\r" );
program.c:	target->hit,	     target->max_hit,
program.c:	target->mana,	     target->max_mana,
program.c:	target->move,	     target->max_move );
program.c:	target->level,	     target->class,	   target->alignment,
program.c:	GET_AC( target ),    target->gold,	   target->exp );
program.c:    for ( mprg = target->pIndexData->mobprogs; mprg != NULL;
program.c:	 mprg = mprg->next )
program.c:	      mprog_type_to_name( mprg->type ),
program.c:	      mprg->arglist,
program.c:	      mprg->comlist );
save.c://*---------------------------------------------------------------*
save.c://*---------------------------------------------------------------*
save.c://*---------------------------------------------------------------*
save.c: * Array of containers read for proper re-nesting of objects.
save.c:    ch->hit /= PPL_HP_MULTIPLYER;
save.c:    ch->max_hit /= PPL_HP_MULTIPLYER;
save.c:    ch->hit     *= PPL_HP_MULTIPLYER;
save.c:    ch->max_hit *= PPL_HP_MULTIPLYER;
save.c:    if ( IS_NPC( ch ) || ( ch->level < 2 && ch->class <= BARBARIAN ) )
save.c:    if ( ch->desc && ch->desc->original )
save.c:  ch = ch->desc->original;
save.c:  if ( IS_SET( ch->act, PLR_HORSE ) )
save.c:  else if ( ( phorse = ch->pcdata->horse ) )
save.c:    if ( phorse->in_room != ch->in_room )
save.c:      old = phorse->in_room;
save.c:      char_to_room( phorse, ch->in_room );
save.c:        save_horse_obj( ch->pcdata->horse );
save.c:        save_horse_obj( ch->pcdata->horse );
save.c:    ch->save_time = current_time;
save.c:    sprintf( strsave, "%s%s%s%s", PLAYER_DIR, initial( ch->name ),
save.c:      "/", capitalize( ch->name ) );
save.c:    sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( ch->name ) );
save.c:  sprintf( buf, "Save_char_obj: fopen %s: ", ch->name );
save.c:  if ( ch->carrying )
save.c:      fwrite_obj( ch, ch->carrying, fp, 0 );
save.c:  if ( ch->eqbank )
save.c:    fwrite_bank_obj( ch, ch->eqbank, fp, 0 );
save.c:    fprintf( fp, "Nm          %s~\n", ch->name    );
save.c:    fprintf( fp, "Cname %s~\n", ch->cname   );
save.c:    fprintf( fp, "ShtDsc      %s~\n", ch->short_descr   );
save.c:    fprintf( fp, "LngDsc      %s~\n", ch->long_descr    );
save.c:    fprintf( fp, "Dscr        %s~\n", ch->description   );
save.c:    fprintf( fp, "Prmpt       %s~\n", ch->pcdata->prompt  );
save.c:    fprintf( fp, "CTitle   %s~\n",  ch->pcdata->clantitle );
save.c:    fprintf( fp, "Sx          %d\n",  ch->sex     );
save.c:    fprintf( fp, "Cla         %d\n",  ch->class   );
save.c:    fprintf( fp, "Race        %s~\n", race_table[ ch->race ].name );
save.c:    fprintf( fp, "Lvl         %d\n",  ch->level   );
save.c:    fprintf( fp, "PKWin       %d\n",  ch->pcdata->pkwin);
save.c:    fprintf( fp, "PKLose  %d\n",  ch->pcdata->pklose);
save.c:    fprintf( fp, "Trst        %d\n",  ch->trust   );
save.c:    fprintf( fp, "Security    %d\n",  ch->pcdata->security  );  /* OLC */
save.c:  ch->played + (int) ( current_time - ch->logon )   );
save.c:    fprintf( fp, "Note        %ld\n", (unsigned long)ch->last_note );
save.c:    if ( (ch->in_room && IS_SET( ch->in_room->room_flags, ROOM_SAVE ))
save.c:      || (ch->in_room && !str_cmp( ch->in_room->area->identity, "skarabrae" ))
save.c:        fprintf( fp, "Room        %d\n", ch->in_room->vnum );
save.c:            ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
save.c:        fprintf( fp, "Gold        %d\n",  ch->gold);
save.c:        if( ch->in_room )
save.c:            fprintf( fp, "Room        %d\n", ch->in_room->area->recall );
save.c:            UMAX(1,ch->hit/2),
save.c:            ch->max_hit, UMAX(1,ch->mana/2),
save.c:            ch->max_mana,UMAX(1, ch->move/2), ch->max_move );
save.c:        fprintf( fp, "Gold        %d\n",  ch->gold);
save.c:    fprintf( fp, "Bank        %d\n",  ch->bank    );
save.c:    fprintf( fp, "Exp         %d\n",  ch->exp     );
save.c:    fprintf( fp, "Act         %lld\n",  ch->act     );
save.c:    //REMOVE_BIT(ch->affected_by, AFF_DELAYED_CAST);
save.c:    fprintf( fp, "AffdBy      %lld\n",  ch->affected_by   );
save.c://    fprintf( fp, "AffdBy2     %d\n",  ch->affected_by2  );
save.c:      ch->position == POS_FIGHTING ? POS_STANDING : ch->position );
save.c:    fprintf( fp, "Prac        %d\n",  ch->practice    );
save.c:    fprintf( fp, "SavThr    %d\n" ,ch->saving_throw[0]);
save.c:  fprintf(fp, " %d", ch->saving_throw[i]);
save.c:    fprintf( fp, "Align       %d\n",  ch->alignment   );
save.c:    fprintf( fp, "Hit         %d\n",  ch->hitroll   );
save.c:    fprintf( fp, "Dam         %d\n",  ch->damroll   );
save.c:    fprintf( fp, "Armr        %d\n",  ch->armor   );
save.c:    fprintf( fp, "PPotent     %d\n",  ch->pp      );
save.c:    fprintf( fp, "Mdr       %d\n",  ch->mdr     );
save.c:    fprintf( fp, "Pdr       %d\n",  ch->pdr     );
save.c:    fprintf( fp, "AMdr        %d\n",  ch->amdr      );
save.c:    fprintf( fp, "APdr        %d\n",  ch->apdr      );
save.c:    fprintf( fp, "Wimp        %d\n",  ch->wimpy   );
save.c:    fprintf( fp, "Deaf        %d\n",  ch->deaf    );
save.c:  fprintf( fp, "Vnum        %d\n",  ch->pIndexData->vnum  );
save.c:  fprintf( fp, "Paswd       %s~\n", ch->pcdata->pwd   );
save.c:  fprintf( fp, "Bmfin       %s~\n", ch->pcdata->bamfin  );
save.c:  fprintf( fp, "Bmfout      %s~\n", ch->pcdata->bamfout );
save.c:  fprintf( fp, "Immskll     %s~\n", ch->pcdata->immskll );
save.c:  fprintf( fp, "Ttle        %s~\n", ch->pcdata->title );
save.c:  fprintf( fp, "Rank      %d\n",  ch->pcdata->rank);
save.c:    ch->perm_str,
save.c:    ch->perm_int,
save.c:    ch->perm_wis,
save.c:    ch->perm_dex,
save.c:    ch->perm_con);
save.c:    ch->mod_str, 
save.c:    ch->mod_int, 
save.c:    ch->mod_wis,
save.c:    ch->mod_dex, 
save.c:    ch->mod_con );
save.c:    ch->pcdata->condition[0],
save.c:    ch->pcdata->condition[1],
save.c:    ch->pcdata->condition[2] );
save.c:  fprintf( fp, "Pglen       %d\n",    ch->pcdata->pagelen    );
save.c:  fprintf( fp, "Respect     %d\n",    ch->pcdata->respect    );
save.c:  fprintf( fp, "CLevel     %d\n",     ch->pcdata->clanlevel    );
save.c:  fprintf( fp, "CStat     %d\n",    ch->pcdata->clanstatistics     );
save.c:  fprintf( fp, "CExp     %d\n",     ch->pcdata->clanexp    );
save.c:  fprintf( fp, "Ride     %d\n",     ch->pcdata->ride == 0 ? 0 : 1   );
save.c:  fprintf( fp, "AutoC %d\n",    ch->pcdata->autocombat  );
save.c:  fprintf( fp, "SkExp     %d  %d \n",     ch->pcdata->skexp_used, ch->pcdata->skexp_earned );
save.c:  fprintf( fp, "Dodge %d\n",    ch->dodge);
save.c:  fprintf( fp, "Denied  %ld\n",     (long)ch->pcdata->denied);
save.c:  fprintf( fp, "Freezd  %ld\n",     (long)ch->pcdata->freezed);
save.c:      if ( skill_table[sn].name && ch->pcdata->learned[sn] > 0 )
save.c:        ch->pcdata->learned[sn], skill_table[sn].name );
save.c: //   if ( !ch->pcdata->prime_attr )
save.c://  ch->pcdata->prime_attr = ch->class + 1;
save.c:    if ( !ch->pcdata->snd_attr )
save.c:  ch->pcdata->snd_attr = 0;
save.c:    fprintf( fp, "PS_ATTR %d %d\n", ch->pcdata->prime_attr, ch->pcdata->snd_attr );
save.c:    for ( paf = ch->affected; paf; paf = paf->next )
save.c:  if ( paf->deleted )
save.c:    skill_table[ paf->type ].name,
save.c:    paf->duration,
save.c:    paf->modifier,
save.c:    paf->location,
save.c:    paf->bitvector );
save.c:    if ( ch->qmark )
save.c:      for( qmark = ch->qmark; qmark; qmark = qmark->next )
save.c:        if ( qmark->fSave )
save.c:            qmark->mark_name,
save.c:            qmark->timer,
save.c:            qmark->v0,
save.c:            qmark->v1,
save.c:            qmark->v2,
save.c:            qmark->fDeath );
save.c:    if ( ch->clan )
save.c:      fprintf( fp, "CLAN %s~\n", ch->clan->name );
save.c:    if ( obj->next_content )
save.c:    fwrite_obj( ch, obj->next_content, fp, iNest );
save.c:    if( obj->deleted ) return;
save.c:    if ( !IS_SET(obj->extra_flags, ITEM_PERSONAL)  // personal item is always saveable
save.c:    && (( ch->level < ( obj->level - 5 ) && ch->class < 5 ) || obj->item_type == ITEM_KEY))
save.c:    if ( IS_SET( obj->extra_flags, ITEM_NOSAVE )
save.c:  || IS_SET( obj->extra_flags, ITEM_UNIQUE )){
save.c:    //REMOVE_BIT(obj->extra_flags, ITEM_RECOVER);
save.c:    fprintf( fp, "Name         %s~\n",  obj->name        );
save.c:    fprintf( fp, "ShortDescr   %s~\n",  obj->short_descr       );
save.c:/*    fprintf( fp, "Cname  %s~\n",  obj->cname         );*/
save.c:    fprintf( fp, "Description  %s~\n",  obj->description       );
save.c:    fprintf( fp, "Vnum         %d\n", obj->pIndexData->vnum      );
save.c:    fprintf( fp, "ExtraFlags   %d\n", obj->extra_flags       );
save.c:    fprintf( fp, "WearFlags    %d\n", obj->wear_flags        );
save.c:    fprintf( fp, "WearLoc      %d\n", obj->wear_loc        );
save.c:    fprintf( fp, "ItemType     %d\n", obj->item_type         );
save.c:    fprintf( fp, "Weight       %d\n", obj->weight        );
save.c:    fprintf( fp, "Level        %d\n", obj->level         );
save.c:    fprintf( fp, "Timer        %d\n", obj->timer         );
save.c:    fprintf( fp, "Cost         %d\n", obj->cost        );
save.c:    fprintf( fp, "Class        %d\n", obj->class         );
save.c:    fprintf( fp, "Race         %d\n", obj->race        );
save.c:    fprintf( fp, "Serial    %d\n", (int)obj->serial);
save.c:  obj->value[0], obj->value[1], obj->value[2], obj->value[3]   );
save.c:    switch ( obj->item_type )
save.c:  if ( obj->value[1] > 0 )
save.c:    skill_table[obj->value[1]].name );
save.c:  if ( obj->value[2] > 0 )
save.c:    skill_table[obj->value[2]].name );
save.c:  if ( obj->value[3] > 0 )
save.c:    skill_table[obj->value[3]].name );
save.c:  if ( obj->value[3] > 0 )
save.c:    skill_table[obj->value[3]].name );
save.c:    for ( ed = obj->extra_descr; ed; ed = ed->next )
save.c:    ed->keyword, ed->description );
save.c:    for ( paf = obj->affected; paf; paf = paf->next )
save.c:    paf->type,
save.c:    paf->duration,
save.c:    paf->modifier,
save.c:    paf->location,
save.c:    paf->bitvector );
save.c:    if ( obj->hp ) {
save.c:  OBJ_HP * ohp = obj->hp;
save.c:  for( ; ohp; ohp = ohp->next ) {
save.c:  fprintf( fp, "Hidden %d %s~ %d %d %d\n", ohp->vnum,
save.c:    ohp->hp_name, ohp->percent, 
save.c:    ohp->level, ohp->event );
save.c:    if ( ( obj->extra_value ).used )
save.c:                ( obj->extra_value ).v[0],
save.c:                ( obj->extra_value ).v[1],
save.c:                ( obj->extra_value ).t[0],
save.c:                ( obj->extra_value ).t[1] );
save.c:    if ( obj->contains )
save.c:  fwrite_obj( ch, obj->contains, fp, iNest + 1 );
save.c:    if ( obj->next_content )
save.c:  fwrite_newbank_obj( ch, obj->next_content, fp, iNest );
save.c:    //REMOVE_BIT(obj->extra_flags, ITEM_RECOVER);
save.c:    fprintf( fp, "Name         %s~\n",  obj->name        );
save.c:    fprintf( fp, "ShortDescr   %s~\n",  obj->short_descr       );
save.c:/*    fprintf( fp, "Cname  %s~\n",  obj->cname         );*/
save.c:    fprintf( fp, "Description  %s~\n",  obj->description       );
save.c:    fprintf( fp, "Vnum         %d\n", obj->pIndexData->vnum      );
save.c:    fprintf( fp, "ExtraFlags   %d\n", obj->extra_flags       );
save.c:    fprintf( fp, "WearFlags    %d\n", obj->wear_flags        );
save.c:    fprintf( fp, "WearLoc      %d\n", obj->wear_loc        );
save.c:    fprintf( fp, "ItemType     %d\n", obj->item_type         );
save.c:    fprintf( fp, "Weight       %d\n", obj->weight        );
save.c:    fprintf( fp, "Level        %d\n", obj->level         );
save.c:    fprintf( fp, "Timer        %d\n", obj->timer         );
save.c:    fprintf( fp, "Cost         %d\n", obj->cost        );
save.c:    fprintf( fp, "Class        %d\n", obj->class         );
save.c:    fprintf( fp, "Race         %d\n", obj->race        );
save.c:    fprintf( fp, "Serial    %d\n", (int)obj->serial);
save.c:  obj->value[0], obj->value[1], obj->value[2], obj->value[3]   );
save.c:    fprintf( fp, "Recall    %d\n", obj->value[4]);
save.c:    switch ( obj->item_type )
save.c:  if ( obj->value[1] > 0 )
save.c:    skill_table[obj->value[1]].name );
save.c:  if ( obj->value[2] > 0 )
save.c:    skill_table[obj->value[2]].name );
save.c:  if ( obj->value[3] > 0 )
save.c:    skill_table[obj->value[3]].name );
save.c:  if ( obj->value[3] > 0 )
save.c:    skill_table[obj->value[3]].name );
save.c:    for ( ed = obj->extra_descr; ed; ed = ed->next )
save.c:    ed->keyword, ed->description );
save.c:    for ( paf = obj->affected; paf; paf = paf->next )
save.c:    paf->type,
save.c:    paf->duration,
save.c:    paf->modifier,
save.c:    paf->location,
save.c:    paf->bitvector );
save.c:    if ( obj->hp ){
save.c:  for( ohp = obj->hp; ohp; ohp = ohp->next ) {
save.c:  fprintf( fp, "Hidden %d %s~ %d %d %d\n", ohp->vnum,
save.c:    ohp->hp_name, ohp->percent, 
save.c:    ohp->level, ohp->event );
save.c:    if ( ( obj->extra_value ).used )
save.c:                ( obj->extra_value ).v[0],
save.c:                ( obj->extra_value ).v[1],
save.c:                ( obj->extra_value ).t[0],
save.c:                ( obj->extra_value ).t[1] );
save.c:    if ( obj->contains )
save.c:  fwrite_newbank_obj( ch, obj->contains, fp, iNest + 1 );
save.c:    if ( obj->next_content )
save.c:  fwrite_bank_obj( ch, obj->next_content, fp, iNest );
save.c:    //REMOVE_BIT(obj->extra_flags, ITEM_RECOVER);
save.c:    fprintf( fp, "Name         %s~\n",  obj->name        );
save.c:    fprintf( fp, "ShortDescr   %s~\n",  obj->short_descr       );
save.c:/*    fprintf( fp, "Cname  %s~\n",  obj->cname         );*/
save.c:    fprintf( fp, "Description  %s~\n",  obj->description       );
save.c:    fprintf( fp, "Vnum         %d\n", obj->pIndexData->vnum      );
save.c:    fprintf( fp, "ExtraFlags   %d\n", obj->extra_flags       );
save.c:    fprintf( fp, "WearFlags    %d\n", obj->wear_flags        );
save.c:    fprintf( fp, "WearLoc      %d\n", obj->wear_loc        );
save.c:    fprintf( fp, "ItemType     %d\n", obj->item_type         );
save.c:    fprintf( fp, "Weight       %d\n", obj->weight        );
save.c:    fprintf( fp, "Level        %d\n", obj->level         );
save.c:    fprintf( fp, "Timer        %d\n", obj->timer         );
save.c:    fprintf( fp, "Cost         %d\n", obj->cost        );
save.c:    fprintf( fp, "Class        %d\n", obj->class         );
save.c:    fprintf( fp, "Race         %d\n", obj->race        );
save.c:    fprintf( fp, "Serial    %d\n", (int)obj->serial);
save.c:  obj->value[0], obj->value[1], obj->value[2], obj->value[3]   );
save.c:    switch ( obj->item_type )
save.c:  if ( obj->value[1] > 0 )
save.c:    skill_table[obj->value[1]].name );
save.c:  if ( obj->value[2] > 0 )
save.c:    skill_table[obj->value[2]].name );
save.c:  if ( obj->value[3] > 0 )
save.c:    skill_table[obj->value[3]].name );
save.c:  if ( obj->value[3] > 0 )
save.c:    skill_table[obj->value[3]].name );
save.c:    for ( ed = obj->extra_descr; ed; ed = ed->next )
save.c:    ed->keyword, ed->description );
save.c:    for ( paf = obj->affected; paf; paf = paf->next )
save.c:    paf->type,
save.c:    paf->duration,
save.c:    paf->modifier,
save.c:    paf->location,
save.c:    paf->bitvector );
save.c:    if ( obj->hp ){
save.c:  for( ohp = obj->hp; ohp; ohp = ohp->next ) {
save.c:  fprintf( fp, "Hidden %d %s~ %d %d %d\n", ohp->vnum,
save.c:    ohp->hp_name, ohp->percent, 
save.c:    ohp->level, ohp->event );
save.c:    if ( ( obj->extra_value ).used )
save.c:                ( obj->extra_value ).v[0],
save.c:                ( obj->extra_value ).v[1],
save.c:                ( obj->extra_value ).t[0],
save.c:                ( obj->extra_value ).t[1] );
save.c:    if ( obj->contains )
save.c:  fwrite_obj( ch, obj->contains, fp, iNest + 1 );
save.c:  d->character      = ch;
save.c:  ch->desc        = d;
save.c:  ch->name        = str_dup( name );
save.c:  sprintf(pipe_buf, "|N %d %s \n", (int)d, ch->name);
save.c:  ch->pcdata->prompt      = str_dup( daPrompt );
save.c:  ch->last_note     = 0;
save.c:  ch->act       = PLR_BLANK
save.c:  ch->pcdata->pwd     = str_dup( "" );
save.c:  ch->pcdata->bamfin      = str_dup( "" );
save.c:  ch->pcdata->bamfout     = str_dup( "" );
save.c:  ch->pcdata->immskll     = str_dup( "" );
save.c:  ch->pcdata->title     = str_dup( "" );
save.c:  ch->perm_str    = 13;
save.c:  ch->perm_int    = 13; 
save.c:  ch->perm_wis    = 13;
save.c:  ch->perm_dex    = 13;
save.c:  ch->perm_con    = 13;
save.c:  ch->pcdata->condition[COND_THIRST]  = 48;
save.c:  ch->pcdata->condition[COND_FULL]  = 48;
save.c:  ch->pcdata->pagelen     = 20;
save.c:  ch->pcdata->security    = 0;  /* OLC */
save.c:  ch->pcdata->switched    = FALSE;
save.c:  ch->pcdata->horse     = NULL;
save.c:  ch->pcdata->ride      = 0;
save.c:  ch->pcdata->version     = 0;
save.c:  ch->dodge       = 0;
save.c:  // ch->pcdata->skexp_earned_max = 0;//add by jacquex
save.c:  ch->pcdata->ba        = NULL;
save.c:  /* decompress if .gz file exists - Thx Alander */
save.c:  sprintf( strsave, "%s%s%s%s%s", PLAYER_DIR, initial( ch->name ),
save.c:    sprintf( buf, "gzip -dfq %s", strsave );
save.c:  sprintf( strsave, "%s%s%s%s", PLAYER_DIR, initial( ch->name ),
save.c:           * what we are missing are MANDATORY fields.  -Kahn
save.c:          SET_BIT( ch->act, PLR_DENY );
save.c:  char  *def_sdesc  /*[]*/ = ch->name;/*"Your short description was corrupted.";*/
save.c:  char  *def_name   = ch->name;
save.c:  char  *def_cname    = ch->name;
save.c:      { "Ver",      FALSE,  LATEST_VERSION, { &ch->pcdata->version,       NULL } },
save.c:      { "Nm",     TRUE,  (int) &def_name, { &ch->name,        NULL } },
save.c:      { "Cname",  TRUE,  (int) &def_cname,  { &ch->cname,       NULL } },
save.c:      { "ShtDsc", TRUE,  (int) def_sdesc, { &ch->short_descr,   NULL } },
save.c:      { "LngDsc", TRUE,  (int) &def_ldesc,  { &ch->long_descr,    NULL } },
save.c:      { "Dscr",   TRUE,  (int) &def_desc, { &ch->description,   NULL } },
save.c:      { "Prmpt",  TRUE,  (int) &def_prompt, { &ch->pcdata->prompt,NULL } },
save.c:      { "CTitle",   TRUE,  (int) &def_clantitle,  { &ch->pcdata->clantitle,   NULL } },
save.c:      { "Sx",   FALSE, SEX_MALE,    { &ch->sex,       NULL } },
save.c:      { "Security",FALSE,0,     { &ch->pcdata->security,NULL } },
save.c:      { "Cla",    FALSE, MAND,      { &ch->class,       NULL } },
save.c:      { "Lvl",    FALSE, MAND,      { &ch->level,       NULL } },
save.c:      { "PKWin",    FALSE, 0,     { &ch->pcdata->pkwin,       NULL } },
save.c:      { "PKLose",   FALSE, 0,     { &ch->pcdata->pklose,        NULL } },
save.c:      { "Trst",   FALSE, 0,     { &ch->trust,       NULL } },
save.c:      { "Playd",  FALSE, 0,     { &ch->played,        NULL } },
save.c:      { "Note",   FALSE, 0,     { &ch->last_note,     NULL } },
save.c:      { "HpMnMv", FALSE, MAND,      { &ch->hit,     
save.c:              &ch->max_hit,           
save.c:              &ch->mana,           
save.c:              &ch->max_mana,           
save.c:              &ch->move,           
save.c:              &ch->max_move,      NULL } },         
save.c:      { "Gold",   FALSE, 0,     { &ch->gold,        NULL } },
save.c:      { "Bank",   FALSE, 0,     { &ch->bank,        NULL } },
save.c:      { "Exp",    FALSE, MAND,      { &ch->exp,       NULL } },
save.c:      { "Act",    FALSE, 3344558LL,     { &ch->act,         NULL } },
save.c:      { "AffdBy", FALSE, 0LL,     { &ch->affected_by,   NULL } },
save.c:      { "AffdBy2",FALSE, 0,     { &ch->affected_by2,  NULL } },
save.c:      { "Pos",    FALSE, POS_STANDING,    { &ch->position,      NULL } },
save.c:      { "Prac",   FALSE, MAND,      { &ch->practice,      NULL } },
save.c:      { "SavThr", FALSE, 0/*MAND*/,     { &(ch->saving_throw[0]),
save.c:              &(ch->saving_throw[1]),           
save.c:              &(ch->saving_throw[2]),           
save.c:              &(ch->saving_throw[3]),           
save.c:              &(ch->saving_throw[4]),           
save.c:              &(ch->saving_throw[5]),           
save.c:              &(ch->saving_throw[6]),           
save.c:              &(ch->saving_throw[7]),           
save.c:              &(ch->saving_throw[8]),           
save.c:              &(ch->saving_throw[9]),           
save.c:              &(ch->saving_throw[10]),           
save.c:              &(ch->saving_throw[11]),           
save.c:              &(ch->saving_throw[12]),           
save.c:              &(ch->saving_throw[13]),           
save.c:              &(ch->saving_throw[14]),           
save.c:              &(ch->saving_throw[15]),           
save.c:              &(ch->saving_throw[16]),           
save.c:      { "Align",  FALSE, 0,     { &ch->alignment,     NULL } },
save.c:      { "Hit",    FALSE, MAND,      { &ch->hitroll,         NULL } },
save.c:      { "Dam",    FALSE, MAND,      { &ch->damroll,         NULL } },
save.c:      { "Armr",   FALSE, MAND,      { &ch->armor,       NULL } },
save.c:      { "PPotent", FALSE, 0,      { &ch->pp,        NULL } },
save.c:      { "Mdr", FALSE, 0,      { &ch->mdr,       NULL } },
save.c:      { "Pdr", FALSE, 0,      { &ch->pdr,       NULL } },
save.c:      { "AMdr", FALSE, 0,     { &ch->amdr,        NULL } },
save.c:      { "APdr", FALSE, 0,     { &ch->apdr,        NULL } },
save.c:      { "Wimp",   FALSE, 10,      { &ch->wimpy,       NULL } },
save.c:      { "Deaf",   FALSE, 0,     { &ch->deaf,        NULL } },
save.c:      { "Paswd",  TRUE,  MAND,      { &ch->pcdata->pwd,   NULL } },
save.c:      { "Bmfin",  TRUE,  DEFLT,     { &ch->pcdata->bamfin,
save.c:      { "Bmfout", TRUE,  DEFLT,     { &ch->pcdata->bamfout,
save.c:      { "Immskll",TRUE,  DEFLT,     { &ch->pcdata->immskll,
save.c:      { "Ttle",   TRUE,  (int) &def_title,  { &ch->pcdata->title, NULL } },
save.c:      { "Rank",   FALSE,   0, { &ch->pcdata->rank, NULL } },
save.c:      { "AtrPrm", FALSE, MAND,      { &ch->perm_str,
save.c:              &ch->perm_int,           
save.c:              &ch->perm_wis,           
save.c:              &ch->perm_dex,           
save.c:              &ch->perm_con,           
save.c:      { "AtrMd",  FALSE, MAND,      { &ch->mod_str, 
save.c:              &ch->mod_int,           
save.c:              &ch->mod_wis,           
save.c:              &ch->mod_dex,           
save.c:              &ch->mod_con,           
save.c:      { "Cond",   FALSE, DEFLT,     { &ch->pcdata->condition [0],
save.c:              &ch->pcdata->condition [1],           
save.c:              &ch->pcdata->condition [2],           
save.c:      { "Pglen",  FALSE, 20,      { &ch->pcdata->pagelen,
save.c:      { "Respect",FALSE,  0,      { &ch->pcdata->respect,
save.c:      { "CLevel",FALSE,  0,     { &ch->pcdata->clanlevel,
save.c:      { "CStat",FALSE,  0,      { &ch->pcdata->clanstatistics,
save.c:      { "CExp",FALSE,  0,     { &ch->pcdata->clanexp,
save.c:      { "Ride",FALSE,  0,     { &ch->pcdata->ride,  
save.c:      { "SkExp",FALSE,  0,      { &ch->pcdata->skexp_used,
save.c:                                                  &ch->pcdata->skexp_earned,
save.c: //                                                 &ch->pcdata->skexp_earned_max,
save.c:      { "AutoC",FALSE,  0,      { &ch->pcdata->autocombat,
save.c:      { "Dodge",      FALSE,  0,  { &ch->dodge,       NULL } },
save.c:      { "Denied",     FALSE,  0,  { &ch->pcdata->denied,        NULL } },
save.c:      { "Freezd",     FALSE,  0,  { &ch->pcdata->freezed,       NULL } },
save.c:                            ch->affected_by = tmpi;
save.c:                            ch->act = tmpi;
save.c:           ch->in_room = get_room_index( nRoomNum );
save.c:           if( !ch->in_room )
save.c:               ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:           if( ch->pcdata->version < 13 && ch->class == KNIGHT)
save.c:               ch->in_room = get_room_index(11000);
save.c:           if( ch->pcdata->version < 15)
save.c:               ch->in_room = get_room_index(11000);
save.c:           if( ch->pcdata->version < 17 && (ch->class == KNIGHT || ch->class == WARLORD || ch->class == MARTIALMAN))
save.c:               ch->in_room = get_room_index(11000);
save.c:           if( ch->pcdata->version < 19 && ch->class == MARTIALMAN)
save.c:               ch->in_room = get_room_index(11000);
save.c:           if( ch->pcdata->version < 21 && ch->class == WIZARD)
save.c:               ch->in_room = get_room_index(11000);
save.c:           if( ch->pcdata->version < 23 && ch->class == KNIGHT)
save.c:               ch->in_room = get_room_index(11000);
save.c:                   ch ->race = 5;
save.c:                   ch->race = i;
save.c:           ch->race = URANGE( 0, ch->race, MAX_RACE);
save.c:           if( ch->pcdata->version < 1 ) 
save.c:                    ch->saving_throw[i] = fread_number(fp, &status);
save.c:               ch->saving_throw[16] = 0;
save.c:                    ch->saving_throw[i] = fread_number(fp, &status);
save.c:           if( ch->pcdata->version < 2 ) 
save.c:           if( ch->pcdata->version < 9 )
save.c:           if( ch->pcdata->version < 10 && ch->class == SWORDSMAN )
save.c:           if( ch->pcdata->version < 11 && ch->class == SORCERER )
save.c:           if( ch->pcdata->version < 12 && (ch->class == SHAMAN || ch->class == LORD))
save.c:           if( ch->pcdata->version < 13 && ch->class == KNIGHT)
save.c:           if( ch->pcdata->version < 16 && ch->class == WIZARD){
save.c:           if( ch->pcdata->version < 17 && (ch->class == KNIGHT || ch->class == WARLORD || ch->class == MARTIALMAN)){
save.c:           if( ch->pcdata->version < 21 && ch->class == WIZARD){
save.c:               ch->pcdata->learned[sn] = i;
save.c:            ch->pcdata->prime_attr = fread_number( fp, &status );
save.c:            ch->pcdata->snd_attr = fread_number( fp, &status );
save.c:            ch->pcdata->prime_attr = URANGE( 0, ch->pcdata->prime_attr, 5);
save.c:            ch->pcdata->snd_attr = URANGE( 0, ch->pcdata->snd_attr, 5);
save.c:            if( ch->pcdata->version < 20 && (ch->class == NINJA || ch->class == WARLORD || ch->class == KNIGHT)
save.c:                && ch->pcdata->prime_attr == APPLY_CON)
save.c:                ch->in_room = get_room_index(11000);
save.c:           if( ch->pcdata->version < 22 && ch->pcdata->prime_attr == APPLY_INT){
save.c:                   ch->in_room = get_room_index(11000);
save.c:           paf->type = affect_lookup( p=fread_string( fp, &status ) );
save.c:           paf->duration   = fread_number( fp, &status );
save.c:           paf->modifier   = fread_number( fp, &status );
save.c:           paf->location   = fread_number( fp, &status );
save.c:           paf->bitvector    = fread_number( fp, &status );
save.c:           paf->deleted    = FALSE;
save.c:           paf->next     = ch->affected;
save.c:           ch->affected    = paf;
save.c:               /*qmark->timer    = */fread_number( fp, &status );
save.c:               /*qmark->v0     = */fread_number( fp, &status );
save.c:               /*qmark->v1     =*/ fread_number( fp, &status );
save.c:               /*qmark->v2     =*/ fread_number( fp, &status );
save.c:               /*qmark->fDeath     = */fread_number( fp, &status );
save.c:               sprintf( buf, "fread_char: %s has duplicated qmark '%s' in pfile.", ch->name, p);
save.c:               qmark->timer    = fread_number( fp, &status );
save.c:               qmark->v0     = fread_number( fp, &status );
save.c:               qmark->v1     = fread_number( fp, &status );
save.c:               qmark->v2     = fread_number( fp, &status );
save.c:               qmark->fDeath     = fread_number( fp, &status );
save.c:               qmark->fSave    = TRUE;
save.c:               qmark->owner    = ch;
save.c:               qmark->next   = ch->qmark;
save.c:               if( ch->pcdata->version < 5 ) 
save.c:                       qmark->v0 = 0;
save.c:                       qmark->v1 = 0;
save.c:                       qmark->v2 = 0;
save.c:               if( ch->qmark )
save.c:                   ch->qmark->prev = qmark;
save.c:               ch->qmark   = qmark;
save.c:               if( qmark->timer > 0 )
save.c:                   qmark->next_in_list = qmark_list;
save.c:                       qmark_list->prev_in_list = qmark;
save.c:           for( cn = clan_list; cn; cn = cn->next )
save.c:                if( !str_cmp( p, cn->name ) )
save.c:                  ch->clan = cn;
save.c:               if(!ch->desc)
save.c:                   bug( ch->name, 0 );
save.c:                   write_to_buffer( ch->desc, "±zªºÀ°¬£¤w¸g¤£¦s¦b¤F¡C\n\r", 0 );
save.c:                   //ch->pcdata->respect --;
save.c:                   ch->pcdata->clantitle = NULL;
save.c:                   ch->pcdata->clanlevel = 0;
save.c:                   ch->pcdata->clanstatistics = 0;
save.c:  ch->protector = NULL;
save.c:  ch->protecting = NULL;
save.c:  ch->next_in_protect = NULL;
save.c:  ch->neweqbank = NULL;
save.c:  ch->act |= PLR_COMBINE;
save.c:  //skill expÂk¹s ver 2-> 3
save.c:  if( ch->pcdata->version < 5 ) 
save.c:      ch->pcdata->skexp_earned = 0;
save.c:      ch->pcdata->skexp_used = 0;
save.c:      //ch->pcdata->skexp_earned_max = 0;
save.c:  if( ch->pcdata->version < 9 )
save.c:      ch->pcdata->skexp_used = 0;
save.c:  if( ch->pcdata->version < 10 && ch->class == SWORDSMAN )
save.c:      ch->pcdata->skexp_used = 0;
save.c:  if( ch->pcdata->version < 11 && ch->class == SORCERER )
save.c:      ch->pcdata->skexp_used = 0;
save.c:  if( ch->pcdata->version < 12 && (ch->class == SHAMAN || ch->class == LORD))
save.c:      ch->pcdata->skexp_used = 0;
save.c:  if( ch->pcdata->version < 13 && ch->class == KNIGHT)
save.c:      ch->pcdata->skexp_used = 0;
save.c:  if( ch->pcdata->version < 16 && ch->class == WIZARD)
save.c:      ch->pcdata->skexp_used = 0;
save.c:  if( ch->pcdata->version < 17 && (ch->class == KNIGHT || ch->class == WARLORD || ch->class == MARTIALMAN))
save.c:      ch->pcdata->skexp_used = 0;
save.c:  if( ch->pcdata->version < 18)
save.c:      ch->max_mana += ch->level * 10;
save.c:  if( ch->pcdata->version < 21 && ch->class == WIZARD)
save.c:      ch->pcdata->skexp_used = 0;
save.c:  if( ch->pcdata->version < 14){
save.c:      for ( paf = ch->affected; paf; paf = paf->next ){
save.c:          if ( paf->deleted ) continue;
save.c:          if ( paf->type == gsn_polymorph ){
save.c:              //  Check for natural_fly and inborn ability skill -- added by keelar
save.c:              REMOVE_BIT( ch->affected_by, paf->bitvector );
save.c:              int  mod         = -paf->modifier;
save.c:              int  nNewRace    = ch->race + mod;
save.c:                  nNewRace -= 64;
save.c:              bOrgFlyStat = IS_SET(race_table[ ch->race ].race_abilities, RACE_FLY);
save.c:                  ch->dodge += nRaceSklv * 2 + (nRaceSklv * nRaceSklv) / 2;
save.c:                  ch->dodge -= race_table[ch->race].size * 5;
save.c:                  ch->dodge -= nRaceSklv * 2 + (nRaceSklv * nRaceSklv) / 2;
save.c:                  ch->dodge += race_table[nNewRace].size * 5;
save.c:              ch->race  = nNewRace;
save.c:              paf->deleted = TRUE;
save.c:  REMOVE_BIT(ch->affected_by, AFF_BATTLE);
save.c:  // if ( ch->pcdata->skexp_earned_max == 0)
save.c:  //      ch->pcdata->skexp_earned_max = ch->pcdata->skexp_earned;
save.c:  if( strlen(ch->description) > 500 )
save.c:      strncpy(debuf, ch->description, 500);
save.c:      free_string(ch->description);
save.c:      ch->description = str_dup(debuf);
save.c:  if( ch->pcdata->title && isalnum ( *ch->pcdata->title ) )
save.c:      sprintf( buf, "%s", ch->pcdata->title );
save.c:      free_string( ch->pcdata->title );
save.c:      ch->pcdata->title = str_dup( buf );
save.c:  { "Level",   FALSE, ch->level,    { &obj.level,       NULL } },
save.c:     //if( obj.extra_flags != obj.pIndexData->extra_flags )
save.c:       //  obj.extra_flags |= obj.pIndexData->extra_flags;
save.c:        // sprintf(ebuf,"%s has one %d.", ch->name, obj.pIndexData->vnum);
save.c:      obj.vrace = obj.pIndexData->vrace;
save.c:      obj.material = obj.pIndexData->material;
save.c:      paf->type     = fread_number( fp, &status );
save.c:      paf->duration   = fread_number( fp, &status );
save.c:      paf->modifier   = fread_number( fp, &status );
save.c:      paf->location   = fread_number( fp, &status );
save.c:      paf->bitvector  = fread_number( fp, &status );
save.c:      paf->next = obj.affected;
save.c:    for( hp = obj_hp_list; hp; hp = hp->next )
save.c:      if ( hp->vnum == vnum_tmp )
save.c:          hp->vnum  = vnum_tmp;
save.c:          hp->hp_name = fread_string( fp, &stat );
save.c:          hp->percent = fread_number( fp, &stat );
save.c:          hp->level = fread_number( fp, &stat );
save.c:          hp->event = fread_number( fp, &stat );
save.c:          //hp->next  = obj_hp_list;
save.c:      hp->next  = obj.hp;
save.c:      ed->keyword     = tmp_ptr;
save.c:      ed->description = p;
save.c:      ed->next      = obj.extra_descr;
save.c:    new_obj->next = object_list;
save.c:    new_obj->pIndexData->count++;
save.c:  obj_to_obj( new_obj, rgObjNest[iNest-1] );
save.c:     //if( obj.extra_flags != obj.pIndexData->extra_flags )
save.c:         //obj.extra_flags |= obj.pIndexData->extra_flags;
save.c:        // sprintf(ebuf,"%s has one %d.", ch->name, obj.pIndexData->vnum);
save.c:      obj.vrace = obj.pIndexData->vrace;
save.c:      obj.material = obj.pIndexData->material;
save.c:      paf->type     = fread_number( fp, &status );
save.c:      paf->duration   = fread_number( fp, &status );
save.c:      paf->modifier   = fread_number( fp, &status );
save.c:      paf->location   = fread_number( fp, &status );
save.c:      paf->bitvector  = fread_number( fp, &status );
save.c:      paf->next = obj.affected;
save.c:    for( hp = obj_hp_list; hp; hp = hp->next )
save.c:      if ( hp->vnum == vnum_tmp )
save.c:          hp->vnum  = vnum_tmp;
save.c:          hp->hp_name = fread_string( fp, &stat );
save.c:          hp->percent = fread_number( fp, &stat );
save.c:          hp->level = fread_number( fp, &stat );
save.c:          hp->event = fread_number( fp, &stat );
save.c:          //hp->next  = obj_hp_list;
save.c:      hp->next  = obj.hp;
save.c:      ed->keyword     = tmp_ptr;
save.c:      ed->description = p;
save.c:      ed->next      = obj.extra_descr;
save.c:    new_obj->next = object_list;
save.c:    new_obj->pIndexData->count++;
save.c:  new_obj->next_content = ch->objs;
save.c:  ch->objs = new_obj;
save.c:  //obj_to_obj( new_obj, rgObjNest[iNest-1] );
save.c:  new_obj->next_content = rgObjNest[iNest-1]->contains;
save.c:  new_obj->in_obj = rgObjNest[iNest-1];
save.c:  new_obj->in_room = NULL;
save.c:  new_obj->carried_by = NULL;
save.c:  rgObjNest[iNest-1]->contains = new_obj;
save.c:  { "Level",   FALSE, ch->level,    { &obj.level,       NULL } },
save.c:     if( obj.extra_flags != obj.pIndexData->extra_flags )
save.c:         //obj.extra_flags |= obj.pIndexData->extra_flags;
save.c:        // sprintf(ebuf,"%s has one %d.", ch->name, obj.pIndexData->vnum);
save.c:      obj.vrace = obj.pIndexData->vrace;
save.c:      obj.material = obj.pIndexData->material;
save.c:      paf->type     = fread_number( fp, &status );
save.c:      paf->duration   = fread_number( fp, &status );
save.c:      paf->modifier   = fread_number( fp, &status );
save.c:      paf->location   = fread_number( fp, &status );
save.c:      paf->bitvector  = fread_number( fp, &status );
save.c:      paf->next = obj.affected;
save.c:    for( hp = obj_hp_list; hp; hp = hp->next )
save.c:      if ( hp->vnum == vnum_tmp )
save.c:          hp->vnum  = vnum_tmp;
save.c:          hp->hp_name = fread_string( fp, &stat );
save.c:          hp->percent = fread_number( fp, &stat );
save.c:          hp->level = fread_number( fp, &stat );
save.c:          hp->event = fread_number( fp, &stat );
save.c:          //hp->next  = obj_hp_list;
save.c:      hp->next  = obj.hp;
save.c:      ed->keyword     = tmp_ptr;
save.c:      ed->description = p;
save.c:      ed->next      = obj.extra_descr;
save.c:    new_obj->next = object_list;
save.c://    new_obj->pIndexData->count++;
save.c:    new_obj->next_content = ch->eqbank;
save.c:    ch->eqbank      = new_obj;
save.c:    if ( ch->desc && ch->desc->original )
save.c:  ch = ch->desc->original;
save.c:    ch->save_time = current_time;
save.c:    sprintf( strsave, "%s%s%s%s", HORSE_BACKUP_DIR, initial( ch->pcdata->horse->name ),
save.c:      "/", capitalize( ch->pcdata->horse->name ) );
save.c:  sprintf( buf, "Save_char_obj: fopen %s: ", ch->name );
save.c:  if ( ch->carrying )
save.c:      fwrite_obj( ch, ch->carrying, fp, 0 );
save.c:    if( !ch->desc ) return;
save.c:  if ( IS_SET( ch->act, PLR_HORSE ) )
save.c:    if ( ch->pcdata->horse )
save.c:      ch->pcdata->horse->desc = ch->desc;
save.c:      ch = ch->pcdata->horse;
save.c:      ch->pcdata->horse->desc = NULL;
save.c:    if ( ch->level < 5 )
save.c:      ch = ch->pcdata->horse;
save.c:    if ( ch->desc && ch->desc->original )
save.c:  ch = ch->desc->original;
save.c:    ch->save_time = current_time;
save.c:    sprintf( strsave, "%s%s%s%s", BACKUP_DIR, initial( ch->name ),
save.c:      "/", capitalize( ch->name ) );
save.c:  sprintf( buf, "Save_char_obj: fopen %s: ", ch->name );
save.c:  if ( ch->carrying )
save.c:      fwrite_obj( ch, ch->carrying, fp, 0 );
save.c:  if ( ch->eqbank )
save.c:    fwrite_bank_obj( ch, ch->eqbank, fp, 0 );
save.c:    if ( ch->pcdata->horse )
save.c:      do_horse_backup( ch->pcdata->horse, "" );
save.c:    ch->pcdata->horse->desc = ch->desc;
save.c:    ch = ch->pcdata->horse;
save.c:    ch->pcdata->horse->desc = NULL;
save.c://    ch->desc        = d;
save.c:    ch->name        = str_dup( name );
save.c://    sprintf(pipe_buf, "|N %d %s \n", (int)d, ch->name);
save.c:    ch->pcdata->prompt      = str_dup( daPrompt );
save.c:    ch->last_note     = 0;
save.c:    ch->act       = PLR_BLANK
save.c:    ch->pcdata->pwd     = str_dup( "" );
save.c:    ch->pcdata->bamfin      = str_dup( "" );
save.c:    ch->pcdata->bamfout     = str_dup( "" );
save.c:    ch->pcdata->immskll     = str_dup( "" );
save.c:    ch->pcdata->title     = str_dup( "" );
save.c:    ch->perm_str    = 13;
save.c:    ch->perm_int    = 13; 
save.c:    ch->perm_wis    = 13;
save.c:    ch->perm_dex    = 13;
save.c:    ch->perm_con    = 13;
save.c:    ch->pcdata->condition[COND_THIRST]  = 48;
save.c:    ch->pcdata->condition[COND_FULL]  = 48;
save.c:    ch->pcdata->pagelen     = 20;
save.c:    ch->pcdata->security    = 0;  /* OLC */
save.c:  ch->pcdata->ride      = 0;
save.c:    ch->pcdata->switched    = FALSE;
save.c:    ch->pcdata->horse     = d->character;
save.c:  d->character->pcdata->horse = d->original;
save.c:    /* decompress if .gz file exists - Thx Alander */
save.c:    sprintf( strsave, "%s%s%s%s%s", HORSE_DIR, initial( ch->name ),
save.c:  sprintf( buf, "gzip -dfq %s", strsave );
save.c:    sprintf( strsave, "%s%s%s%s", HORSE_DIR, initial( ch->name ),
save.c:        SET_BIT( ch->act, PLR_DENY );
save.c://    sprintf( buf, "%s horse", ch->name );
save.c://    free_string( ch->name );
save.c://    ch->name = str_dup( buf );
save.c:    ch->pcdata->ride      = 0;
save.c:    if ( IS_NPC( ch ) || ( ch->level < 2 && ch->class <= BARBARIAN ) )
save.c:    if( !ch->pcdata->horse ) return;
save.c:    if ( ch->desc && ch->desc->original )
save.c:  ch = ch->desc->original;
save.c:    ch->save_time = current_time;
save.c:    sprintf( strsave, "%s%s%s%s", HORSE_DIR, initial( ch->pcdata->horse->name ),
save.c:      "/", capitalize( ch->pcdata->horse->name ) );
save.c:    sprintf( strsave, "%s%s", HORSE_DIR, capitalize( ch->pcdata->horse->name ) );
save.c:  sprintf( buf, "Save_char_obj: fopen %s: ", ch->name );
save.c:  //ch->in_room = ch->master->in_room;
save.c:  if ( ch->carrying )
save.c:      fwrite_obj( ch, ch->carrying, fp, 0 );
save.c:  if ( ch->eqbank )
save.c:    fwrite_bank_obj( ch, ch->eqbank, fp, 0 );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->deleted )
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, NULL );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    if( !IS_AWAKE(ch) || ch->deleted ) return FALSE;
special.c:    if( !(victim = ch->fighting) || victim->deleted || victim->in_room != ch->in_room ) return FALSE;
special.c:    percent = ch->level + 20;
special.c:    sprintf(arg, "'%s'", victim->name);
special.c:    if ( !IS_AWAKE( ch ) || ch->fighting )
special.c:	//|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	//|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    level = UMIN( ch->level, 42 );
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:    if ( victim->level > 10 )
special.c:    if ( !IS_AWAKE( ch ) || ch->fighting )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:    if ( victim->level > 10 )
special.c:	spell_armor( skill_lookup( "armor" ), ch->level, ch, victim );
special.c:	spell_bless( skill_lookup( "bless" ), ch->level, ch, victim );
special.c:			     ch->level, ch, victim );
special.c:			 ch->level, ch, victim );
special.c:			  ch->level, ch, victim );
special.c:	spell_full_refresh( skill_lookup( "full refresh" ), ch->level, ch, victim );
special.c:	spell_combat_mind( skill_lookup( "combat mind" ), ch->level, ch,
special.c:	spell_sanctuary( skill_lookup( "sanctuary" ), ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )){
special.c:	    if( !IS_SET(victim->special, EXPERT) && number_bits(2) == 1 ) break;
special.c:	    else if ( IS_SET(victim->special, EXPERT) && number_bits(1) == 1 ) break;
special.c:		 spell = ((IS_SET(ch->special, EXPERT) ? "whirlwind":"soulsteal"));	   break;
special.c:	case 12: min_level = 42;  spell = ((IS_SET(ch->special, EXPERT) ? "polymorph other":"paralyze"));break;
special.c:	case 13: min_level = 38; spell = ((IS_SET(ch->special, EXPERT) ? "teleport":"2 fireball"));	   break;
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )
special.c:    if ( number_bits( 1 ) == 0 && can_see( ch, ch->fighting) )
special.c:	    victim = ch->fighting;
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )
special.c:    if ( number_bits( 1 ) == 0 && can_see( ch, ch->fighting) )
special.c:	    victim = ch->fighting;
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )
special.c:    if ( number_bits( 1 ) == 0 && can_see( ch, ch->fighting) )
special.c:	    victim = ch->fighting;
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )
special.c:    if ( number_bits( 1 ) == 0 && can_see( ch, ch->fighting) )
special.c:	    victim = ch->fighting;
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )
special.c:	case  7: min_level = 30; spell =((IS_SET(ch->special, EXPERT) ?  "teleport":"paralyze"));	   break;
special.c:	case 10: if ( ch->race == race_lookup( "Vampire" ) )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( !IS_AWAKE( ch ) || ch->fighting )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->deleted )
special.c:	if ( !IS_NPC( victim ) && victim->level >= L_APP )
special.c:	if ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_KILLER ) )
special.c:	if ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_THIEF  ) )
special.c:	if ( IS_NPC( victim ) && victim->level > 9 && 
special.c:			IS_SET( victim->act, ACT_AGGRESSIVE ) )
special.c:    if ( !victim || IS_SET(victim->in_room->room_flags, ROOM_SAFE) )
special.c:	    victim->short_descr, crime );
special.c://		 ch->in_room );
special.c://		 ch->in_room );
special.c:    for ( corpse = ch->in_room->contents; corpse; corpse = corpse_next )
special.c:	corpse_next = corpse->next_content;
special.c:	if ( corpse->deleted )
special.c:	if ( corpse->item_type != ITEM_CORPSE_NPC )
special.c:	for ( obj = corpse->contains; obj; obj = obj_next )
special.c:	    obj_next = obj->next_content;
special.c:	    if ( obj->deleted )
special.c:	    obj_to_room( obj, ch->in_room );
special.c:    if ( !IS_AWAKE( ch ) || ch->fighting )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->deleted )
special.c:	if ( victim->level >= L_APP )
special.c:	if ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_KILLER ) )
special.c:	if ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_THIEF  ) )
special.c:	if ( victim->fighting
special.c:	    && victim->fighting != ch
special.c:	    && IS_GOOD(victim->fighting)
special.c:	    && victim->alignment < victim->fighting->alignment
special.c:	    && victim->alignment < max_evil )
special.c:	    max_evil = victim->alignment;
special.c:		victim->name, crime );
special.c:    if( !ch->in_room ) return FALSE;
special.c:    for ( trash = ch->in_room->contents; trash; trash = trash_next )
special.c:	trash_next = trash->next_content;
special.c:	if ( trash->deleted )
special.c:	if ( !IS_SET( trash->wear_flags, ITEM_TAKE ) )
special.c:	if (   trash->item_type == ITEM_DRINK_CON
special.c:	    || trash->item_type == ITEM_TRASH
special.c:	    || trash->cost < 50 )
special.c:    if ( ch->fighting )
special.c:    if ( !move || ch->position < POS_SLEEPING )
special.c:	move_char( ch, path[pos] - '0' );
special.c:	ch->position = POS_STANDING;
special.c:	ch->position = POS_SLEEPING;
special.c:    if ( ch->position != POS_FIGHTING
special.c:	|| !( victim = ch->fighting )
special.c:	|| number_percent( ) > 2 * ch->level )
special.c:    spell_poison( gsn_poison, ch->level, ch, victim );
special.c:    if ( ch->position != POS_STANDING )
special.c:    for ( victim = ch->in_room->people; victim;
special.c:	 victim = victim->next_in_room )
special.c:	    || victim->level >= LEVEL_IMMORTAL
special.c:	if ( IS_AWAKE( victim ) && victim->level > 5
special.c:	    && number_percent( ) + victim->level - ch->level >= 33 )
special.c:	    gold = victim->gold * number_range( 1, 20 ) / 100;
special.c:	    ch->gold	 += 3 * gold / 4;
special.c:	    victim->gold -= gold;
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:      if ( !ch->in_room )
special.c:      if ( ch->fighting )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	|| IS_SET( race_table[ch->race].race_abilities, RACE_MUTE )
special.c:	|| IS_SET( ch->in_room->room_flags, ROOM_CONE_OF_SILENCE ) )
special.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
special.c:	if ( victim->deleted )
special.c:	if ( victim->fighting == ch && can_see( ch, victim )
special.c:	case  7: min_level = 21; spell = ((IS_SET(ch->special, EXPERT) ? "teleport":"paralyze"));	   break;
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:     *	-- Thelonius (Monk)
special.c:    if ( !( pexit = ch->in_room->exit[door] ) )
special.c:    if ( IS_SET( pexit->exit_info, EX_BASHED ) )
special.c:	REMOVE_BIT( pexit->exit_info, EX_BASHED );
special.c:	act( "§A­×¦n¤F $d.", ch, NULL, pexit->keyword, TO_CHAR );
special.c:	act( "$n ­×¦n¤F $d.", ch, NULL, pexit->keyword, TO_ROOM );
special.c:	if (   ( to_room   = pexit->to_room		  )
special.c:	    && ( pexit_rev = to_room->exit[rev_dir[door]] )
special.c:	    && pexit_rev->to_room == ch->in_room )
special.c:	    REMOVE_BIT( pexit_rev->exit_info, EX_BASHED );
special.c:	    for ( rch = to_room->people; rch; rch = rch->next_in_room )
special.c:		    rch, NULL, pexit_rev->keyword, TO_CHAR );
ssm.c: *  usage is now virtually identical to standard Merc on 32-bit		      *
ssm.c: *  architecture, but slightly larger on 64-bit. Memory usage is still	      *
ssm.c: *  handled more efficiently by marking failed chunks with -1 to temporarily  *
ssm.c: *  ROM2.4 modifications by Tom Adriaenssen (Jan 1996) -- Wreck		      *
ssm.c: *  Removed ROM 2.4 modifications as Envy doesnt need *fread_string_eol -Kahn *
ssm.c://*---------------------------------------------------------------*
ssm.c:#define addrSizeMask ( sizeof( addrType ) - 1 )
ssm.c:    top_string	 = string_space + MAX_STRING-1;
ssm.c:    HEADER_SIZE	 = (int)( (char*)&ssm_buf_head->buf[0] - (char*)ssm_buf_head );
ssm.c:	walk->usage = 0;
ssm.c:	walk->size  = CHUNK_SIZE - HEADER_SIZE;
ssm.c:	if( i < MAX_CHUNKS - 1 )
ssm.c:	    walk->next = (BufEntry *)( (char*)walk + CHUNK_SIZE );
ssm.c:	    walk       = walk->next;
ssm.c:	walk->next = 0;
ssm.c:     * Free blocks are merged in str_free if free->next is free but
ssm.c:     *	(2) Speed - don't want to bog down str_ functions with heap management
ssm.c:	next = walk->next;
ssm.c:	if( walk->usage > 0 )
ssm.c:	    if( (long)last_free->size + (long)walk->size <= CHUNK_SIZE )
ssm.c:		last_free->size += walk->size + HEADER_SIZE;
ssm.c:		last_free->next	 = walk->next;
ssm.c:		last_free->usage = 0;
ssm.c:		ptr = (BufEntry *)( str - HEADER_SIZE );
ssm.c:		if( ptr->usage <= 0 ){
ssm.c:		ptr->usage++;
ssm.c:		len += addrTypeSize - ( ( len + HEADER_SIZE ) & addrSizeMask );
ssm.c:		for( ptr = ssm_buf_free; ptr; ptr = ptr->next )
ssm.c:			if( ptr->usage == 0 && ptr->size >= len ) break;
ssm.c:		}else if( ptr->size - len >= HEADER_SIZE ){
ssm.c:			/* WARNING! - DONT REMOVE THE CASTS BELOW! - Fusion */
ssm.c:			temp->size	 = ptr->size - ( len + HEADER_SIZE );
ssm.c:			temp->next	 = ptr->next;
ssm.c:			temp->usage	 = 0;
ssm.c:			ptr->size    = len;
ssm.c:			ptr->next  	 = temp;
ssm.c:			ptr->usage	 = 1;
ssm.c:			ptr->usage = 1;
ssm.c:				ssm_buf_free->usage--; /* buf_free was skipped */
ssm.c:			for( ssm_buf_free = ssm_buf_head; ssm_buf_free; ssm_buf_free = ssm_buf_free->next ){
ssm.c:				if( ssm_buf_free->usage == 0 ) break;
ssm.c:		str_new = (char *)&ptr->buf[0];
ssm.c:		sAllocString += ptr->size + HEADER_SIZE;
ssm.c:	ptr = (BufEntry *)( str - HEADER_SIZE );
ssm.c:	if( --ptr->usage > 0 )
ssm.c:	else if( ptr->usage < 0 )
ssm.c:	    bug( (char*)&ptr->buf[0], 0 );
ssm.c:	sAllocString -= ( ptr->size + HEADER_SIZE );
ssm.c:	nAllocString--;
ssm.c:	    for( ptr = temp_string_hash[ ihash ]; ptr; ptr = ptr->next )
ssm.c:		if( ptr->str != str )
ssm.c:		    temp_string_hash[ ihash ] = ptr->next;
ssm.c:			walk = walk->next )
ssm.c:			if( walk->next == ptr )
ssm.c:			    walk->next = ptr->next;
ssm.c:    sOverFlowString -= strlen( str ) + 1;
ssm.c:    nOverFlowString--;
ssm.c:/* Lookup the string in the boot-time hash table. */
ssm.c:    for( ptr = temp_string_hash[ ihash ]; ptr; ptr = ptr->next )
ssm.c:	if( *ptr->str != *str )
ssm.c:	else if( strcmp( ptr->str, str ) )
ssm.c:	else return ptr->str;
ssm.c:    add->next = temp_string_hash[ ihash ];
ssm.c:    add->len = len;
ssm.c:    add->str = str;
ssm.c:	    next = ptr->next;
ssm.c:    int type= -1;
ssm.c:    if( ch->pcdata )
ssm.c:	bug("ch->ride = %d", ch->pcdata->ride);
ssm.c:    if( ch->pcdata->horse && ch->pcdata->horse->pcdata )
ssm.c:	bug("horse->ride = %d", ch->pcdata->horse->pcdata->ride);
ssm.c:ptr = (BufEntry *)( str - HEADER_SIZE );
ssm.c:if (ptr->usage == 1)
ssm.c: bug((char *)&ptr->buf[0],0);
ssm.c: ptr = ptr->next;
ssm.c:	    obj->name );
ssm.c:    sprintf( buf, "Serial: [%ld]\n\r", (long)obj->serial);
ssm.c:    if( obj->material ) {
ssm.c:	sprintf( buf, "Material: %s\n\r", obj->material->short_descr );
ssm.c:	    obj->pIndexData->vnum, item_type_name( obj ) );
ssm.c:	    obj->short_descr, obj->description );
ssm.c:	    wear_bit_name(obj->wear_flags), extra_bit_name( obj->extra_flags ) );
ssm.c:    if( IS_SET(obj->extra_flags, ITEM_UNIQUE)){
ssm.c:	sprintf(buf, "Unique, Replica : %d.\n\r", obj->pIndexData->replica );
ssm.c:	    obj->weight, get_obj_weight( obj ) );
ssm.c:	    obj->cost, obj->timer, obj->level, obj->class, obj->race );
ssm.c:	    !obj->in_room    ?	      0 : obj->in_room->vnum,
ssm.c:	    !obj->in_obj     ?	     "" : obj->in_obj->short_descr,
ssm.c:	    !obj->in_obj     ?	     "" : "(",
ssm.c:	    !obj->in_obj     ? "¡]µL¡^" : obj->in_obj->name,
ssm.c:	    !obj->in_obj     ?	     "" : ")",
ssm.c:	    !obj->carried_by ?	     "" : obj->carried_by->short_descr,
ssm.c:	    !obj->carried_by ?	     "" : "(",
ssm.c:	    !obj->carried_by ? "¡]µL¡^" : obj->carried_by->name,
ssm.c:	    !obj->carried_by ?	     "" : ")",
ssm.c:	    obj->wear_loc );
ssm.c:	    obj->value[0], obj->value[1], obj->value[2], obj->value[3],obj->value[4] );
ssm.c:    if ( ( obj->extra_value ).used )
ssm.c:	      ( obj->extra_value ).v[0],
ssm.c:	      ( obj->extra_value ).v[1],
ssm.c:	      ( obj->extra_value ).t[0],
ssm.c:	      ( obj->extra_value ).t[1] );
ssm.c:    if ( obj->extra_descr || obj->pIndexData->extra_descr )
ssm.c:	for ( ed = obj->extra_descr; ed; ed = ed->next )
ssm.c:	    strcat( buf1, ed->keyword );
ssm.c:	    if ( ed->next )
ssm.c:	for ( ed = obj->pIndexData->extra_descr; ed; ed = ed->next )
ssm.c:	    strcat( buf1, ed->keyword );
ssm.c:	    if ( ed->next )
ssm.c:    for ( paf = obj->affected; paf; paf = paf->next )
ssm.c:		affect_loc_name( paf->location ), paf->modifier );
ssm.c:    for ( paf = obj->pIndexData->affected; paf; paf = paf->next )
ssm.c:		affect_loc_name( paf->location ), paf->modifier );
ssm.c:    for ( paf = obj->material->affected; paf; paf = paf->next )
ssm.c:		affect_loc_name( paf->location ), paf->modifier );
ssm.c:    if( obj->vrace ) {
ssm.c:	for( ovr = obj->vrace ; ovr ; ovr = ovr->next )
ssm.c:		    race_table[ovr->race].name, ovr->hr_mod_q, ovr->hr_mod_p,
ssm.c:		    ovr->dr_mod_q, ovr->dr_mod_p);
ssm.c:    if( obj->material->vrace ) {
ssm.c:	for( ovr = obj->material->vrace ; ovr ; ovr = ovr->next )
ssm.c:		    race_table[ovr->race].name, ovr->hr_mod_q, ovr->hr_mod_p,
ssm.c:		    ovr->dr_mod_q, ovr->dr_mod_p);
ssm.c:    if( obj->item_type == ITEM_ARROW ) type = 14;
ssm.c:    else if( obj->item_type == ITEM_WEAPON) type = obj->value[3];
ssm.c:    if( type > -1 && type < MAX_TYPES ) {
ssm.c:	for( ovr = (basic_types[type])->vrace ; ovr ; ovr = ovr->next )
ssm.c:		    race_table[ovr->race].name, ovr->hr_mod_q, ovr->hr_mod_p,
ssm.c:		    ovr->dr_mod_q, ovr->dr_mod_p);
ssm.c:    if ( obj->hp )
ssm.c:	OBJ_HP * ohp = obj->hp;
ssm.c:	for( ; ohp; ohp = ohp->next ) {
ssm.c:		    ohp->hp_name, ohp->percent, ohp->level,
ssm.c:		    ohp->event );
ssm.c:    if( obj->material->hp ) 
ssm.c:	OBJ_HP * ohp = obj->material->hp;
ssm.c:	for( ; ohp; ohp = ohp->next ) {
ssm.c:		    ohp->hp_name, ohp->percent, ohp->level,
ssm.c:		    ohp->event );
update.c://*-----------------------------------------------------------------*
update.c://*              :         «e«á¥[¤W obj->update_checked ªº¹Bºâ¦¡    *
update.c://*-----------------------------------------------------------------*
update.c://*-----------------------------------------------------------------*
update.c://*-----------------------------------------------------------------*
update.c://*-----------------------------------------------------------------*
update.c://*-----------------------------------------------------------------*
update.c://*-----------------------------------------------------------------*
update.c://*  PURPOSE     :         ­×§ï obj_extra_value ªº t0 t1 ·|´î¨ì -1  *
update.c://*-----------------------------------------------------------------*
update.c://*-----------------------------------------------------------------*
update.c:    if( IS_NPC(ch) || !IS_SET(ch->act, PLR_TITLE)){
update.c:  if( IS_NPC( ch )|| IS_SET( ch->act, PLR_CHINESE )  ){
update.c:      sprintf( buf, "- %s", 
update.c:        c_title_table [ch->class] [ch->level] [ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:        title_table [ch->class] [ch->level] [ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:    ch->temp_race = '\0'; //NULL;
update.c:        class_table[ch->class].hp_min,
update.c:        class_table[ch->class].hp_max ) 
update.c:        + race_table[ ch->race ].hp_gain;
update.c:        class_table[ch->class].hp_max 
update.c:        + race_table[ ch->race ].hp_gain;
update.c:    switch(ch->class) {
update.c:            mod = ((4*get_curr_int( ch ) + 1*get_curr_wis( ch ) + 2*race_table[ch->race].mana_gain ) / 7);
update.c:            mod = ((2*get_curr_int( ch ) + 3*get_curr_wis( ch ) + 2*race_table[ch->race].mana_gain ) / 7);
update.c:      if ( ch->pcdata->prime_attr == APPLY_WIS )
update.c:            mod = ((2*get_curr_int( ch ) + 3*get_curr_wis( ch ) + 2*race_table[ch->race].mana_gain ) / 7);
update.c:            mod = ((3*get_curr_int( ch ) + 2*get_curr_wis( ch ) +2*race_table[ch->race].mana_gain ) / 7);
update.c:            mod = ((3*get_curr_int( ch ) + 2*get_curr_wis( ch ) + 2*race_table[ch->race].mana_gain ) / 7);
update.c:    if( class_table[ ch->class ].fMana ){
update.c:    add_mana = number_range( mod -4, mod);
update.c:    else if ( ch->pcdata->prime_attr == APPLY_WIS 
update.c:      || ch->pcdata->prime_attr == APPLY_INT )
update.c:  add_mana = number_range( mod - 2, mod );
update.c:      number_range( 5,( ( get_curr_con( ch ) + 4 * get_curr_dex( ch ) + 2* race_table[ch->race].move_gain)  / 3)) ;
update.c:    max +=   ( get_curr_con( ch ) + 4 * get_curr_dex( ch ) + 2*race_table[ch->race].move_gain) / 3 ;
update.c:    if( total > max -3 ) /* you are too lucky */
update.c:  add_hp--;
update.c:  add_mana--;
update.c:  add_move--;
update.c:    switch( ch->level )
update.c:      ch->pp += 3;
update.c:      ch->mdr += 4;
update.c:      ch->pdr += 4;
update.c:      ch->pp += 4;
update.c:      ch->mdr += 8;
update.c:      ch->pdr += 8;
update.c:      ch->pp += 6;
update.c:      ch->mdr += 12;
update.c:      ch->pdr += 12;
update.c:    ch->max_hit += add_hp;
update.c:    ch->max_mana  += add_mana;
update.c:    ch->max_move  += add_move;
update.c:    ch->practice  += add_prac;
update.c://  REMOVE_BIT( ch->act, PLR_BOUGHT_PET );
update.c:      add_hp, ch->max_hit,
update.c:      add_mana, ch->max_mana,
update.c:      add_move, ch->max_move,
update.c:      add_prac, ch->practice );
update.c:    if( ch->level > 30 || ch->level % 5 == 0 ) do_backup(ch,"");
update.c:    sprintf( buf, "%s "HIG"ªºµ¥¯Å´£¤É¤F¡I"NOR"\n\r", ch->cname );
update.c:    if ( ch->level == 1 )
update.c:  title_table [ch->class] [ch->level] [ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:        class_table[ch->class].hp_min,
update.c:        class_table[ch->class].hp_max ) 
update.c:        + race_table[ ch->race ].hp_gain;
update.c:        class_table[ch->class].hp_max 
update.c:        + race_table[ ch->race ].hp_gain;
update.c:    mod = class_table[ ch->class ].fMana ? 
update.c:  ((3*get_curr_int( ch ) + 2 * get_curr_wis( ch ) + 2*race_table[ch->race].mana_gain ) / 7):
update.c:    add_mana = class_table[ch->class].fMana ? number_range( mod -4, mod) :0;
update.c:      number_range( 5,( ( get_curr_con( ch ) + (3 * get_curr_dex( ch )) + (2* race_table[ch->race].move_gain) ) / 3) );
update.c:    max +=   ( get_curr_con( ch ) + 2 * get_curr_dex( ch ) + 2*race_table[ch->race].move_gain) / 3 ;
update.c:    if( total > max -3 ) /* you are too lucky */
update.c:  add_hp--;
update.c:  add_mana--;
update.c:  add_move--;
update.c:    switch( ch->level )
update.c:      ch->pp -= 2;
update.c:      ch->mdr -= 2;
update.c:      ch->pdr -= 2;
update.c:      ch->mdr += 4;
update.c:      ch->pdr += 4;
update.c:      ch->pp += 3;
update.c:      ch->mdr += 4;
update.c:      ch->pdr += 4;
update.c:    ch->max_hit -= add_hp;
update.c:    ch->max_mana  -= add_mana;
update.c:    ch->max_move  -= add_move;
update.c:    ch->practice  -= add_prac;
update.c://  REMOVE_BIT( ch->act, PLR_BOUGHT_PET );
update.c:    ch->level -= 1;
update.c:      add_hp, ch->max_hit,
update.c:      add_mana, ch->max_mana,
update.c:      add_move, ch->max_move,
update.c:      add_prac, ch->practice );
update.c:    if ( IS_NPC( ch ) || ch->level >= L_APP )
update.c: //   if ( ch->race == gnome && gain > 0 )
update.c:    if ( ch->clan )
update.c:        clanexp = gain / ( 7 - ch->pcdata->clanlevel );
update.c:        gain -= clanexp;
update.c:        if ( ch->clan->bank > clanexp && clanexp>0 )
update.c:            ch->clan->score += ( clanexp / 10 );
update.c:            ch->clan->bank -= UMAX( 0, clanexp * 2 );
update.c:            ch->pcdata->clanexp += clanexp;
update.c:/*    if (ch->exp< EXP_PER_LEVEL(ch->level-1) * ch->level )
update.c:            ch->exp = ch->exp + gain;
update.c:    //ch->exp = UMAX( EXP_PER_LEVEL( ch->level - 1 ) * ch->level, ch->exp + gain );
update.c:    ch->exp = UMAX( 0 , ch->exp + gain );
update.c:    while ( ch->level < L_APP && ch->exp >= EXP_PER_LEVEL( ch->level,ch->class ) * ( ch->level + 1 ) )
update.c:        if( ch->level == 39 ) {
update.c:        if( ch->level == 40 ) {
update.c:        if( ch->level == 41 ) {
update.c:        if( ch->level == 42 ) 
update.c:        ch->level += 1;
update.c:        if ( ch->class < 4 && ch->level == 30)
update.c:        if ( ch->level % 5 == 0 )
update.c:    if( ch->exp <= 0 ) {
update.c:            ch->pcdata->denied = time(NULL) + 8640000;
update.c:            SET_BIT( ch->act, PLR_DENY );
update.c:            bugf("%s's exp < 0", ch->name);
update.c:	if(!IS_NPC(ch) && IS_SET(race_table[ ch->race ].race_abilities, RACE_INFRAVISION) ){
update.c:			ch->hit  += nGain * get_curr_con(ch) / 12;
update.c:			ch->mana += nGain * get_curr_int(ch) / 12;
update.c:			ch->move += nGain * get_curr_dex(ch) / 12;
update.c:        gain = ch->max_hit/50 + ch->level * 4;
update.c:        gain =   UMAX( 10, ch->level )
update.c:               + UMAX((get_curr_con( ch ) - 10),0) * 5 
update.c:        if ( race_table[ch->race].hunger_mod >= 0 ) {
update.c:            nFood  = ch->pcdata->condition[COND_FULL];
update.c:        if ( race_table[ch->race].thirst_mod >= 0 ) {
update.c:            nDrink = ch->pcdata->condition[COND_THIRST];
update.c:        switch ( ch->position )
update.c:        gain += gain * (4 + race_table[ ch->race ].hp_gain) / 8;
update.c:        gain += ch->max_hit / 100;
update.c:        gain = ch->max_mana/100 + ch->level * 4;
update.c:        gain =   UMAX( 10 , ch->level/2 ) 
update.c:               + UMAX((get_curr_int( ch ) - 10),0) 
update.c:        if ( race_table[ch->race].hunger_mod >= 0 ) {
update.c:            nFood  = ch->pcdata->condition[COND_FULL];
update.c:        if ( race_table[ch->race].thirst_mod >= 0 ) {
update.c:            nDrink = ch->pcdata->condition[COND_THIRST];
update.c:        switch ( ch->position ){
update.c:        gain += gain * (4 + race_table[ ch->race ].mana_gain) / 8;
update.c:        gain += ch->pcdata->condition[COND_DRUNK];
update.c:        gain += ch->max_mana / 100;
update.c:        if( ch->pcdata->prime_attr == APPLY_INT ){
update.c:				}else if( ch->pcdata->prime_attr == APPLY_WIS ){
update.c:        gain = ch->max_move/100 + ch->level * 4;
update.c:        gain =   UMAX( 10, ch->level )
update.c:               + UMAX((get_curr_con( ch ) - 10), 0) * 5 
update.c:        if ( race_table[ch->race].hunger_mod >= 0 ) {
update.c:            nFood  = ch->pcdata->condition[COND_FULL];
update.c:        if ( race_table[ch->race].thirst_mod >= 0 ) {
update.c:            nDrink = ch->pcdata->condition[COND_THIRST];
update.c:        switch ( ch->position )
update.c://      if( !IS_NPC(ch) && IS_SET(ch->act, PLR_MEDITATING))
update.c:        gain += gain * (4 + race_table[ ch->race ].move_gain) / 8;
update.c:        gain += ch->max_move / 100;
update.c:    //return UMIN( gain, ch->max_move - ch->move );
update.c:    condition       = ch->pcdata->condition[ iCond ];
update.c:    ch->pcdata->condition[iCond]  = URANGE( 0, condition + value, 48 );
update.c:    if ( ch->level < LEVEL_HERO || ( ch->level < L_APP && IS_SET(ch->act, PLR_NOTIFY)))
update.c:        if ( ch->pcdata->condition[iCond] == 0 )
update.c:        else if ( iCond == COND_DRUNK && ch->pcdata->condition[ iCond ] > 3 )
update.c: * -- Furey
update.c:    for ( ch = char_list; ch; ch = ch->next )
update.c:  if ( ch->deleted )
update.c:      || !ch->in_room
update.c://  if( ch->wait && !ch->fighting ) ch->wait = 0;
update.c:  if ( ch->spec_fun && !IS_AFFECTED(ch, AFF_PARALYZED))
update.c:      if ( ( *ch->spec_fun ) ( ch ) )
update.c:  if ( ch->position < POS_STANDING )
update.c:  if ( ch->in_room->area->nplayer > 0 )
update.c:            trigger, continue - Kahn */
update.c:      if ( ch->position < POS_STANDING )
update.c:  if ( IS_SET( ch->act, ACT_SCAVENGER )
update.c:      && ch->in_room->contents
update.c:      for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
update.c:        && obj->cost > max
update.c:        max   = obj->cost;
update.c:    sprintf(picbuf,"'%s'", obj_best->name);
update.c:  /* Wander or Flee  - modifications by Jason Dinkel */
update.c:  if ( ch->hit < ch->max_hit / 2 )
update.c:  if ( !IS_SET( ch->act, ACT_SENTINEL )
update.c:      && ( pexit = ch->in_room->exit[door] )
update.c:      &&   pexit->to_room
update.c:      &&   !IS_SET( pexit->exit_info, EX_CLOSED )
update.c:      &&   !IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB )
update.c:      && ( !IS_SET( ch->act, ACT_STAY_AREA )
update.c:    ||   pexit->to_room->area == ch->in_room->area ) )
update.c:            continue - Kahn */
update.c:      if ( ch->position < POS_STANDING )
update.c:    for ( rch  = pexit->to_room->people;
update.c:          rch  = rch->next_in_room )
update.c:        if ( rch->deleted )
update.c:      door = -1;
update.c:          if ( ch->in_room->exit[direction]
update.c:      if ( door == -1 )
update.c:  diff = weather_info.mmhg >  985 ? -2 : 2;
update.c:  diff = weather_info.mmhg > 1015 ? -2 : 2;
update.c:    weather_info.change   += diff * dice( 1, 4 ) + dice( 2, 6 ) - dice( 2, 6 );
update.c:    weather_info.change    = UMAX( weather_info.change, -12 );
update.c:  for ( d = descriptor_list; d; d = d->next )
update.c:      if ( d->connected == CON_PLAYING
update.c:    && IS_OUTSIDE( d->character )
update.c:    && IS_AWAKE  ( d->character ) )
update.c:    send_to_char( buf, d->character );
update.c:  d_next = d->next;
update.c:  if ( (d->connected != CON_PLAYING) )
update.c:      if ( --d->repeat <= -10 )
update.c:    sprintf( log_buf, "%s idle too long !", d->host );
update.c:    for ( ch = char_list; ch; ch = ch->next ){
update.c:      if ( ch->deleted )
update.c:      if( !ch->in_room ) continue;
update.c:            ch->hit = UMIN( ch->hit + 65 + nChSklv * 40 + nChSklv * nChSklv * nChSklv, ch->max_hit );
update.c:            ch->hit = UMIN( ch->hit + ch->max_hit * (5 + nChSklv * 2) / 100, ch->max_hit );
update.c:            ch->hit = UMIN( ch->hit + 65 + nSklv * 40 + nSklv * nSklv * nSklv, ch->max_hit );
update.c:            ch->hit = UMIN( ch->hit + ch->max_hit * (5 + nSklv * 2) / 100, ch->max_hit );
update.c://  if ( IS_NPC( ch ) && ch->position > POS_FIGHTING )
update.c:  if ( IS_NPC( ch ) && ( ch->position > POS_FIGHTING || is_qmark(ch, "enable_fight_tick")))
update.c:            trigger, continue - Kahn */
update.c:      if ( ch->position < POS_STANDING || ch->deleted )
update.c:        if( !IS_NPC(ch) && IS_SET(ch->act, PLR_NOTIFY) && ch->level > 2 && !is_qmark(ch, "roc_ppl_salary") && number_bits(5) < 3 ){
update.c:    //if ( ch->forced ) ch->forced = FALSE; // delete forced
update.c:  if ( !IS_NPC(ch) && ch->pcdata->autocombat == AUTOC_INSTANT
update.c:      ch->pcdata->autocombat = AUTOC_NORMAL;
update.c:  if ( !IS_NPC( ch ) && !IS_SET( ch->act, PLR_HORSE )
update.c:      && ( !ch->desc || ch->desc->connected == CON_PLAYING )
update.c:      &&   ch->level >= 2
update.c:      &&   ch->save_time < save_time )
update.c:      save_time = ch->save_time;
update.c:  if( ch->position >= POS_STUNNED )
update.c:          if( qmark->v0 > 1 )
update.c:              do_mod_qmark( ch, "self cast_evacuate_mark v0 - 1" );
update.c:          if( ch->hit  <= ch->max_hit   )
update.c:              ch->hit = UMIN( ch->max_hit, ch->hit + hit_gain( ch ) );
update.c:          else if ( ch->hit > ch->max_hit * 2 )
update.c:              ch->hit = ch->max_hit * 2;
update.c:              ch->hit = UMAX( ch->max_hit, ch->hit - hit_gain( ch ) );
update.c:          if( ch->mana <= ch->max_mana )
update.c:              ch->mana = UMIN( ch->max_mana, ch->mana + mana_gain( ch ) );
update.c:          else if ( ch->mana > ch->max_mana * 2 )
update.c:              ch->mana = ch->max_mana * 2;
update.c:              ch->mana = UMAX( ch->max_mana, ch->mana - mana_gain( ch ) );
update.c:              if( ch->mana >= ch->max_mana ) 
update.c:                  ch->wait = 0;
update.c:          if( ch->move <= ch->max_move )
update.c:              ch->move = UMIN( ch->max_move, ch->move + move_gain( ch ) );
update.c:          else if( ch->move > ch->max_move * 2 )
update.c:              ch->move = ch->max_move * 2;
update.c:              ch->move = UMAX( ch->max_move, ch->move - move_gain( ch ) );
update.c:  if ( ch->position <= POS_PARALYZED )
update.c:  if ( ch->position == POS_DEAD )
update.c:  if ( !IS_NPC( ch ) && !IS_SET( ch->act, PLR_HORSE ) && 
update.c:    ch->level < LEVEL_IMMORTAL && !IS_SWITCHED( ch ) )
update.c:    && obj->item_type == ITEM_LIGHT
update.c:    && obj->value[2] > 0 )
update.c:    if ( --obj->value[2] == 0 )
update.c:        --ch->in_room->light;
update.c:      if ( ++ch->timer >= 10 )
update.c://    if ( !ch->was_in_room )
update.c:        ch->was_in_room = ch->in_room;
update.c:        if ( ch->fighting )
update.c:                    SET_BIT(ch->act, PLR_IDLE);
update.c:        if ( IS_SET(ch->act, PLR_IDLE))//ch->in_room->vnum == 11001 || ch->in_room->vnum == ROOM_VNUM_LIMBO)
update.c://    else if ( !ch->desc )
update.c:    if ( !ch->desc )
update.c:      sprintf( buf, "%s lost link too long, force quit!", ch->name );
update.c:      if ( ch->timer > 20 && !IS_SWITCHED( ch ) ){
update.c:    if( ch->was_in_room ) {
update.c:        char_to_room(ch, ch->was_in_room);
update.c:      gain_condition( ch, COND_DRUNK,  -1 );
update.c:      if ( ch->level < 4 && ch->class < 5 )
update.c:        ch->pcdata->condition[COND_FULL] = 48;
update.c:        ch->pcdata->condition[COND_THIRST] = 48;
update.c:        if(race_table[ch->race].hunger_mod >= 0)
update.c:            gain_condition( ch, COND_FULL,   - number_range(1, 1 + race_table[ch->race].hunger_mod));
update.c:        if(race_table[ch->race].thirst_mod >= 0)
update.c:            gain_condition( ch, COND_THIRST, - number_range(1, 1 + race_table[ch->race].thirst_mod));
update.c:  else if ( ch->desc && IS_SET(ch->act, PLR_HORSE))
update.c:      if ( ++ch->timer >= 10 )
update.c:    if ( !ch->was_in_room )
update.c:        ch->was_in_room = ch->in_room;
update.c:        if ( ch->fighting )
update.c:      ch->desc->original, NULL, NULL, TO_ROOM );
update.c:        //do_save(ch->desc->original, "");
update.c:                    SET_BIT(ch->act, PLR_IDLE);
update.c:        if( IS_SET(ch->act, PLR_IDLE) )//ch->in_room->vnum == ROOM_VNUM_LIMBO)
update.c:        //char_from_room(ch->desc->original);
update.c:        //char_to_room( ch->desc->original, get_room_index( ROOM_VNUM_LIMBO ) );
update.c:      if ( ch->timer > 20 && !IS_SWITCHED( ch ) && ch->desc) {
update.c:    CHAR_DATA * ppl = ch->desc->original;
update.c:  for ( paf = ch->affected; paf; paf = paf->next )
update.c:      if ( paf->deleted )
update.c:      if ( paf->duration > 0 )
update.c:    paf->duration--;
update.c:      else if ( paf->duration < 0 )
update.c:    if ( !paf->next
update.c:        || paf->next->type != paf->type
update.c:        || paf->next->duration > 0 )
update.c:        if ( paf->type > 0 && skill_table[paf->type].msg_off )
update.c:      send_to_char( skill_table[paf->type].msg_off, ch );
update.c://    if ( paf->type == gsn_vampiric_bite )
update.c://        ch->race = race_lookup( "Vampire" );
update.c:      if( paf->type == gsn_polymorph || paf->type == gsn_morphing )
update.c:          ch->temp_race = '\0';
update.c:      if( paf->type == gsn_flying )
update.c:  if ( ch->deleted )
update.c:  if ( IS_SET( race_table[ ch->race ].race_abilities, RACE_VAMPIRE ) )
update.c:      if (   !IS_SET( ch->in_room->room_flags, ROOM_UNDERGROUND )
update.c:          && !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) ){
update.c:        int dmg = ch->max_hit;
update.c:        if( ch->class < 5 && ch->level < 30 )
update.c:            dmg = ch->hit / 5;
update.c:        //dmg = ((ch->hit / 2)+2);
update.c:          dmg = ch->hit * (10 - nSklv) / 30;
update.c:					if(nSklv > 4) dmg -= (nSklv - 4) * 25;
update.c:          if(dmg < 0) dmg = ch->hit /10;
update.c:        if(ch->deleted) break;
update.c:      int nDecay    = (time_info.hour > 12) ? (time_info.hour - 12) : (12 - time_info.hour);
update.c:      int nMaxHr    =  8 - nSklv/2 - (nSklv * nSklv) / 6;
update.c:			int nMaxDr    =  8 - nSklv/2 - (nSklv * nSklv) / 6;
update.c:      nMaxHr -= nDecay;
update.c:      nMaxDr -= nDecay;
update.c:        af.duration  = -1;
update.c:        af.modifier  = - nMaxHr;
update.c:        af.modifier  = - nMaxDr;
update.c:      int nDecay    = (time_info.hour > 12) ? (24 - time_info.hour) : (time_info.hour);
update.c:      af.duration  = -1;
update.c:      af.modifier  = nMaxHr - nDecay * 1.5;
update.c:			af.modifier  = nMaxDr - nDecay * 1.5;
update.c:  if ( IS_SET( race_table[ ch->race ].race_abilities, RACE_WEREWOLF ) && !IS_NPC(ch) 
update.c:    // if (time_info.hour > 3 + nSklv && time_info.hour < 21 - nSklv){
update.c:    if (time_info.hour > 4 + nSklv * 2 / 3 && time_info.hour < 20 - nSklv * 2 / 3){
update.c:        if(ch->class >= 5){
update.c:            af.duration  = -1;
update.c:            af.modifier  = -ch->race;
update.c:            af.modifier  = 100 - nSklv * (nSklv + 4);
update.c:            af.modifier  = 100 - nSklv * (nSklv + 4);
update.c:        int nDecay   = (time_info.hour > 12) ? (24 - time_info.hour) : (time_info.hour);
update.c:        af.duration  = -1;
update.c:            nMaxPD   = nMaxPD * (12 - nDecay) / 12;
update.c:            nMaxAC   = nMaxAC * (12 - nDecay) / 12;
update.c:            af.modifier  = - nMaxAC;
update.c:              &&  ch->level >= 36 && ch->class >= 5){
update.c:                   af.modifier   = -10;
update.c:                   af.modifier   = -2;
update.c:  if ( ch->deleted )
update.c:  if ( (   ch->in_room->sector_type == SECT_UNDERWATER
update.c:      && !IS_SET( race_table[ ch->race ].race_abilities,
update.c:    || ( ch->in_room->sector_type != SECT_UNDERWATER
update.c:        && ch->in_room->sector_type != SECT_WATER_NOSWIM
update.c:        && IS_SET( race_table[ ch->race ].race_abilities,
update.c:        && ( str_cmp( race_table[ ch->race ].name, "Object" )
update.c:      && str_cmp( race_table[ ch->race ].name, "God" ) ) ) )
update.c:      ////damage( ch, ch, number_range(ch->max_hit/20, ch->max_hit/10), gsn_breathe_water, WEAR_NONE );
update.c:      damage( ch, ch, number_range(ch->max_hit/20, ch->max_hit/10), gsn_breathe_water, WEAR_NONE, MSG_NORMAL, DMG_NORMAL );
update.c:  if ( ch->deleted )
update.c:  &&   !IS_SET( race_table[ch->race].race_abilities, RACE_NO_POISON))
update.c:      ch->hit = ( ( ( ch->hit - ch->saving_throw[MAGIC_POISON] ) <= 0 ) ? 
update.c:          1 : ch->hit - ch->saving_throw[MAGIC_POISON] );
update.c:      ch->hit = ch->hit - ch->saving_throw[MAGIC_POISON];
update.c:      if ( ch->position == POS_DEAD )
update.c:    if ( (ch->hit - ch->level*2) <= 0 )
update.c:      ch->hit = 1;
update.c:      ch->hit -= ch->level*2;
update.c:      ch->mana -= ch->level*2;
update.c:      ch->move -= ch->level*2;
update.c:    ch->hit = ch->hit - ch->hit/12;
update.c:    ch->mana = ch->mana - ch->mana/12;
update.c:    ch->move = ch->move - ch->move/12;
update.c:      if ( ch->position == POS_DEAD )
update.c:  if ( ch->deleted )
update.c:  if ( ch->position == POS_MORTAL )
update.c:  if ( ch->deleted )
update.c:  if ( ch->position == POS_INCAP )
update.c:  if ( ch->deleted )
update.c:      ch->move -= ch->level + ch->level / 2;
update.c:  for ( ch = char_list; ch; ch = ch->next )
update.c:      if ( ch->deleted )
update.c:      if( ch == auction->owner )
update.c:          talk_channel( auction->owner , "¥Ñ©ó¥»¤HÂ_½u¤F¡A©ç½æ¦]¦¹¤¤¤î¡C", CHANNEL_AUCTION, "¡i©ç½æ¡j",HIY );
update.c:          obj_to_char( auction->obj, ch );
update.c:        auction_list = auction_list->next;
update.c:        for( auc_next = auction_list ; auc_next; auc_next = auc_next->next ){
update.c:            if( auc_next->next == auction ){
update.c:          auc_next->next = auction->next;
update.c:          auc_next = auction->next;
update.c:      else if( ch == auction->buyer )
update.c:          talk_channel( auction->owner , "¥Ñ©ó¶R¤èÂ_½u¤F¡A©ç½æ¦]¦¹¤¤¤î¡C", CHANNEL_AUCTION, "¡i©ç½æ¡j",HIY );
update.c:          obj_to_char( auction->obj, auction->owner );
update.c:        auction_list = auction_list->next;
update.c:        for( auc_next = auction_list ; auc_next; auc_next = auc_next->next ){
update.c:            if( auc_next->next == auction ){
update.c:          auc_next->next = auction->next;
update.c:          auc_next = auction->next;
update.c:      auc_next = auction->next;
update.c:    if( ch->was_in_room ) {
update.c:        char_to_room(ch, ch->was_in_room);
update.c:		obj_next = obj->next;
update.c:		if ( obj->deleted   ) continue;
update.c:		if ( obj->in_eqbank ) continue;
update.c:		if( obj->carried_by )
update.c:			obj->update_checked = FALSE;
update.c:			obj->update_checked = TRUE;
update.c:		else if ( obj->in_room )
update.c:		if ( obj->timer < -1 )
update.c:			obj->timer = -1;
update.c:		if( obj->carried_by && obj->wear_loc != -1 && IS_SET (obj->pIndexData->souvenir, Z1) )
update.c:			act ( "§A³Q $p µ¹±Æ¥¸¤F.", obj->carried_by, obj, NULL, TO_CHAR );
update.c:			act ( "$n ³Q $p ±Æ¥¸¤F." , obj->carried_by, obj, NULL, TO_ROOM );
update.c:			unequip_char ( obj->carried_by, obj );
update.c:		pafPre = obj->affected;
update.c:		for ( paf = obj->affected; paf; paf = pafNext )
update.c:			pafNext = paf->next;
update.c:			if ( paf->duration != 0 )
update.c:				if ( paf->duration > 0 )
update.c:					paf->duration--;
update.c:			if ( paf == obj->affected )
update.c:				obj->affected = pafPre = paf->next;
update.c:				pafPre->next = paf->next;
update.c:		if ( ( obj->extra_value ).used )
update.c:			( obj->extra_value ).t[0] = UMAX ( -1, ( obj->extra_value ).t[0] - 1 );
update.c:			( obj->extra_value ).t[1] = UMAX ( -1, ( obj->extra_value ).t[1] - 1 );
update.c:			if ( ( obj->extra_value ).t[0] == 0 )
update.c:				( obj->extra_value ).v[0] = 0;
update.c:				( obj->extra_value ).v[1] = 0;
update.c:		if ( obj->timer < 0 ) continue;
update.c:		if ( obj->in_obj && obj->in_obj->value[0] == -1 ) continue;
update.c:			obj->carried_by 
update.c:				IS_NPC ( obj->carried_by ) 
update.c:				&& !IS_SET ( obj->carried_by->act, ACT_HORSE )
update.c:		 *  timer ran out contained obj->next. Bug was reported
update.c:		 *  during the same tick.     --Thelonius (Monk)
update.c:		if ( --obj->timer == 0 )
update.c:					if( obj == auction->obj )
update.c:						sprintf ( buf, "¥Ñ©ó%s®ø¥¢¤F¡A©ç½æ¤¤¤î¡C", obj->short_descr);
update.c:						talk_channel ( auction->owner , buf, CHANNEL_AUCTION, "¡i©ç½æ¡j",HIY );
update.c:							auction_list = auction_list->next;
update.c:							for( auc_next = auction_list ; auc_next; auc_next = auc_next->next )
update.c:								if( auc_next->next == auction )
update.c:									auc_next->next = auction->next;
update.c:									auc_next = auction->next;
update.c:					auc_next = auction->next;
update.c:			if( IS_SET ( obj->extra_flags, ITEM_BROKEN ) )
update.c:				REMOVE_BIT ( obj->extra_flags, ITEM_BROKEN );
update.c:				obj->timer = -1;
update.c:				if ( obj->carried_by )
update.c:				act( "$p º¥º¥´_­ì¤F.", obj->carried_by, obj, NULL, TO_CHAR );
update.c:			if ( IS_SET ( obj->extra_flags, ITEM_POISONED_WEAPON ) )
update.c:					SET_BIT( obj->extra_flags, ITEM_BROKEN );
update.c:					obj->timer = 120;
update.c:					obj->timer = -1;
update.c:					obj->value[0] = 0;
update.c:				REMOVE_BIT( obj->extra_flags, ITEM_POISONED );
update.c:				REMOVE_BIT( obj->extra_flags, ITEM_POISONED_WEAPON );
update.c:				if ( obj->carried_by )
update.c:					act( "$p ªº¬rº¥º¥®ø´²¤F.", obj->carried_by, obj, NULL, TO_CHAR );
update.c:					if( obj->wear_loc > -1 )
update.c:						act( "$p ¤w¸g¤£¯à¦A¨Ï¥Î¤F.", obj->carried_by, obj, NULL, TO_CHAR );
update.c:						act( "$n ²æ¤U $p.", obj->carried_by, obj, NULL, TO_ROOM );
update.c:						act( "§A²æ¤U $p.", obj->carried_by, obj, NULL, TO_CHAR );
update.c:						unequip_char(obj->carried_by, obj);
update.c:			switch ( obj->item_type )
update.c:			if ( obj->carried_by )
update.c:				act( message, obj->carried_by, obj, NULL, TO_CHAR );
update.c:					obj->in_room
update.c:					&& ( rch = obj->in_room->people )
update.c:				for ( previous = object_list; previous; previous = previous->next )
update.c:					if ( previous->next == obj )
update.c:					bug( "Obj_update: obj %d no longer in object_list", obj->pIndexData->vnum );
update.c:				obj_next = previous->next;
update.c:		}// end if obj->timer == 0
update.c:			if ( !auction->buyer )
update.c:				if( auction->time >= 4 )
update.c:					obj_to_char ( auction->obj, auction->owner );
update.c:					sprintf ( buf, "§Aªº %s µL¤H²z·|¡A©ç½æ¥¢±Ñ¤F¡C\n\r", auction->obj->short_descr );
update.c:					send_to_char ( buf, auction->owner );
update.c:						auction_list = auction_list->next;
update.c:						for( auc_next = auction_list ; auc_next; auc_next = auc_next->next )
update.c:							if( auc_next->next == auction )
update.c:								auc_next->next = auction->next;
update.c:								auc_next = auction->next;
update.c:						auction->obj->short_descr,
update.c:						auction->price );
update.c:					talk_channel ( auction->owner, buf, CHANNEL_AUCTION, "¡i©ç½æ¡j",HIY );
update.c:					auction->time++;
update.c:					auc_next = auction->next;
update.c:			if ( auction->time >= 2 )
update.c:					auction->buyer->name,
update.c:					auction->price,
update.c:					auction->obj->short_descr );
update.c:				talk_channel ( auction->owner, buf, CHANNEL_AUCTION, "¡i©ç½æ¡j",HIY );
update.c:				obj_to_char ( auction->obj, auction->buyer );
update.c:				save_char_obj( auction->buyer );
update.c:				send_to_char (CYN"©ç½æ·|°u¦¬ 5% ªº¦¬¤J°µ¬°¤âÄò¶O¡C"NOR"\n\r", auction->owner );
update.c:				sprintf ( buf,CYN"©ç½æ·|¬°§A°e¨Ó%s¡C"NOR"\n\r", auction->obj->short_descr );
update.c:				send_to_char (buf, auction->buyer );
update.c:				if( auction->owner->in_room->area->clan )
update.c:					auction->owner->in_room->area->clan->bank += ( auction->price / 30 );
update.c:					sprintf (buf, CYN"3%% ªº¥æ©ö¶O¥ÎÂà¥æ%s°µ¬°³õ¦a´£¨Ñ¶O¡C"NOR"\n\r", auction->owner->in_room->area->clan->name );
update.c:					send_to_char (buf, auction->owner );
update.c:				//auction->buyer->gold = auction->buyer->gold - auction->price;
update.c:				auction->owner->bank += ( auction->price - auction->price / 20 );
update.c:				save_char_obj ( auction->owner );
update.c:					auction_list = auction_list->next;
update.c:					for ( auc_next = auction_list ; auc_next; auc_next = auc_next->next )
update.c:						if( auc_next->next == auction )
update.c:							auc_next->next = auction->next;
update.c:							auc_next = auction->next;
update.c:				auction->obj->short_descr,
update.c:				auction->price,
update.c:				auction->buyer->name );
update.c:			auction->time++;
update.c:			talk_channel ( auction->owner, buf, CHANNEL_AUCTION, "¡i©ç½æ¡j",HIY );
update.c:			auc_next = auction->next;
update.c: * -Kahn
update.c:     * Let's not worry about link dead characters. -Kahn
update.c:    for ( d = descriptor_list; d; d = d->next )
update.c:  ch = d->character;
update.c:  if ( d->connected != CON_PLAYING
update.c:      || ch->level >= LEVEL_IMMORTAL
update.c:      || !ch->in_room )
update.c:  for ( mch = ch->in_room->people; mch; mch = mch->next_in_room )
update.c:  if ( IS_NPC( mch ) && !mch->deleted && mch->mpactnum > 0
update.c:      && mch->in_room->area->nplayer > 0 )
update.c:      for ( tmp_act = mch->mpact; tmp_act != NULL;
update.c:     tmp_act = tmp_act->next )
update.c:     mprog_wordlist_check( tmp_act->buf,mch, tmp_act->ch,
update.c:              tmp_act->obj, tmp_act->vo, ACT_PROG );
update.c:     free_string( tmp_act->buf );
update.c:      for ( tmp_act = mch->mpact; tmp_act != NULL; tmp_act = tmp2_act )
update.c:     tmp2_act = tmp_act->next;
update.c:      mch->mpactnum = 0;
update.c:      mch->mpact    = NULL;
update.c:    || mch->deleted
update.c:    || mch->fighting
update.c:    || ( IS_SET( mch->act, ACT_WIMPY ) && IS_AWAKE( ch ) )
update.c:    || ( !IS_SET( mch->act, ACT_AGGRESSIVE )
update.c:/*        && ( str_infix( race_table[ch->race].name,
update.c:           race_table[mch->race].hate )
update.c:      || ( !str_infix( race_table[ch->race].name,
update.c:          race_table[mch->race].hate )
update.c:          && abs( mch->level - ch->level ) > 4 ) ) ) )
update.c:      if ( !str_infix( race_table[ch->race].name,
update.c:          race_table[mch->race].hate ) 
update.c:      for ( vch = mch->in_room->people; vch; vch = vch->next_in_room )
update.c:        || vch->deleted
update.c:        || vch->level >= LEVEL_IMMORTAL )
update.c:    if ( ( !IS_SET( mch->act, ACT_WIMPY ) || !IS_AWAKE( vch ) )
update.c://          && !str_infix( race_table[vch->race].name,
update.c://            race_table[mch->race].hate ) ) )
update.c:  wch_next = ch->next;
update.c:  if ( IS_NPC( ch ) && ch->mpactnum > 0)
update.c:      // no reason to wait for that to happen--Slash
update.c:      //     && wch->in_room->area->nplayer > 0 )
update.c:      for ( tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp_act->next )
update.c:    mprog_wordlist_check( tmp_act->buf, ch, tmp_act->ch, tmp_act->obj, tmp_act->vo, 
update.c:    free_string( tmp_act->buf );
update.c:      for ( tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp2_act )
update.c:    tmp2_act = tmp_act->next;
update.c:      ch->mpactnum = 0;
update.c:      ch->mpact = NULL;
update.c:                    (int) ( down_time - current_time ) / 60,
update.c:                    (int) ( down_time - current_time ) ,
update.c:                    (int) ( down_time - current_time ) / 60,
update.c:                    (int) ( down_time - current_time ) ,
update.c:                    (int) ( down_time - current_time ) / 60,
update.c:                    (int) ( down_time - current_time ) ,
update.c:      warning2--;
update.c:      for ( paf = ch->affected; paf; paf = paf_next )
update.c:    paf_next = paf->next;
update.c:    if ( paf->deleted || ch->deleted )
update.c:        if ( ch->affected == paf )
update.c:      ch->affected = paf->next;
update.c:      for ( prev = ch->affected; prev; prev = prev->next )
update.c:          if ( prev->next == paf )
update.c:        prev->next = paf->next;
update.c:        paf->next = affect_free;
update.c:      ch_next = ch->next;
update.c:      if ( ch->deleted )
update.c:        char_list = ch->next;
update.c:        for ( prev = char_list; prev; prev = prev->next )
update.c:      if ( prev->next == ch )
update.c:          prev->next = ch->next;
update.c:        ch->name );
update.c:    for ( ed = obj->extra_descr; ed; ed = ed_next )
update.c:        ed_next = ed->next;
update.c:        if ( obj->deleted )
update.c:      free_string( ed->description );
update.c:      free_string( ed->keyword     );
update.c:      ed->next     = extra_descr_free;
update.c:    for( ohp = obj->hp ; ohp; ohp = ohp_next ) {
update.c:        ohp_next = ohp->next;
update.c:        if( obj->deleted ) {
update.c:      free_string(ohp->hp_name);
update.c:      ohp->next = obj_hp_free;
update.c:    for ( paf = obj->affected; paf; paf = paf_next )
update.c:        paf_next = paf->next;
update.c:        if ( obj->deleted )
update.c:      if ( obj->affected == paf )
update.c:          obj->affected = paf->next;
update.c:          for ( prev = obj->affected; prev; prev = prev->next )
update.c:        if ( prev->next == paf )
update.c:            prev->next = paf->next;
update.c:      paf->next   = affect_free;
update.c:    obj_next = obj->next;
update.c:    if ( obj->deleted )
update.c:      object_list = obj->next;
update.c:      for ( prev = object_list; prev; prev = prev->next )
update.c:          if ( prev->next == obj )
update.c:        prev->next = obj->next;
update.c:        obj->pIndexData->vnum );
update.c:        free_string( obj->name      );
update.c:        free_string( obj->description );
update.c:        free_string( obj->short_descr );
update.c:/*        free_string( obj->cname     );*/
update.c:        --obj->pIndexData->count;
update.c:        obj->next = obj_free;
update.c:            for ( paf = ch->affected; paf; paf = paf_next )
update.c:                paf_next = paf->next;
update.c:                if ( paf->deleted || ch->deleted )
update.c:                    if ( ch->affected == paf )
update.c:                        ch->affected = paf->next;
update.c:                        for ( prev = ch->affected; prev; prev = prev->next )
update.c:                            if ( prev->next == paf )
update.c:                                prev->next = paf->next;
update.c:                    paf->next = affect_free;
update.c:            ch_next = ch->next;
update.c:            if ( ch->deleted )
update.c:                    char_list = ch->next;
update.c:                    for ( prev = char_list; prev; prev = prev->next )
update.c:                        if ( prev->next == ch )
update.c:                            prev->next = ch->next;
update.c:                                ch->name );
update.c:            obj_next = obj->next;
update.c:            if ( obj->deleted )
update.c:                for ( ed = obj->extra_descr; ed; ed = ed_next )
update.c:                    ed_next = ed->next;
update.c:                    free_string( ed->description );
update.c:                    free_string( ed->keyword     );
update.c:                    ed->next     = extra_descr_free;
update.c:                for( ohp = obj->hp ; ohp; ohp = ohp_next ) {
update.c:                    ohp_next = ohp->next;
update.c:                    free_string(ohp->hp_name);
update.c:                    ohp->next = obj_hp_free;
update.c:                for ( paf = obj->affected; paf; paf = paf_next )
update.c:                    paf_next = paf->next;
update.c:                    if ( obj->affected == paf )
update.c:                        obj->affected = paf->next;
update.c:                        for ( prev = obj->affected; prev; prev = prev->next )
update.c:                            if ( prev->next == paf )
update.c:                                prev->next = paf->next;
update.c:                        paf->next   = affect_free;
update.c:                    object_list = obj->next;
update.c:                    for ( prev = object_list; prev; prev = prev->next )
update.c:                        if ( prev->next == obj )
update.c:                            prev->next = obj->next;
update.c:                                obj->pIndexData->vnum );
update.c:                free_string( obj->name      );
update.c:                free_string( obj->description );
update.c:                free_string( obj->short_descr );
update.c:                /*        free_string( obj->cname     );*/
update.c:                --obj->pIndexData->count;
update.c:                obj->next = obj_free;
update.c: * its timer reach 0. -- Amenda
update.c:    if ( qmark->timer > 0 )
update.c:      qmark->timer --;
update.c:      if ( qmark->timer == 0 )
update.c:        qmark_next_in_list = qmark->next_in_list;
update.c:    qmark = qmark->next_in_list;
update.c:    for(mob_action = mob_action_list; mob_action != NULL; mob_action = mob_action->next_in_list){
update.c:        if ( mob_action->owner == NULL
update.c:          || mob_action->owner->deleted
update.c:          || mob_action->owner->position < POS_SLEEPING
update.c:          || mob_action->owner->position == POS_FIGHTING ){
update.c:        if( IS_AFFECTED(mob_action->owner, AFF_CRAZY)
update.c:        || IS_AFFECTED(mob_action->owner, AFF_PARALYZED)){
update.c:        if ( mob_action->start_time != time_info.hour && mob_action->mode != 1){
update.c:            mob_action->mode = 0;
update.c:        if ( mob_action->mode == 0 ){
update.c:            mob_action->mode = 1;
update.c:        if( mob_action->mode == 2 ){
update.c:        mob  = mob_action->owner;
update.c:        cmnd = mob_action->com_list;
update.c:            mob_action->mode = 2;
update.c:            mob_action->com_list = mob_action->old_com_list;
update.c:        //  if( mob_action->mode == 2 ) {
update.c:        //      mob_action = mob_action->next_in_list;
update.c:            mob_action->com_list = action_next_command( mob_action->com_list );
update.c:      if ( !mob->deleted )
update.c:    if ( !mob->deleted )
update.c:// Deduct room timer -- Amenda
update.c:      for( rprg = rprg_list; rprg; rprg = rprg->next_in_list )
update.c:      if ( rprg->timer[0] > 0 )
update.c:        --rprg->timer[0];
update.c:        if (rprg->timer[0] == 0 )
update.c:          rprg->v0 = 0;
update.c:          rprg->v1 = 0;
update.c:            if( rprg->timer[1] > 0 )
update.c:        --rprg->timer[1];
update.c:      for( rprg = rprg_list; rprg; rprg = rprg->next_in_list )
update.c:    if ( ( rprg->type & ROOM_RAND ) && rprg->owner->people )
update.c:      for( rprg = rprg_list; rprg; rprg = rprg->next_in_list )
update.c://    if ( ( rprg->type & ROOM_TIME ) && rprg->owner->people )
update.c:    if ( ( rprg->type & ROOM_TIME ) )
update.c:    for ( pban = ban_list; pban; pban = pban->next )
update.c:  fprintf( fp, "%s~\n", pban->name );
update.c:    for( vch = paf->owner->people; vch ; vch = vch->next_in_room){
update.c:  r_damage(paf->owner, vch, paf->modifier,skill_lookup("fire wall"));
update.c:    for( paf = r_affect_list; paf; paf = paf->next_in_list ) {
update.c:  if( paf->duration == 0 ) r_affect_remove(paf->owner, paf);
update.c:  else if( paf->duration > 0 ) --paf->duration;
update.c:  if( paf->bitvector == R_AFF_FIREWALL) firewall_update(paf);
update.c: * Random times to defeat tick-timing clients and players.
update.c:    if ( --pulse_area   <= 0 )
update.c:    if ( --pulse_call_out <= 0 )
update.c:    if ( --pulse_violence <= 0 )
update.c:    if ( --pulse_mobile   <= 0 )
update.c:    if ( --pulse_point    <= 0 )
update.c:    if ( --pulse_db_dump  <= 0 )
update.c:  for ( ch = char_list; ch; ch = ch->next )
update.c:    if( ch->forced )
update.c:      ch->forced = FALSE;
update.c:  cod_next = cod->next;
update.c:  if( !cod->owner ) {
update.c:  if( --cod->timer <= 0 ) {
update.c:      rinterpret( cod->owner, NULL,cod->cmd);
update.c:  cod_next = cod->next;
update.c:  if( !cod->owner || cod->owner->deleted || !cod->owner->in_room ) {
update.c:  if( --cod->timer <= 0 ) {
update.c:      if( !IS_AFFECTED( cod->owner, AFF_CHARM ) )
update.c:    interpret( cod->owner, cod->cmd);
